<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>LoadStoreVectorizer.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This pass merges loads/stores to/from sequential memory addresses into vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// loads/stores.  Although there's nothing GPU-specific in here, this pass is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">// motivated by the microarchitectural quirks of nVidia and AMD GPUs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">// (For simplicity below we talk about loads only, but everything also applies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">// to stores.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">// This pass is intended to be run late in the pipeline, after other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">// vectorization opportunities have been exploited.  So the assumption here is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">// that immediately following our new vector load we'll need to extract out the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">// individual elements of the load, so we can operate on them individually.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">// On CPUs this transformation is usually not beneficial, because extracting the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">// elements of a vector register is expensive on most architectures.  It's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">// usually better just to load each element individually into its own scalar</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">// register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">// However, nVidia and AMD GPUs don't have proper vector registers.  Instead, a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">// "vector load" loads directly into a series of scalar registers.  In effect,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">// extracting the elements of the vector is free.  It's therefore always</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">// beneficial to vectorize a sequence of loads on these architectures.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">// Vectorizing (perhaps a better name might be "coalescing") loads can have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">// large performance impacts on GPU kernels, and opportunities for vectorizing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">// are common in GPU code.  This pass tries very hard to find such</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">// opportunities; its runtime is quadratic in the number of loads in a BB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">// Some CPU architectures, such as ARM, have instructions that load into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">// multiple scalar registers, similar to a GPU vectorized load.  In theory ARM</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">// could use this pass (with some modifications), but currently it implements</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">// its own pass to do something similar to what we do here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">// Overview of the algorithm and terminology in this pass:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">//  - Break up each basic block into pseudo-BBs, composed of instructions which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">//    are guaranteed to transfer control to their successors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">//  - Within a single pseudo-BB, find all loads, and group them into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">//    "equivalence classes" according to getUnderlyingObject() and loaded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">//    element size.  Do the same for stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">//  - For each equivalence class, greedily build "chains".  Each chain has a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">//    leader instruction, and every other member of the chain has a known</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">//    constant offset from the first instr in the chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">//  - Break up chains so that they contain only contiguous accesses of legal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">//    size with no intervening may-alias instrs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">//  - Convert each chain to vector instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">// The O(n^2) behavior of this pass comes from initially building the chains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">// In the worst case we have to compare each new instruction to all of those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">// that came before. To limit this, we only calculate the offset to the leaders</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">// of the N most recently-used chains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">#include "llvm/Transforms/Vectorize/LoadStoreVectorizer.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">#include "llvm/ADT/MapVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">#include "llvm/ADT/STLExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">#include "llvm/ADT/Sequence.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">#include "llvm/ADT/Statistic.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">#include "llvm/ADT/iterator_range.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">#include "llvm/Analysis/ValueTracking.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">#include "llvm/Analysis/VectorUtils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">#include "llvm/IR/Attributes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">#include "llvm/IR/BasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">#include "llvm/IR/ConstantRange.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">#include "llvm/IR/Constants.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">#include "llvm/IR/DataLayout.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">#include "llvm/IR/DerivedTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">#include "llvm/IR/Dominators.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">#include "llvm/IR/IRBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">#include "llvm/IR/InstrTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">#include "llvm/IR/LLVMContext.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">#include "llvm/IR/Module.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">#include "llvm/IR/Type.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">#include "llvm/IR/Value.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">#include "llvm/Support/Alignment.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">#include "llvm/Support/Casting.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">#include "llvm/Support/KnownBits.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">#include "llvm/Support/MathExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">#include "llvm/Support/ModRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">#include "llvm/Transforms/Utils/Local.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">#include "llvm/Transforms/Vectorize.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">#include <cstdlib></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">#include <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">#include <limits></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">#include <numeric></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">#include <optional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">#include <tuple></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">#include <type_traits></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">#include <vector></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">#define DEBUG_TYPE "load-store-vectorizer"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">STATISTIC(NumVectorInstructions, "Number of vector accesses generated");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">STATISTIC(NumScalarsVectorized, "Number of scalar accesses vectorized");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">// Equivalence class key, the initial tuple by which we group loads/stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">// Loads/stores with different EqClassKeys are never merged.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">// (We could in theory remove element-size from the this tuple.  We'd just need</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">// to fix up the vector packing/unpacking code.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">using EqClassKey =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">    std::tuple<const Value * /* result of getUnderlyingObject() */,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">               unsigned /* AddrSpace */,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">               unsigned /* Load/Store element size bits */,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">               char /* IsLoad; char b/c bool can't be a DenseMap key */</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">               >;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="uncoveredLine">[[maybe_unused]] llvm::raw_ostream &operator<<(llvm::raw_ostream &OS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">                                               const EqClassKey &K) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="uncoveredLine">  const auto &[UnderlyingObject, AddrSpace, ElementSize, IsLoad] = K;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="uncoveredLine">  return OS << (IsLoad ? "load" : "store") << " of " << *UnderlyingObject</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="uncoveredLine">            << " of element size " << ElementSize << " bits in addrspace "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="uncoveredLine">            << AddrSpace;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">// A Chain is a set of instructions such that:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">//  - All instructions have the same equivalence class, so in particular all are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">//    loads, or all are stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">//  - We know the address accessed by the i'th chain elem relative to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">//    chain's leader instruction, which is the first instr of the chain in BB</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">//    order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">// Chains have two canonical orderings:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">//  - BB order, sorted by Instr->comesBefore.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">//  - Offset order, sorted by OffsetFromLeader.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">// This pass switches back and forth between these orders.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">struct ChainElem {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">  Instruction *Inst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  APInt OffsetFromLeader;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">using Chain = SmallVector<ChainElem, 1>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">void sortChainInBBOrder(Chain &C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="uncoveredLine">  sort(C, [](auto &A, auto &B) { return A.Inst->comesBefore(B.Inst); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">void sortChainInOffsetOrder(Chain &C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">  sort(C, [](const auto &A, const auto &B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="uncoveredLine">    if (A.OffsetFromLeader != B.OffsetFromLeader)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="uncoveredLine">      return A.OffsetFromLeader.slt(B.OffsetFromLeader);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="uncoveredLine">    return A.Inst->comesBefore(B.Inst); // stable tiebreaker</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="uncoveredLine">[[maybe_unused]] void dumpChain(ArrayRef<ChainElem> C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="uncoveredLine">  for (const auto &E : C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="uncoveredLine">    dbgs() << "  " << *E.Inst << " (offset " << E.OffsetFromLeader << ")\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">using EquivalenceClassMap =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">    MapVector<EqClassKey, SmallVector<Instruction *, 8>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">// FIXME: Assuming stack alignment of 4 is always good enough</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">constexpr unsigned StackAdjustedAlignment = 4;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="uncoveredLine">Instruction *propagateMetadata(Instruction *I, const Chain &C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="uncoveredLine">  SmallVector<Value *, 8> Values;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">  for (const ChainElem &E : C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="uncoveredLine">    Values.push_back(E.Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">  return propagateMetadata(I, Values);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="uncoveredLine">bool isInvariantLoad(const Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">  const LoadInst *LI = dyn_cast<LoadInst>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="uncoveredLine">  return LI != nullptr && LI->hasMetadata(LLVMContext::MD_invariant_load);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">/// Reorders the instructions that I depends on (the instructions defining its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">/// operands), to ensure they dominate I.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">void reorder(Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="uncoveredLine">  SmallPtrSet<Instruction *, 16> InstructionsToMove;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="uncoveredLine">  SmallVector<Instruction *, 16> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="uncoveredLine">  Worklist.push_back(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="uncoveredLine">    Instruction *IW = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="uncoveredLine">    int NumOperands = IW->getNumOperands();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="uncoveredLine">    for (int i = 0; i < NumOperands; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">      Instruction *IM = dyn_cast<Instruction>(IW->getOperand(i));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="uncoveredLine">      if (!IM || IM->getOpcode() == Instruction::PHI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">      // If IM is in another BB, no need to move it, because this pass only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">      // vectorizes instructions within one BB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="uncoveredLine">      if (IM->getParent() != I->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="uncoveredLine">      if (!IM->comesBefore(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="uncoveredLine">        InstructionsToMove.insert(IM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="uncoveredLine">        Worklist.push_back(IM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">  // All instructions to move should follow I. Start from I, not from begin().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">  for (auto BBI = I->getIterator(), E = I->getParent()->end(); BBI != E;) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="uncoveredLine">    Instruction *IM = &*(BBI++);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">    if (!InstructionsToMove.count(IM))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">    IM->moveBefore(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">class Vectorizer {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">  Function &F;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">  AliasAnalysis &AA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">  AssumptionCache &AC;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">  DominatorTree &DT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">  ScalarEvolution &SE;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">  TargetTransformInfo &TTI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  const DataLayout &DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">  IRBuilder<> Builder;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">  // We could erase instrs right after vectorizing them, but that can mess up</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">  // our BB iterators, and also can make the equivalence class keys point to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">  // freed memory.  This is fixable, but it's simpler just to wait until we're</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  // done with the BB and erase all at once.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">  SmallVector<Instruction *, 128> ToErase;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="uncoveredLine">  Vectorizer(Function &F, AliasAnalysis &AA, AssumptionCache &AC,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">             DominatorTree &DT, ScalarEvolution &SE, TargetTransformInfo &TTI)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">      : F(F), AA(AA), AC(AC), DT(DT), SE(SE), TTI(TTI),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="uncoveredLine">        DL(F.getParent()->getDataLayout()), Builder(SE.getContext()) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">  bool run();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">  static const unsigned MaxDepth = 3;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  /// Runs the vectorizer on a "pseudo basic block", which is a range of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">  /// instructions [Begin, End) within one BB all of which have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">  /// isGuaranteedToTransferExecutionToSuccessor(I) == true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  bool runOnPseudoBB(BasicBlock::iterator Begin, BasicBlock::iterator End);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  /// Runs the vectorizer on one equivalence class, i.e. one set of loads/stores</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">  /// in the same BB with the same value for getUnderlyingObject() etc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  bool runOnEquivalenceClass(const EqClassKey &EqClassKey,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">                             ArrayRef<Instruction *> EqClass);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">  /// Runs the vectorizer on one chain, i.e. a subset of an equivalence class</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">  /// where all instructions access a known, constant offset from the first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">  /// instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">  bool runOnChain(Chain &C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">  /// Splits the chain into subchains of instructions which read/write a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">  /// contiguous block of memory.  Discards any length-1 subchains (because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">  /// there's nothing to vectorize in there).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">  std::vector<Chain> splitChainByContiguity(Chain &C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">  /// Splits the chain into subchains where it's safe to hoist loads up to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">  /// beginning of the sub-chain and it's safe to sink loads up to the end of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">  /// the sub-chain.  Discards any length-1 subchains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  std::vector<Chain> splitChainByMayAliasInstrs(Chain &C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">  /// Splits the chain into subchains that make legal, aligned accesses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">  /// Discards any length-1 subchains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">  std::vector<Chain> splitChainByAlignment(Chain &C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">  /// Converts the instrs in the chain into a single vectorized load or store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">  /// Adds the old scalar loads/stores to ToErase.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">  bool vectorizeChain(Chain &C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">  /// Tries to compute the offset in bytes PtrB - PtrA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">  std::optional<APInt> getConstantOffset(Value *PtrA, Value *PtrB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">                                         Instruction *ContextInst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">                                         unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">  std::optional<APInt> getConstantOffsetComplexAddrs(Value *PtrA, Value *PtrB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">                                                     Instruction *ContextInst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">                                                     unsigned Depth);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="">  std::optional<APInt> getConstantOffsetSelects(Value *PtrA, Value *PtrB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">                                                Instruction *ContextInst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">                                                unsigned Depth);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">  /// Gets the element type of the vector that the chain will load or store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">  /// This is nontrivial because the chain may contain elements of different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">  /// types; e.g. it's legal to have a chain that contains both i32 and float.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">  Type *getChainElemTy(const Chain &C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">  /// Determines whether ChainElem can be moved up (if IsLoad) or down (if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">  /// !IsLoad) to ChainBegin -- i.e. there are no intervening may-alias</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">  /// instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">  /// The map ChainElemOffsets must contain all of the elements in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">  /// [ChainBegin, ChainElem] and their offsets from some arbitrary base</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">  /// address.  It's ok if it contains additional entries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">  template <bool IsLoadChain></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">  bool isSafeToMove(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">      Instruction *ChainElem, Instruction *ChainBegin,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">      const DenseMap<Instruction *, APInt /*OffsetFromLeader*/> &ChainOffsets);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">  /// Collects loads and stores grouped by "equivalence class", where:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">  ///   - all elements in an eq class are a load or all are a store,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">  ///   - they all load/store the same element size (it's OK to have e.g. i8 and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">  ///     <4 x i8> in the same class, but not i32 and <4 x i8>), and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">  ///   - they all have the same value for getUnderlyingObject().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">  EquivalenceClassMap collectEquivalenceClasses(BasicBlock::iterator Begin,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">                                                BasicBlock::iterator End);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">  /// Partitions Instrs into "chains" where every instruction has a known</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">  /// constant offset from the first instr in the chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">  /// Postcondition: For all i, ret[i][0].second == 0, because the first instr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">  /// in the chain is the leader, and an instr touches distance 0 from itself.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">  std::vector<Chain> gatherChains(ArrayRef<Instruction *> Instrs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">class LoadStoreVectorizerLegacyPass : public FunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="uncoveredLine">  LoadStoreVectorizerLegacyPass() : FunctionPass(ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">    initializeLoadStoreVectorizerLegacyPassPass(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">        *PassRegistry::getPassRegistry());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">  bool runOnFunction(Function &F) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="uncoveredLine">  StringRef getPassName() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="uncoveredLine">    return "GPU Load and Store Vectorizer";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="uncoveredLine">    AU.setPreservesCFG();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">char LoadStoreVectorizerLegacyPass::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(LoadStoreVectorizerLegacyPass, DEBUG_TYPE,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">                      "Vectorize load and Store instructions", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(SCEVAAWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(GlobalsAAWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="coveredLine">INITIALIZE_PASS_END(LoadStoreVectorizerLegacyPass, DEBUG_TYPE,</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">                    "Vectorize load and store instructions", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">Pass *llvm::createLoadStoreVectorizerPass() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">  return new LoadStoreVectorizerLegacyPass();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">bool LoadStoreVectorizerLegacyPass::runOnFunction(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">  // Don't vectorize when the attribute NoImplicitFloat is used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">  if (skipFunction(F) || F.hasFnAttribute(Attribute::NoImplicitFloat))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="uncoveredLine">  AliasAnalysis &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="uncoveredLine">  DominatorTree &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">  ScalarEvolution &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  TargetTransformInfo &TTI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="uncoveredLine">      getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">  AssumptionCache &AC =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">      getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="uncoveredLine">  return Vectorizer(F, AA, AC, DT, SE, TTI).run();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="uncoveredLine">PreservedAnalyses LoadStoreVectorizerPass::run(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">                                               FunctionAnalysisManager &AM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  // Don't vectorize when the attribute NoImplicitFloat is used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">  if (F.hasFnAttribute(Attribute::NoImplicitFloat))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">    return PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">  AliasAnalysis &AA = AM.getResult<AAManager>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="uncoveredLine">  DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="uncoveredLine">  ScalarEvolution &SE = AM.getResult<ScalarEvolutionAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="uncoveredLine">  TargetTransformInfo &TTI = AM.getResult<TargetIRAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">  AssumptionCache &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">  bool Changed = Vectorizer(F, AA, AC, DT, SE, TTI).run();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="uncoveredLine">  PreservedAnalyses PA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">  PA.preserveSet<CFGAnalyses>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="uncoveredLine">  return Changed ? PA : PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="uncoveredLine">bool Vectorizer::run() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">  // Break up the BB if there are any instrs which aren't guaranteed to transfer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">  // execution to their successor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">  // Consider, for example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">  //   def assert_arr_len(int n) { if (n < 2) exit(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">  //   load arr[0]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  //   call assert_array_len(arr.length)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">  //   load arr[1]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">  // Even though assert_arr_len does not read or write any memory, we can't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">  // speculate the second load before the call.  More info at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">  // https://github.com/llvm/llvm-project/issues/52950.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">  for (BasicBlock *BB : post_order(&F)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">    // BB must at least have a terminator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="uncoveredLine">    assert(!BB->empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">    SmallVector<BasicBlock::iterator, 8> Barriers;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">    Barriers.push_back(BB->begin());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">    for (Instruction &I : *BB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">      if (!isGuaranteedToTransferExecutionToSuccessor(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">        Barriers.push_back(I.getIterator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="uncoveredLine">    Barriers.push_back(BB->end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="uncoveredLine">    for (auto It = Barriers.begin(), End = std::prev(Barriers.end()); It != End;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">         ++It)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">      Changed |= runOnPseudoBB(*It, *std::next(It));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">    for (Instruction *I : ToErase) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="uncoveredLine">      auto *PtrOperand = getLoadStorePointerOperand(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">      if (I->use_empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="uncoveredLine">        I->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="uncoveredLine">      RecursivelyDeleteTriviallyDeadInstructions(PtrOperand);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">    ToErase.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">bool Vectorizer::runOnPseudoBB(BasicBlock::iterator Begin,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">                               BasicBlock::iterator End) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">    dbgs() << "LSV: Running on pseudo-BB [" << *Begin << " ... ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">    if (End != Begin->getParent()->end())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">      dbgs() << *End;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">      dbgs() << "<BB end>";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">    dbgs() << ")\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="uncoveredLine">  for (const auto &[EqClassKey, EqClass] :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">       collectEquivalenceClasses(Begin, End))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="uncoveredLine">    Changed |= runOnEquivalenceClass(EqClassKey, EqClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="uncoveredLine">bool Vectorizer::runOnEquivalenceClass(const EqClassKey &EqClassKey,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">                                       ArrayRef<Instruction *> EqClass) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">    dbgs() << "LSV: Running on equivalence class of size " << EqClass.size()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="">           << " keyed on " << EqClassKey << ":\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">    for (Instruction *I : EqClass)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">      dbgs() << "  " << *I << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">  std::vector<Chain> Chains = gatherChains(EqClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "LSV: Got " << Chains.size()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">                    << " nontrivial chains.\n";);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="uncoveredLine">  for (Chain &C : Chains)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">    Changed |= runOnChain(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">bool Vectorizer::runOnChain(Chain &C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">    dbgs() << "LSV: Running on chain with " << C.size() << " instructions:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">    dumpChain(C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">  // Split up the chain into increasingly smaller chains, until we can finally</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">  // vectorize the chains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">  // (Don't be scared by the depth of the loop nest here.  These operations are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  // all at worst O(n lg n) in the number of instructions, and splitting chains</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">  // doesn't change the number of instrs.  So the whole loop nest is O(n lg n).)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="uncoveredLine">  for (auto &C : splitChainByMayAliasInstrs(C))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">    for (auto &C : splitChainByContiguity(C))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">      for (auto &C : splitChainByAlignment(C))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="uncoveredLine">        Changed |= vectorizeChain(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">std::vector<Chain> Vectorizer::splitChainByMayAliasInstrs(Chain &C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">  if (C.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="uncoveredLine">    return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">  sortChainInBBOrder(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">    dbgs() << "LSV: splitChainByMayAliasInstrs considering chain:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">    dumpChain(C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">  // We know that elements in the chain with nonverlapping offsets can't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="">  // alias, but AA may not be smart enough to figure this out.  Use a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">  // hashtable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">  DenseMap<Instruction *, APInt /*OffsetFromLeader*/> ChainOffsets;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="uncoveredLine">  for (const auto &E : C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="uncoveredLine">    ChainOffsets.insert({&*E.Inst, E.OffsetFromLeader});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">  // Loads get hoisted up to the first load in the chain.  Stores get sunk</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">  // down to the last store in the chain.  Our algorithm for loads is:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">  //  - Take the first element of the chain.  This is the start of a new chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">  //  - Take the next element of `Chain` and check for may-alias instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">  //    up to the start of NewChain.  If no may-alias instrs, add it to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">  //    NewChain.  Otherwise, start a new NewChain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">  // For stores it's the same except in the reverse direction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">  // We expect IsLoad to be an std::bool_constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">  auto Impl = [&](auto IsLoad) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">    // MSVC is unhappy if IsLoad is a capture, so pass it as an arg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="uncoveredLine">    auto [ChainBegin, ChainEnd] = [&](auto IsLoad) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">      if constexpr (IsLoad())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">        return std::make_pair(C.begin(), C.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">        return std::make_pair(C.rbegin(), C.rend());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="uncoveredLine">    }(IsLoad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="uncoveredLine">    assert(ChainBegin != ChainEnd);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="uncoveredLine">    std::vector<Chain> Chains;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="uncoveredLine">    SmallVector<ChainElem, 1> NewChain;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="uncoveredLine">    NewChain.push_back(*ChainBegin);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="uncoveredLine">    for (auto ChainIt = std::next(ChainBegin); ChainIt != ChainEnd; ++ChainIt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="uncoveredLine">      if (isSafeToMove<IsLoad>(ChainIt->Inst, NewChain.front().Inst,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="uncoveredLine">                               ChainOffsets)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "LSV: No intervening may-alias instrs; can merge "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">                          << *ChainIt->Inst << " into " << *ChainBegin->Inst</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">                          << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="uncoveredLine">        NewChain.push_back(*ChainIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="uncoveredLine">        LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">            dbgs() << "LSV: Found intervening may-alias instrs; cannot merge "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">                   << *ChainIt->Inst << " into " << *ChainBegin->Inst << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="uncoveredLine">        if (NewChain.size() > 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="uncoveredLine">          LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">            dbgs() << "LSV: got nontrivial chain without aliasing instrs:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">            dumpChain(NewChain);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">          });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">          Chains.push_back(std::move(NewChain));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">        // Start a new chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="uncoveredLine">        NewChain = SmallVector<ChainElem, 1>({*ChainIt});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="uncoveredLine">    if (NewChain.size() > 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="uncoveredLine">      LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">        dbgs() << "LSV: got nontrivial chain without aliasing instrs:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">        dumpChain(NewChain);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="">      });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">      Chains.push_back(std::move(NewChain));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">    return Chains;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="uncoveredLine">  if (isa<LoadInst>(C[0].Inst))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">    return Impl(/*IsLoad=*/std::bool_constant<true>());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">  assert(isa<StoreInst>(C[0].Inst));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="uncoveredLine">  return Impl(/*IsLoad=*/std::bool_constant<false>());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="uncoveredLine">std::vector<Chain> Vectorizer::splitChainByContiguity(Chain &C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">  if (C.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">    return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">  sortChainInOffsetOrder(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">    dbgs() << "LSV: splitChainByContiguity considering chain:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">    dumpChain(C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="uncoveredLine">  std::vector<Chain> Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">  Ret.push_back({C.front()});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">  for (auto It = std::next(C.begin()), End = C.end(); It != End; ++It) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">    // `prev` accesses offsets [PrevDistFromBase, PrevReadEnd).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">    auto &CurChain = Ret.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">    const ChainElem &Prev = CurChain.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="uncoveredLine">    unsigned SzBits = DL.getTypeSizeInBits(getLoadStoreType(&*Prev.Inst));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">    assert(SzBits % 8 == 0 && "Non-byte sizes should have been filtered out by "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">                              "collectEquivalenceClass");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">    APInt PrevReadEnd = Prev.OffsetFromLeader + SzBits / 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">    // Add this instruction to the end of the current chain, or start a new one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="uncoveredLine">    bool AreContiguous = It->OffsetFromLeader == PrevReadEnd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "LSV: Instructions are "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">                      << (AreContiguous ? "" : "not ") << "contiguous: "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">                      << *Prev.Inst << " (ends at offset " << PrevReadEnd</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">                      << ") -> " << *It->Inst << " (starts at offset "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">                      << It->OffsetFromLeader << ")\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="uncoveredLine">    if (AreContiguous)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">      CurChain.push_back(*It);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">      Ret.push_back({*It});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">  // Filter out length-1 chains, these are uninteresting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="uncoveredLine">  llvm::erase_if(Ret, [](const auto &Chain) { return Chain.size() <= 1; });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="uncoveredLine">Type *Vectorizer::getChainElemTy(const Chain &C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">  assert(!C.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">  // The rules are:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">  //  - If there are any pointer types in the chain, use an integer type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">  //  - Prefer an integer type if it appears in the chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  //  - Otherwise, use the first type in the chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">  // The rule about pointer types is a simplification when we merge e.g.  a load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">  // of a ptr and a double.  There's no direct conversion from a ptr to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">  // double; it requires a ptrtoint followed by a bitcast.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">  // It's unclear to me if the other rules have any practical effect, but we do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">  // it to match this pass's previous behavior.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="uncoveredLine">  if (any_of(C, [](const ChainElem &E) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="uncoveredLine">        return getLoadStoreType(E.Inst)->getScalarType()->isPointerTy();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">      })) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="uncoveredLine">    return Type::getIntNTy(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">        F.getContext(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">        DL.getTypeSizeInBits(getLoadStoreType(C[0].Inst)->getScalarType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="uncoveredLine">  for (const ChainElem &E : C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="uncoveredLine">    if (Type *T = getLoadStoreType(E.Inst)->getScalarType(); T->isIntegerTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="uncoveredLine">      return T;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">  return getLoadStoreType(C[0].Inst)->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">std::vector<Chain> Vectorizer::splitChainByAlignment(Chain &C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">  // We use a simple greedy algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">  //  - Given a chain of length N, find all prefixes that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">  //    (a) are not longer than the max register length, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="">  //    (b) are a power of 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">  //  - Starting from the longest prefix, try to create a vector of that length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">  //  - If one of them works, great.  Repeat the algorithm on any remaining</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">  //    elements in the chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">  //  - If none of them work, discard the first element and repeat on a chain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">  //    of length N-1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="uncoveredLine">  if (C.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="uncoveredLine">    return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">  sortChainInOffsetOrder(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">    dbgs() << "LSV: splitChainByAlignment considering chain:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">    dumpChain(C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="uncoveredLine">  bool IsLoadChain = isa<LoadInst>(C[0].Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">  auto getVectorFactor = [&](unsigned VF, unsigned LoadStoreSize,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">                             unsigned ChainSizeBytes, VectorType *VecTy) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="uncoveredLine">    return IsLoadChain ? TTI.getLoadVectorFactor(VF, LoadStoreSize,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">                                                 ChainSizeBytes, VecTy)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="uncoveredLine">                       : TTI.getStoreVectorFactor(VF, LoadStoreSize,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="uncoveredLine">                                                  ChainSizeBytes, VecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">  for (const auto &E : C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">    Type *Ty = getLoadStoreType(E.Inst)->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">    assert(isPowerOf2_32(DL.getTypeSizeInBits(Ty)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">           "Should have filtered out non-power-of-two elements in "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">           "collectEquivalenceClasses.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">  unsigned AS = getLoadStoreAddressSpace(C[0].Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">  unsigned VecRegBytes = TTI.getLoadStoreVecRegBitWidth(AS) / 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">  std::vector<Chain> Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">  for (unsigned CBegin = 0; CBegin < C.size(); ++CBegin) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">    // Find candidate chains of size not greater than the largest vector reg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">    // These chains are over the closed interval [CBegin, CEnd].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">    SmallVector<std::pair<unsigned /*CEnd*/, unsigned /*SizeBytes*/>, 8></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="uncoveredLine">        CandidateChains;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">    for (unsigned CEnd = CBegin + 1, Size = C.size(); CEnd < Size; ++CEnd) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">      APInt Sz = C[CEnd].OffsetFromLeader +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="uncoveredLine">                 DL.getTypeStoreSize(getLoadStoreType(C[CEnd].Inst)) -</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">                 C[CBegin].OffsetFromLeader;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">      if (Sz.sgt(VecRegBytes))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">      CandidateChains.push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">          {CEnd, static_cast<unsigned>(Sz.getLimitedValue())});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">    // Consider the longest chain first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">    for (auto It = CandidateChains.rbegin(), End = CandidateChains.rend();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">         It != End; ++It) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="uncoveredLine">      auto [CEnd, SizeBytes] = *It;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">      LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">          dbgs() << "LSV: splitChainByAlignment considering candidate chain ["</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">                 << *C[CBegin].Inst << " ... " << *C[CEnd].Inst << "]\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="uncoveredLine">      Type *VecElemTy = getChainElemTy(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">      // Note, VecElemTy is a power of 2, but might be less than one byte.  For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">      // example, we can vectorize 2 x <2 x i4> to <4 x i4>, and in this case</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="">      // VecElemTy would be i4.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">      unsigned VecElemBits = DL.getTypeSizeInBits(VecElemTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">      // SizeBytes and VecElemBits are powers of 2, so they divide evenly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">      assert((8 * SizeBytes) % VecElemBits == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="uncoveredLine">      unsigned NumVecElems = 8 * SizeBytes / VecElemBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="uncoveredLine">      FixedVectorType *VecTy = FixedVectorType::get(VecElemTy, NumVecElems);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">      unsigned VF = 8 * VecRegBytes / VecElemBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">      // Check that TTI is happy with this vectorization factor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="uncoveredLine">      unsigned TargetVF = getVectorFactor(VF, VecElemBits,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="uncoveredLine">                                          VecElemBits * NumVecElems / 8, VecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="uncoveredLine">      if (TargetVF != VF && TargetVF < NumVecElems) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">        LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">                      "because TargetVF="</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">                   << TargetVF << " != VF=" << VF</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">                   << " and TargetVF < NumVecElems=" << NumVecElems << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">      // Is a load/store with this alignment allowed by TTI and at least as fast</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">      // as an unvectorized load/store?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">      // TTI and F are passed as explicit captures to WAR an MSVC misparse (??).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">      auto IsAllowedAndFast = [&, SizeBytes = SizeBytes, &TTI = TTI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="uncoveredLine">                               &F = F](Align Alignment) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">        if (Alignment.value() % SizeBytes == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">        unsigned VectorizedSpeed = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">        bool AllowsMisaligned = TTI.allowsMisalignedMemoryAccesses(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">            F.getContext(), SizeBytes * 8, AS, Alignment, &VectorizedSpeed);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="uncoveredLine">        if (!AllowsMisaligned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">                     << "LSV: Access of " << SizeBytes << "B in addrspace "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">                     << AS << " with alignment " << Alignment.value()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="">                     << " is misaligned, and therefore can't be vectorized.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">        unsigned ElementwiseSpeed = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">        (TTI).allowsMisalignedMemoryAccesses((F).getContext(), VecElemBits, AS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">                                             Alignment, &ElementwiseSpeed);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">        if (VectorizedSpeed < ElementwiseSpeed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">                     << "LSV: Access of " << SizeBytes << "B in addrspace "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">                     << AS << " with alignment " << Alignment.value()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">                     << " has relative speed " << VectorizedSpeed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="">                     << ", which is lower than the elementwise speed of "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">                     << ElementwiseSpeed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="">                     << ".  Therefore this access won't be vectorized.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="uncoveredLine">      };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">      // If we're loading/storing from an alloca, align it if possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">      // FIXME: We eagerly upgrade the alignment, regardless of whether TTI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">      // tells us this is beneficial.  This feels a bit odd, but it matches</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">      // existing tests.  This isn't *so* bad, because at most we align to 4</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">      // bytes (current value of StackAdjustedAlignment).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">      // FIXME: We will upgrade the alignment of the alloca even if it turns out</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">      // we can't vectorize for some other reason.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="uncoveredLine">      Value *PtrOperand = getLoadStorePointerOperand(C[CBegin].Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="uncoveredLine">      bool IsAllocaAccess = AS == DL.getAllocaAddrSpace() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">                            isa<AllocaInst>(PtrOperand->stripPointerCasts());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="uncoveredLine">      Align Alignment = getLoadStoreAlignment(C[CBegin].Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">      Align PrefAlign = Align(StackAdjustedAlignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">      if (IsAllocaAccess && Alignment.value() % SizeBytes != 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="uncoveredLine">          IsAllowedAndFast(PrefAlign)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="uncoveredLine">        Align NewAlign = getOrEnforceKnownAlignment(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="uncoveredLine">            PtrOperand, PrefAlign, DL, C[CBegin].Inst, nullptr, &DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="uncoveredLine">        if (NewAlign >= Alignment) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">                     << "LSV: splitByChain upgrading alloca alignment from "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">                     << Alignment.value() << " to " << NewAlign.value()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">                     << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="uncoveredLine">          Alignment = NewAlign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="uncoveredLine">      if (!IsAllowedAndFast(Alignment)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="uncoveredLine">        LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">                      "because its alignment is not AllowedAndFast: "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">                   << Alignment.value() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">      if ((IsLoadChain &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">           !TTI.isLegalToVectorizeLoadChain(SizeBytes, Alignment, AS)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="uncoveredLine">          (!IsLoadChain &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="uncoveredLine">           !TTI.isLegalToVectorizeStoreChain(SizeBytes, Alignment, AS))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">        LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">                      "because !isLegalToVectorizeLoad/StoreChain.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">      // Hooray, we can vectorize this chain!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">      Chain &NewChain = Ret.emplace_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">      for (unsigned I = CBegin; I <= CEnd; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="uncoveredLine">        NewChain.push_back(C[I]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="uncoveredLine">      CBegin = CEnd; // Skip over the instructions we've added to the chain.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">bool Vectorizer::vectorizeChain(Chain &C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">  if (C.size() < 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="uncoveredLine">  sortChainInOffsetOrder(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">    dbgs() << "LSV: Vectorizing chain of " << C.size() << " instructions:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">    dumpChain(C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="uncoveredLine">  Type *VecElemTy = getChainElemTy(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">  bool IsLoadChain = isa<LoadInst>(C[0].Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">  unsigned AS = getLoadStoreAddressSpace(C[0].Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">  unsigned ChainBytes = std::accumulate(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">      C.begin(), C.end(), 0u, [&](unsigned Bytes, const ChainElem &E) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">        return Bytes + DL.getTypeStoreSize(getLoadStoreType(E.Inst));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">      });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">  assert(ChainBytes % DL.getTypeStoreSize(VecElemTy) == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">  // VecTy is a power of 2 and 1 byte at smallest, but VecElemTy may be smaller</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">  // than 1 byte (e.g. VecTy == <32 x i1>).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">  Type *VecTy = FixedVectorType::get(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">      VecElemTy, 8 * ChainBytes / DL.getTypeSizeInBits(VecElemTy));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="uncoveredLine">  Align Alignment = getLoadStoreAlignment(C[0].Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">  // If this is a load/store of an alloca, we might have upgraded the alloca's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="">  // alignment earlier.  Get the new alignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">  if (AS == DL.getAllocaAddrSpace()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="uncoveredLine">    Alignment = std::max(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="">        Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">        getOrEnforceKnownAlignment(getLoadStorePointerOperand(C[0].Inst),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">                                   MaybeAlign(), DL, C[0].Inst, nullptr, &DT));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">  // All elements of the chain must have the same scalar-type size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="uncoveredLine">  for (const ChainElem &E : C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="uncoveredLine">    assert(DL.getTypeStoreSize(getLoadStoreType(E.Inst)->getScalarType()) ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">           DL.getTypeStoreSize(VecElemTy));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">  Instruction *VecInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="uncoveredLine">  if (IsLoadChain) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">    // Loads get hoisted to the location of the first load in the chain.  We may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">    // also need to hoist the (transitive) operands of the loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="uncoveredLine">    Builder.SetInsertPoint(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="uncoveredLine">        std::min_element(C.begin(), C.end(), [](const auto &A, const auto &B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="uncoveredLine">          return A.Inst->comesBefore(B.Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">        })->Inst);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">    // Chain is in offset order, so C[0] is the instr with the lowest offset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="">    // i.e. the root of the vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">    Value *Bitcast = Builder.CreateBitCast(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="uncoveredLine">        getLoadStorePointerOperand(C[0].Inst), VecTy->getPointerTo(AS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="uncoveredLine">    VecInst = Builder.CreateAlignedLoad(VecTy, Bitcast, Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="uncoveredLine">    unsigned VecIdx = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="uncoveredLine">    for (const ChainElem &E : C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="uncoveredLine">      Instruction *I = E.Inst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">      Value *V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">      Type *T = getLoadStoreType(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="uncoveredLine">      if (auto *VT = dyn_cast<FixedVectorType>(T)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">        auto Mask = llvm::to_vector<8>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="uncoveredLine">            llvm::seq<int>(VecIdx, VecIdx + VT->getNumElements()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="uncoveredLine">        V = Builder.CreateShuffleVector(VecInst, Mask, I->getName());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="uncoveredLine">        VecIdx += VT->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">      } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">        V = Builder.CreateExtractElement(VecInst, Builder.getInt32(VecIdx),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">                                         I->getName());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">        ++VecIdx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="uncoveredLine">      if (V->getType() != I->getType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">        V = Builder.CreateBitOrPointerCast(V, I->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">      I->replaceAllUsesWith(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="">    // Finally, we need to reorder the instrs in the BB so that the (transitive)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="">    // operands of VecInst appear before it.  To see why, suppose we have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">    // vectorized the following code:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">    //   ptr1  = gep a, 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">    //   load1 = load i32 ptr1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">    //   ptr0  = gep a, 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">    //   load0 = load i32 ptr0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">    // We will put the vectorized load at the location of the earliest load in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">    // the BB, i.e. load1.  We get:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">    //   ptr1  = gep a, 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="">    //   loadv = load <2 x i32> ptr0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">    //   load0 = extractelement loadv, 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">    //   load1 = extractelement loadv, 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">    //   ptr0 = gep a, 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">    // Notice that loadv uses ptr0, which is defined *after* it!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">    reorder(VecInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">    // Stores get sunk to the location of the last store in the chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="uncoveredLine">    Builder.SetInsertPoint(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">        std::max_element(C.begin(), C.end(), [](auto &A, auto &B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="uncoveredLine">          return A.Inst->comesBefore(B.Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">        })->Inst);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">    // Build the vector to store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">    Value *Vec = PoisonValue::get(VecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="uncoveredLine">    unsigned VecIdx = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="uncoveredLine">    auto InsertElem = [&](Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">      if (V->getType() != VecElemTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="uncoveredLine">        V = Builder.CreateBitOrPointerCast(V, VecElemTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="uncoveredLine">      Vec = Builder.CreateInsertElement(Vec, V, Builder.getInt32(VecIdx++));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">    };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="uncoveredLine">    for (const ChainElem &E : C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="uncoveredLine">      auto I = cast<StoreInst>(E.Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="uncoveredLine">      if (FixedVectorType *VT =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="uncoveredLine">              dyn_cast<FixedVectorType>(getLoadStoreType(I))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">        for (int J = 0, JE = VT->getNumElements(); J < JE; ++J) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="uncoveredLine">          InsertElem(Builder.CreateExtractElement(I->getValueOperand(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="uncoveredLine">                                                  Builder.getInt32(J)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">        InsertElem(I->getValueOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">    // Chain is in offset order, so C[0] is the instr with the lowest offset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="">    // i.e. the root of the vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">    VecInst = Builder.CreateAlignedStore(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">        Vec,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="uncoveredLine">        Builder.CreateBitCast(getLoadStorePointerOperand(C[0].Inst),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="uncoveredLine">                              VecTy->getPointerTo(AS)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">        Alignment);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="uncoveredLine">  propagateMetadata(VecInst, C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="uncoveredLine">  for (const ChainElem &E : C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="uncoveredLine">    ToErase.push_back(E.Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">  ++NumVectorInstructions;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">  NumScalarsVectorized += C.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">template <bool IsLoadChain></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">bool Vectorizer::isSafeToMove(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">    Instruction *ChainElem, Instruction *ChainBegin,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">    const DenseMap<Instruction *, APInt /*OffsetFromLeader*/> &ChainOffsets) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "LSV: isSafeToMove(" << *ChainElem << " -> "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">                    << *ChainBegin << ")\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="uncoveredLine">  assert(isa<LoadInst>(ChainElem) == IsLoadChain);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="uncoveredLine">  if (ChainElem == ChainBegin)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">  // Invariant loads can always be reordered; by definition they are not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">  // clobbered by stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="uncoveredLine">  if (isInvariantLoad(ChainElem))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="uncoveredLine">  auto BBIt = std::next([&] {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="">    if constexpr (IsLoadChain)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="uncoveredLine">      return BasicBlock::reverse_iterator(ChainElem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="uncoveredLine">      return BasicBlock::iterator(ChainElem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">  }());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="uncoveredLine">  auto BBItEnd = std::next([&] {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">    if constexpr (IsLoadChain)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">      return BasicBlock::reverse_iterator(ChainBegin);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">      return BasicBlock::iterator(ChainBegin);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="">  }());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">  const APInt &ChainElemOffset = ChainOffsets.at(ChainElem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="uncoveredLine">  const unsigned ChainElemSize =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="uncoveredLine">      DL.getTypeStoreSize(getLoadStoreType(ChainElem));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="uncoveredLine">  for (; BBIt != BBItEnd; ++BBIt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="uncoveredLine">    Instruction *I = &*BBIt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">    if (!I->mayReadOrWriteMemory())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">    // Loads can be reordered with other loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="uncoveredLine">    if (IsLoadChain && isa<LoadInst>(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">    // Stores can be sunk below invariant loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="uncoveredLine">    if (!IsLoadChain && isInvariantLoad(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">    // If I is in the chain, we can tell whether it aliases ChainIt by checking</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">    // what offset ChainIt accesses.  This may be better than AA is able to do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">    // We should really only have duplicate offsets for stores (the duplicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="">    // loads should be CSE'ed), but in case we have a duplicate load, we'll</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">    // split the chain so we don't have to handle this case specially.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">    if (auto OffsetIt = ChainOffsets.find(I); OffsetIt != ChainOffsets.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">      // I and ChainElem overlap if:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">      //   - I and ChainElem have the same offset, OR</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">      //   - I's offset is less than ChainElem's, but I touches past the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">      //     beginning of ChainElem, OR</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">      //   - ChainElem's offset is less than I's, but ChainElem touches past the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">      //     beginning of I.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="uncoveredLine">      const APInt &IOffset = OffsetIt->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="uncoveredLine">      unsigned IElemSize = DL.getTypeStoreSize(getLoadStoreType(I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">      if (IOffset == ChainElemOffset ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="uncoveredLine">          (IOffset.sle(ChainElemOffset) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="uncoveredLine">           (IOffset + IElemSize).sgt(ChainElemOffset)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="uncoveredLine">          (ChainElemOffset.sle(IOffset) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="uncoveredLine">           (ChainElemOffset + ChainElemSize).sgt(OffsetIt->second))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="uncoveredLine">        LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">          // Double check that AA also sees this alias.  If not, we probably</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="">          // have a bug.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">          ModRefInfo MR = AA.getModRefInfo(I, MemoryLocation::get(ChainElem));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">          assert(IsLoadChain ? isModSet(MR) : isModOrRefSet(MR));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">          dbgs() << "LSV: Found alias in chain: " << *I << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">        });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="uncoveredLine">        return false; // We found an aliasing instruction; bail.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="uncoveredLine">      continue; // We're confident there's no alias.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "LSV: Querying AA for " << *I << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="uncoveredLine">    ModRefInfo MR = AA.getModRefInfo(I, MemoryLocation::get(ChainElem));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="uncoveredLine">    if (IsLoadChain ? isModSet(MR) : isModOrRefSet(MR)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "LSV: Found alias in chain:\n"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">                        << "  Aliasing instruction:\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">                        << "    " << *I << '\n'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">                        << "  Aliased instruction and pointer:\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="">                        << "    " << *ChainElem << '\n'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">                        << "    " << *getLoadStorePointerOperand(ChainElem)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="">                        << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="uncoveredLine">static bool checkNoWrapFlags(Instruction *I, bool Signed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">  BinaryOperator *BinOpI = cast<BinaryOperator>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="uncoveredLine">  return (Signed && BinOpI->hasNoSignedWrap()) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">         (!Signed && BinOpI->hasNoUnsignedWrap());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="uncoveredLine">static bool checkIfSafeAddSequence(const APInt &IdxDiff, Instruction *AddOpA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="">                                   unsigned MatchingOpIdxA, Instruction *AddOpB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="">                                   unsigned MatchingOpIdxB, bool Signed) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "LSV: checkIfSafeAddSequence IdxDiff=" << IdxDiff</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="">                    << ", AddOpA=" << *AddOpA << ", MatchingOpIdxA="</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">                    << MatchingOpIdxA << ", AddOpB=" << *AddOpB</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="">                    << ", MatchingOpIdxB=" << MatchingOpIdxB</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="">                    << ", Signed=" << Signed << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">  // If both OpA and OpB are adds with NSW/NUW and with one of the operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="">  // being the same, we can guarantee that the transformation is safe if we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="">  // prove that OpA won't overflow when Ret added to the other operand of OpA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">  // For example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="">  //  %tmp7 = add nsw i32 %tmp2, %v0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">  //  %tmp8 = sext i32 %tmp7 to i64</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="">  //  ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">  //  %tmp11 = add nsw i32 %v0, 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">  //  %tmp12 = add nsw i32 %tmp2, %tmp11</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="">  //  %tmp13 = sext i32 %tmp12 to i64</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">  //  Both %tmp7 and %tmp12 have the nsw flag and the first operand is %tmp2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">  //  It's guaranteed that adding 1 to %tmp7 won't overflow because %tmp11 adds</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">  //  1 to %v0 and both %tmp11 and %tmp12 have the nsw flag.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="uncoveredLine">  assert(AddOpA->getOpcode() == Instruction::Add &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">         AddOpB->getOpcode() == Instruction::Add &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">         checkNoWrapFlags(AddOpA, Signed) && checkNoWrapFlags(AddOpB, Signed));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">  if (AddOpA->getOperand(MatchingOpIdxA) ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">      AddOpB->getOperand(MatchingOpIdxB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="uncoveredLine">    Value *OtherOperandA = AddOpA->getOperand(MatchingOpIdxA == 1 ? 0 : 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="uncoveredLine">    Value *OtherOperandB = AddOpB->getOperand(MatchingOpIdxB == 1 ? 0 : 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="uncoveredLine">    Instruction *OtherInstrA = dyn_cast<Instruction>(OtherOperandA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="uncoveredLine">    Instruction *OtherInstrB = dyn_cast<Instruction>(OtherOperandB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="">    // Match `x +nsw/nuw y` and `x +nsw/nuw (y +nsw/nuw IdxDiff)`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">    if (OtherInstrB && OtherInstrB->getOpcode() == Instruction::Add &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="uncoveredLine">        checkNoWrapFlags(OtherInstrB, Signed) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="uncoveredLine">        isa<ConstantInt>(OtherInstrB->getOperand(1))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">      int64_t CstVal =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="uncoveredLine">          cast<ConstantInt>(OtherInstrB->getOperand(1))->getSExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="uncoveredLine">      if (OtherInstrB->getOperand(0) == OtherOperandA &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="uncoveredLine">          IdxDiff.getSExtValue() == CstVal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">    // Match `x +nsw/nuw (y +nsw/nuw -Idx)` and `x +nsw/nuw (y +nsw/nuw x)`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="uncoveredLine">    if (OtherInstrA && OtherInstrA->getOpcode() == Instruction::Add &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="uncoveredLine">        checkNoWrapFlags(OtherInstrA, Signed) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="uncoveredLine">        isa<ConstantInt>(OtherInstrA->getOperand(1))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">      int64_t CstVal =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="uncoveredLine">          cast<ConstantInt>(OtherInstrA->getOperand(1))->getSExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="uncoveredLine">      if (OtherInstrA->getOperand(0) == OtherOperandB &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="uncoveredLine">          IdxDiff.getSExtValue() == -CstVal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="">    // Match `x +nsw/nuw (y +nsw/nuw c)` and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="">    // `x +nsw/nuw (y +nsw/nuw (c + IdxDiff))`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">    if (OtherInstrA && OtherInstrB &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">        OtherInstrA->getOpcode() == Instruction::Add &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">        OtherInstrB->getOpcode() == Instruction::Add &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="uncoveredLine">        checkNoWrapFlags(OtherInstrA, Signed) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">        checkNoWrapFlags(OtherInstrB, Signed) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="uncoveredLine">        isa<ConstantInt>(OtherInstrA->getOperand(1)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">        isa<ConstantInt>(OtherInstrB->getOperand(1))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="">      int64_t CstValA =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">          cast<ConstantInt>(OtherInstrA->getOperand(1))->getSExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="">      int64_t CstValB =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="uncoveredLine">          cast<ConstantInt>(OtherInstrB->getOperand(1))->getSExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="uncoveredLine">      if (OtherInstrA->getOperand(0) == OtherInstrB->getOperand(0) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="uncoveredLine">          IdxDiff.getSExtValue() == (CstValB - CstValA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">std::optional<APInt> Vectorizer::getConstantOffsetComplexAddrs(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">    Value *PtrA, Value *PtrB, Instruction *ContextInst, unsigned Depth) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetComplexAddrs PtrA=" << *PtrA</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="">                    << " PtrB=" << *PtrB << " ContextInst=" << *ContextInst</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="">                    << " Depth=" << Depth << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">  auto *GEPA = dyn_cast<GetElementPtrInst>(PtrA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="uncoveredLine">  auto *GEPB = dyn_cast<GetElementPtrInst>(PtrB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">  if (!GEPA || !GEPB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="uncoveredLine">    return getConstantOffsetSelects(PtrA, PtrB, ContextInst, Depth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">  // Look through GEPs after checking they're the same except for the last</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="">  // index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="uncoveredLine">  if (GEPA->getNumOperands() != GEPB->getNumOperands() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="uncoveredLine">      GEPA->getPointerOperand() != GEPB->getPointerOperand())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="uncoveredLine">  gep_type_iterator GTIA = gep_type_begin(GEPA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="uncoveredLine">  gep_type_iterator GTIB = gep_type_begin(GEPB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="uncoveredLine">  for (unsigned I = 0, E = GEPA->getNumIndices() - 1; I < E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="uncoveredLine">    if (GTIA.getOperand() != GTIB.getOperand())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">      return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="uncoveredLine">    ++GTIA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">    ++GTIB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">  Instruction *OpA = dyn_cast<Instruction>(GTIA.getOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="uncoveredLine">  Instruction *OpB = dyn_cast<Instruction>(GTIB.getOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="uncoveredLine">  if (!OpA || !OpB || OpA->getOpcode() != OpB->getOpcode() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">      OpA->getType() != OpB->getType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="uncoveredLine">  uint64_t Stride = DL.getTypeAllocSize(GTIA.getIndexedType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">  // Only look through a ZExt/SExt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="uncoveredLine">  if (!isa<SExtInst>(OpA) && !isa<ZExtInst>(OpA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">  bool Signed = isa<SExtInst>(OpA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">  // At this point A could be a function parameter, i.e. not an instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="uncoveredLine">  Value *ValA = OpA->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">  OpB = dyn_cast<Instruction>(OpB->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="uncoveredLine">  if (!OpB || ValA->getType() != OpB->getType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="uncoveredLine">  const SCEV *OffsetSCEVA = SE.getSCEV(ValA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="uncoveredLine">  const SCEV *OffsetSCEVB = SE.getSCEV(OpB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="uncoveredLine">  const SCEV *IdxDiffSCEV = SE.getMinusSCEV(OffsetSCEVB, OffsetSCEVA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="uncoveredLine">  if (IdxDiffSCEV == SE.getCouldNotCompute())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="uncoveredLine">  ConstantRange IdxDiffRange = SE.getSignedRange(IdxDiffSCEV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="uncoveredLine">  if (!IdxDiffRange.isSingleElement())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="uncoveredLine">  APInt IdxDiff = *IdxDiffRange.getSingleElement();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetComplexAddrs IdxDiff=" << IdxDiff</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="">                    << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">  // Now we need to prove that adding IdxDiff to ValA won't overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="uncoveredLine">  bool Safe = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">  // First attempt: if OpB is an add with NSW/NUW, and OpB is IdxDiff added to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="">  // ValA, we're okay.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">  if (OpB->getOpcode() == Instruction::Add &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="uncoveredLine">      isa<ConstantInt>(OpB->getOperand(1)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="uncoveredLine">      IdxDiff.sle(cast<ConstantInt>(OpB->getOperand(1))->getSExtValue()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="uncoveredLine">      checkNoWrapFlags(OpB, Signed))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="uncoveredLine">    Safe = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">  // Second attempt: check if we have eligible add NSW/NUW instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">  // sequences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="uncoveredLine">  OpA = dyn_cast<Instruction>(ValA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="uncoveredLine">  if (!Safe && OpA && OpA->getOpcode() == Instruction::Add &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="uncoveredLine">      OpB->getOpcode() == Instruction::Add && checkNoWrapFlags(OpA, Signed) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="uncoveredLine">      checkNoWrapFlags(OpB, Signed)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">    // In the checks below a matching operand in OpA and OpB is an operand which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">    // is the same in those two instructions.  Below we account for possible</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">    // orders of the operands of these add instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="uncoveredLine">    for (unsigned MatchingOpIdxA : {0, 1})</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="uncoveredLine">      for (unsigned MatchingOpIdxB : {0, 1})</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="uncoveredLine">        if (!Safe)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="uncoveredLine">          Safe = checkIfSafeAddSequence(IdxDiff, OpA, MatchingOpIdxA, OpB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">                                        MatchingOpIdxB, Signed);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="uncoveredLine">  unsigned BitWidth = ValA->getType()->getScalarSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">  // Third attempt:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">  // Assuming IdxDiff is positive: If all set bits of IdxDiff or any higher</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">  // order bit other than the sign bit are known to be zero in ValA, we can add</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">  // Diff to it while guaranteeing no overflow of any sort.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="">  // If IdxDiff is negative, do the same, but swap ValA and ValB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="uncoveredLine">  if (!Safe) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">    // When computing known bits, use the GEPs as context instructions, since</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">    // they likely are in the same BB as the load/store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="uncoveredLine">    KnownBits Known(BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">    computeKnownBits((IdxDiff.sge(0) ? ValA : OpB), Known, DL, 0, &AC,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">                     ContextInst, &DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="uncoveredLine">    APInt BitsAllowedToBeSet = Known.Zero.zext(IdxDiff.getBitWidth());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="uncoveredLine">    if (Signed)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">      BitsAllowedToBeSet.clearBit(BitWidth - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="uncoveredLine">    if (BitsAllowedToBeSet.ult(IdxDiff.abs()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">      return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="uncoveredLine">    Safe = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="uncoveredLine">  if (Safe)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="uncoveredLine">    return IdxDiff * Stride;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="uncoveredLine">  return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="uncoveredLine">std::optional<APInt> Vectorizer::getConstantOffsetSelects(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">    Value *PtrA, Value *PtrB, Instruction *ContextInst, unsigned Depth) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="uncoveredLine">  if (Depth++ == MaxDepth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="uncoveredLine">  if (auto *SelectA = dyn_cast<SelectInst>(PtrA)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="uncoveredLine">    if (auto *SelectB = dyn_cast<SelectInst>(PtrB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="uncoveredLine">      if (SelectA->getCondition() != SelectB->getCondition())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="uncoveredLine">        return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetSelects, PtrA=" << *PtrA</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">                        << ", PtrB=" << *PtrB << ", ContextInst="</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">                        << *ContextInst << ", Depth=" << Depth << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">      std::optional<APInt> TrueDiff = getConstantOffset(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="uncoveredLine">          SelectA->getTrueValue(), SelectB->getTrueValue(), ContextInst, Depth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="uncoveredLine">      if (!TrueDiff.has_value())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="uncoveredLine">        return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">      std::optional<APInt> FalseDiff =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">          getConstantOffset(SelectA->getFalseValue(), SelectB->getFalseValue(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="uncoveredLine">                            ContextInst, Depth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="uncoveredLine">      if (TrueDiff == FalseDiff)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">        return TrueDiff;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="uncoveredLine">  return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">EquivalenceClassMap</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="uncoveredLine">Vectorizer::collectEquivalenceClasses(BasicBlock::iterator Begin,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">                                      BasicBlock::iterator End) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="uncoveredLine">  EquivalenceClassMap Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="uncoveredLine">  auto getUnderlyingObject = [](const Value *Ptr) -> const Value * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">    const Value *ObjPtr = llvm::getUnderlyingObject(Ptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="uncoveredLine">    if (const auto *Sel = dyn_cast<SelectInst>(ObjPtr)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">      // The select's themselves are distinct instructions even if they share</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="">      // the same condition and evaluate to consecutive pointers for true and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">      // false values of the condition. Therefore using the select's themselves</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">      // for grouping instructions would put consecutive accesses into different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">      // lists and they won't be even checked for being consecutive, and won't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">      // be vectorized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="uncoveredLine">      return Sel->getCondition();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="uncoveredLine">    return ObjPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">  for (Instruction &I : make_range(Begin, End)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="uncoveredLine">    auto *LI = dyn_cast<LoadInst>(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="uncoveredLine">    auto *SI = dyn_cast<StoreInst>(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="uncoveredLine">    if (!LI && !SI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="uncoveredLine">    if ((LI && !LI->isSimple()) || (SI && !SI->isSimple()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="uncoveredLine">    if ((LI && !TTI.isLegalToVectorizeLoad(LI)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="uncoveredLine">        (SI && !TTI.isLegalToVectorizeStore(SI)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="uncoveredLine">    Type *Ty = getLoadStoreType(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">    if (!VectorType::isValidElementType(Ty->getScalarType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">    // Skip weird non-byte sizes. They probably aren't worth the effort of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">    // handling correctly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">    unsigned TySize = DL.getTypeSizeInBits(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="uncoveredLine">    if ((TySize % 8) != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="">    // Skip vectors of pointers. The vectorizeLoadChain/vectorizeStoreChain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="">    // functions are currently using an integer type for the vectorized</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="">    // load/store, and does not support casting between the integer type and a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">    // vector of pointers (e.g. i64 to <2 x i16*>)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="uncoveredLine">    if (Ty->isVectorTy() && Ty->isPtrOrPtrVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="uncoveredLine">    Value *Ptr = getLoadStorePointerOperand(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">    unsigned AS = Ptr->getType()->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="uncoveredLine">    unsigned VecRegSize = TTI.getLoadStoreVecRegBitWidth(AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="uncoveredLine">    unsigned VF = VecRegSize / TySize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="uncoveredLine">    VectorType *VecTy = dyn_cast<VectorType>(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">    // Only handle power-of-two sized elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="uncoveredLine">    if ((!VecTy && !isPowerOf2_32(DL.getTypeSizeInBits(Ty))) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="uncoveredLine">        (VecTy && !isPowerOf2_32(DL.getTypeSizeInBits(VecTy->getScalarType()))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="">    // No point in looking at these if they're too big to vectorize.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">    if (TySize > VecRegSize / 2 ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">        (VecTy && TTI.getLoadVectorFactor(VF, TySize, TySize / 8, VecTy) == 0))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">    Ret[{getUnderlyingObject(Ptr), AS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="uncoveredLine">         DL.getTypeSizeInBits(getLoadStoreType(&I)->getScalarType()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="uncoveredLine">         /*IsLoad=*/LI != nullptr}]</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="uncoveredLine">        .push_back(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">std::vector<Chain> Vectorizer::gatherChains(ArrayRef<Instruction *> Instrs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">  if (Instrs.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="uncoveredLine">    return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="uncoveredLine">  unsigned AS = getLoadStoreAddressSpace(Instrs[0]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">  unsigned ASPtrBits = DL.getIndexSizeInBits(AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">  // Check that Instrs is in BB order and all have the same addr space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="uncoveredLine">  for (size_t I = 1; I < Instrs.size(); ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="uncoveredLine">    assert(Instrs[I - 1]->comesBefore(Instrs[I]));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="uncoveredLine">    assert(getLoadStoreAddressSpace(Instrs[I]) == AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">  // Machinery to build an MRU-hashtable of Chains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">  // (Ideally this could be done with MapVector, but as currently implemented,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">  // moving an element to the front of a MapVector is O(n).)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="">  struct InstrListElem : ilist_node<InstrListElem>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="">                         std::pair<Instruction *, Chain> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">    explicit InstrListElem(Instruction *I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="uncoveredLine">        : std::pair<Instruction *, Chain>(I, {}) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">  struct InstrListElemDenseMapInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="">    using PtrInfo = DenseMapInfo<InstrListElem *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="">    using IInfo = DenseMapInfo<Instruction *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="uncoveredLine">    static InstrListElem *getEmptyKey() { return PtrInfo::getEmptyKey(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="uncoveredLine">    static InstrListElem *getTombstoneKey() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="uncoveredLine">      return PtrInfo::getTombstoneKey();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">    static unsigned getHashValue(const InstrListElem *E) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="uncoveredLine">      return IInfo::getHashValue(E->first);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="uncoveredLine">    static bool isEqual(const InstrListElem *A, const InstrListElem *B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="uncoveredLine">      if (A == getEmptyKey() || B == getEmptyKey())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="uncoveredLine">        return A == getEmptyKey() && B == getEmptyKey();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="uncoveredLine">      if (A == getTombstoneKey() || B == getTombstoneKey())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="uncoveredLine">        return A == getTombstoneKey() && B == getTombstoneKey();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="uncoveredLine">      return IInfo::isEqual(A->first, B->first);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="uncoveredLine">  SpecificBumpPtrAllocator<InstrListElem> Allocator;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="uncoveredLine">  simple_ilist<InstrListElem> MRU;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="uncoveredLine">  DenseSet<InstrListElem *, InstrListElemDenseMapInfo> Chains;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">  // Compare each instruction in `instrs` to leader of the N most recently-used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">  // chains.  This limits the O(n^2) behavior of this pass while also allowing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">  // us to build arbitrarily long chains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">  for (Instruction *I : Instrs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="uncoveredLine">    constexpr int MaxChainsToTry = 64;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="uncoveredLine">    bool MatchFound = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="uncoveredLine">    auto ChainIter = MRU.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="uncoveredLine">    for (size_t J = 0; J < MaxChainsToTry && ChainIter != MRU.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="uncoveredLine">         ++J, ++ChainIter) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="">      std::optional<APInt> Offset = getConstantOffset(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">          getLoadStorePointerOperand(ChainIter->first),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">          getLoadStorePointerOperand(I),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">          /*ContextInst=*/</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="uncoveredLine">          (ChainIter->first->comesBefore(I) ? I : ChainIter->first));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="uncoveredLine">      if (Offset.has_value()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">        // `Offset` might not have the expected number of bits, if e.g. AS has a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">        // different number of bits than opaque pointers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="uncoveredLine">        ChainIter->second.push_back(ChainElem{I, Offset.value()});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="">        // Move ChainIter to the front of the MRU list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="uncoveredLine">        MRU.remove(*ChainIter);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="uncoveredLine">        MRU.push_front(*ChainIter);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="uncoveredLine">        MatchFound = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="uncoveredLine">    if (!MatchFound) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="uncoveredLine">      APInt ZeroOffset(ASPtrBits, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="uncoveredLine">      InstrListElem *E = new (Allocator.Allocate()) InstrListElem(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="uncoveredLine">      E->second.push_back(ChainElem{I, ZeroOffset});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">      MRU.push_front(*E);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="uncoveredLine">      Chains.insert(E);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="uncoveredLine">  std::vector<Chain> Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="uncoveredLine">  Ret.reserve(Chains.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">  // Iterate over MRU rather than Chains so the order is deterministic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="uncoveredLine">  for (auto &E : MRU)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="uncoveredLine">    if (E.second.size() > 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="uncoveredLine">      Ret.push_back(std::move(E.second));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">  return Ret;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="uncoveredLine">std::optional<APInt> Vectorizer::getConstantOffset(Value *PtrA, Value *PtrB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">                                                   Instruction *ContextInst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="">                                                   unsigned Depth) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffset, PtrA=" << *PtrA</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">                    << ", PtrB=" << *PtrB << ", ContextInst= " << *ContextInst</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="">                    << ", Depth=" << Depth << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="">  // We'll ultimately return a value of this bit width, even if computations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="">  // happen in a different width.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="uncoveredLine">  unsigned OrigBitWidth = DL.getIndexTypeSizeInBits(PtrA->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="uncoveredLine">  APInt OffsetA(OrigBitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="uncoveredLine">  APInt OffsetB(OrigBitWidth, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="uncoveredLine">  PtrA = PtrA->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="uncoveredLine">  PtrB = PtrB->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="uncoveredLine">  unsigned NewPtrBitWidth = DL.getTypeStoreSizeInBits(PtrA->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="uncoveredLine">  if (NewPtrBitWidth != DL.getTypeStoreSizeInBits(PtrB->getType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="">  // If we have to shrink the pointer, stripAndAccumulateInBoundsConstantOffsets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="">  // should properly handle a possible overflow and the value should fit into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">  // the smallest data type used in the cast/gep chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">  assert(OffsetA.getSignificantBits() <= NewPtrBitWidth &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">         OffsetB.getSignificantBits() <= NewPtrBitWidth);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="uncoveredLine">  OffsetA = OffsetA.sextOrTrunc(NewPtrBitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="uncoveredLine">  OffsetB = OffsetB.sextOrTrunc(NewPtrBitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="uncoveredLine">  if (PtrA == PtrB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="uncoveredLine">    return (OffsetB - OffsetA).sextOrTrunc(OrigBitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="">  // Try to compute B - A.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">  const SCEV *DistScev = SE.getMinusSCEV(SE.getSCEV(PtrB), SE.getSCEV(PtrA));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="uncoveredLine">  if (DistScev != SE.getCouldNotCompute()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "LSV: SCEV PtrB - PtrA =" << *DistScev << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="uncoveredLine">    ConstantRange DistRange = SE.getSignedRange(DistScev);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="uncoveredLine">    if (DistRange.isSingleElement()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">      // Handle index width (the width of Dist) != pointer width (the width of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">      // the Offset*s at this point).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="uncoveredLine">      APInt Dist = DistRange.getSingleElement()->sextOrTrunc(NewPtrBitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="uncoveredLine">      return (OffsetB - OffsetA + Dist).sextOrTrunc(OrigBitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">  std::optional<APInt> Diff =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="uncoveredLine">      getConstantOffsetComplexAddrs(PtrA, PtrB, ContextInst, Depth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">  if (Diff.has_value())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="uncoveredLine">    return (OffsetB - OffsetA + Diff->sext(OffsetB.getBitWidth()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="uncoveredLine">        .sextOrTrunc(OrigBitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="uncoveredLine">  return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_1lsERN4llvm11raw_ostreamERKSt5tupleIJPKNS0_5ValueEjjcEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118sortChainInBBOrderERN4llvm11SmallVectorINS_9ChainElemELj1EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_118sortChainInBBOrderERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlRT_RT0_E_clIS2_S2_EEDaS6_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_122sortChainInOffsetOrderERN4llvm11SmallVectorINS_9ChainElemELj1EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_122sortChainInOffsetOrderERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlRKT_RKT0_E_clIS2_S2_EEDaS7_SA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_19dumpChainEN4llvm8ArrayRefINS_9ChainElemEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_117propagateMetadataEPN4llvm11InstructionERKNS0_11SmallVectorINS_9ChainElemELj1EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_115isInvariantLoadEPKN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_17reorderEPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110VectorizerC2ERN4llvm8FunctionERNS1_9AAResultsERNS1_15AssumptionCacheERNS1_13DominatorTreeERNS1_15ScalarEvolutionERNS1_19TargetTransformInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_129LoadStoreVectorizerLegacyPassC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_129LoadStoreVectorizerLegacyPass11getPassNameEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_129LoadStoreVectorizerLegacyPass16getAnalysisUsageERN4llvm13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL47initializeLoadStoreVectorizerLegacyPassPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm43initializeLoadStoreVectorizerLegacyPassPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm29createLoadStoreVectorizerPassEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_129LoadStoreVectorizerLegacyPass13runOnFunctionERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23LoadStoreVectorizerPass3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer3runEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer13runOnPseudoBBEN4llvm14ilist_iteratorINS1_12ilist_detail12node_optionsINS1_11InstructionELb1ELb0EvEELb0ELb0EEES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer21runOnEquivalenceClassERKSt5tupleIJPKN4llvm5ValueEjjcEENS2_8ArrayRefIPNS2_11InstructionEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer10runOnChainERN4llvm11SmallVectorINS_9ChainElemELj1EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer26splitChainByMayAliasInstrsERN4llvm11SmallVectorINS_9ChainElemELj1EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer26splitChainByMayAliasInstrsERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlT_E_clISt17integral_constantIbLb1EEEEDaS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer26splitChainByMayAliasInstrsERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlT_E_clISt17integral_constantIbLb0EEEEDaS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZN12_GLOBAL__N_110Vectorizer26splitChainByMayAliasInstrsERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlT_E_clISt17integral_constantIbLb1EEEEDaS6_ENKUlS6_E_clISA_EEDaS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZN12_GLOBAL__N_110Vectorizer26splitChainByMayAliasInstrsERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlT_E_clISt17integral_constantIbLb0EEEEDaS6_ENKUlS6_E_clISA_EEDaS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer22splitChainByContiguityERN4llvm11SmallVectorINS_9ChainElemELj1EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer22splitChainByContiguityERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlRKT_E_clIS4_EEDaS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer14getChainElemTyERKN4llvm11SmallVectorINS_9ChainElemELj1EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer14getChainElemTyERKN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlRKS3_E_clES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer21splitChainByAlignmentERN4llvm11SmallVectorINS_9ChainElemELj1EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer21splitChainByAlignmentERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUljjjPNS1_10VectorTypeEE_clEjjjS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer21splitChainByAlignmentERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlNS1_5AlignEE0_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer14vectorizeChainERN4llvm11SmallVectorINS_9ChainElemELj1EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer14vectorizeChainERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUljRKS3_E_clEjS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer14vectorizeChainERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlRKT_RKT0_E0_clIS3_S3_EEDaS8_SB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer14vectorizeChainERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlRT_RT0_E1_clIS3_S3_EEDaS7_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer14vectorizeChainERN4llvm11SmallVectorINS_9ChainElemELj1EEEENKUlPNS1_5ValueEE2_clES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer12isSafeToMoveILb0EEEbPN4llvm11InstructionES4_RKNS2_8DenseMapIS4_NS2_5APIntENS2_12DenseMapInfoIS4_vEENS2_6detail12DenseMapPairIS4_S6_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer12isSafeToMoveILb1EEEbPN4llvm11InstructionES4_RKNS2_8DenseMapIS4_NS2_5APIntENS2_12DenseMapInfoIS4_vEENS2_6detail12DenseMapPairIS4_S6_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer12isSafeToMoveILb0EEEbPN4llvm11InstructionES4_RKNS2_8DenseMapIS4_NS2_5APIntENS2_12DenseMapInfoIS4_vEENS2_6detail12DenseMapPairIS4_S6_EEEEENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer12isSafeToMoveILb1EEEbPN4llvm11InstructionES4_RKNS2_8DenseMapIS4_NS2_5APIntENS2_12DenseMapInfoIS4_vEENS2_6detail12DenseMapPairIS4_S6_EEEEENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer12isSafeToMoveILb0EEEbPN4llvm11InstructionES4_RKNS2_8DenseMapIS4_NS2_5APIntENS2_12DenseMapInfoIS4_vEENS2_6detail12DenseMapPairIS4_S6_EEEEENKUlvE0_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer12isSafeToMoveILb1EEEbPN4llvm11InstructionES4_RKNS2_8DenseMapIS4_NS2_5APIntENS2_12DenseMapInfoIS4_vEENS2_6detail12DenseMapPairIS4_S6_EEEEENKUlvE0_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL16checkNoWrapFlagsPN4llvm11InstructionEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL22checkIfSafeAddSequenceRKN4llvm5APIntEPNS_11InstructionEjS4_jb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer29getConstantOffsetComplexAddrsEPN4llvm5ValueES3_PNS1_11InstructionEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer24getConstantOffsetSelectsEPN4llvm5ValueES3_PNS1_11InstructionEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer25collectEquivalenceClassesEN4llvm14ilist_iteratorINS1_12ilist_detail12node_optionsINS1_11InstructionELb1ELb0EvEELb0ELb0EEES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer25collectEquivalenceClassesEN4llvm14ilist_iteratorINS1_12ilist_detail12node_optionsINS1_11InstructionELb1ELb0EvEELb0ELb0EEES7_ENKUlPKNS1_5ValueEE_clESA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer12gatherChainsEN4llvm8ArrayRefIPNS1_11InstructionEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer12gatherChainsEN4llvm8ArrayRefIPNS1_11InstructionEEEEN13InstrListElemC2ES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer12gatherChainsEN4llvm8ArrayRefIPNS1_11InstructionEEEEN25InstrListElemDenseMapInfo11getEmptyKeyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer12gatherChainsEN4llvm8ArrayRefIPNS1_11InstructionEEEEN25InstrListElemDenseMapInfo15getTombstoneKeyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer12gatherChainsEN4llvm8ArrayRefIPNS1_11InstructionEEEEN25InstrListElemDenseMapInfo12getHashValueEPKZNS0_12gatherChainsES5_E13InstrListElem</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_110Vectorizer12gatherChainsEN4llvm8ArrayRefIPNS1_11InstructionEEEEN25InstrListElemDenseMapInfo7isEqualEPKZNS0_12gatherChainsES5_E13InstrListElemS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_110Vectorizer17getConstantOffsetEPN4llvm5ValueES3_PNS1_11InstructionEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This pass merges loads/stores to/from sequential memory addresses into vector</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This pass merges loads/stores to/from sequential memory addresses into vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// loads/stores.  Although there's nothing GPU-specific in here, this pass is</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// loads/stores.  Although there's nothing GPU-specific in here, this pass is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">// motivated by the microarchitectural quirks of nVidia and AMD GPUs.</td>
    <td class="lineNumber">11</td>
    <td class="codeline">// motivated by the microarchitectural quirks of nVidia and AMD GPUs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">//</td>
    <td class="lineNumber">12</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">// (For simplicity below we talk about loads only, but everything also applies</td>
    <td class="lineNumber">13</td>
    <td class="codeline">// (For simplicity below we talk about loads only, but everything also applies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">// to stores.)</td>
    <td class="lineNumber">14</td>
    <td class="codeline">// to stores.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">//</td>
    <td class="lineNumber">15</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">// This pass is intended to be run late in the pipeline, after other</td>
    <td class="lineNumber">16</td>
    <td class="codeline">// This pass is intended to be run late in the pipeline, after other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">// vectorization opportunities have been exploited.  So the assumption here is</td>
    <td class="lineNumber">17</td>
    <td class="codeline">// vectorization opportunities have been exploited.  So the assumption here is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">// that immediately following our new vector load we'll need to extract out the</td>
    <td class="lineNumber">18</td>
    <td class="codeline">// that immediately following our new vector load we'll need to extract out the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">// individual elements of the load, so we can operate on them individually.</td>
    <td class="lineNumber">19</td>
    <td class="codeline">// individual elements of the load, so we can operate on them individually.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">//</td>
    <td class="lineNumber">20</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">// On CPUs this transformation is usually not beneficial, because extracting the</td>
    <td class="lineNumber">21</td>
    <td class="codeline">// On CPUs this transformation is usually not beneficial, because extracting the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">// elements of a vector register is expensive on most architectures.  It's</td>
    <td class="lineNumber">22</td>
    <td class="codeline">// elements of a vector register is expensive on most architectures.  It's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">// usually better just to load each element individually into its own scalar</td>
    <td class="lineNumber">23</td>
    <td class="codeline">// usually better just to load each element individually into its own scalar</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">// register.</td>
    <td class="lineNumber">24</td>
    <td class="codeline">// register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">//</td>
    <td class="lineNumber">25</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">// However, nVidia and AMD GPUs don't have proper vector registers.  Instead, a</td>
    <td class="lineNumber">26</td>
    <td class="codeline">// However, nVidia and AMD GPUs don't have proper vector registers.  Instead, a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">// "vector load" loads directly into a series of scalar registers.  In effect,</td>
    <td class="lineNumber">27</td>
    <td class="codeline">// "vector load" loads directly into a series of scalar registers.  In effect,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">// extracting the elements of the vector is free.  It's therefore always</td>
    <td class="lineNumber">28</td>
    <td class="codeline">// extracting the elements of the vector is free.  It's therefore always</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">// beneficial to vectorize a sequence of loads on these architectures.</td>
    <td class="lineNumber">29</td>
    <td class="codeline">// beneficial to vectorize a sequence of loads on these architectures.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">//</td>
    <td class="lineNumber">30</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">// Vectorizing (perhaps a better name might be "coalescing") loads can have</td>
    <td class="lineNumber">31</td>
    <td class="codeline">// Vectorizing (perhaps a better name might be "coalescing") loads can have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">// large performance impacts on GPU kernels, and opportunities for vectorizing</td>
    <td class="lineNumber">32</td>
    <td class="codeline">// large performance impacts on GPU kernels, and opportunities for vectorizing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">// are common in GPU code.  This pass tries very hard to find such</td>
    <td class="lineNumber">33</td>
    <td class="codeline">// are common in GPU code.  This pass tries very hard to find such</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">// opportunities; its runtime is quadratic in the number of loads in a BB.</td>
    <td class="lineNumber">34</td>
    <td class="codeline">// opportunities; its runtime is quadratic in the number of loads in a BB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">//</td>
    <td class="lineNumber">35</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">// Some CPU architectures, such as ARM, have instructions that load into</td>
    <td class="lineNumber">36</td>
    <td class="codeline">// Some CPU architectures, such as ARM, have instructions that load into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">// multiple scalar registers, similar to a GPU vectorized load.  In theory ARM</td>
    <td class="lineNumber">37</td>
    <td class="codeline">// multiple scalar registers, similar to a GPU vectorized load.  In theory ARM</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">// could use this pass (with some modifications), but currently it implements</td>
    <td class="lineNumber">38</td>
    <td class="codeline">// could use this pass (with some modifications), but currently it implements</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">// its own pass to do something similar to what we do here.</td>
    <td class="lineNumber">39</td>
    <td class="codeline">// its own pass to do something similar to what we do here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">//</td>
    <td class="lineNumber">40</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">// Overview of the algorithm and terminology in this pass:</td>
    <td class="lineNumber">41</td>
    <td class="codeline">// Overview of the algorithm and terminology in this pass:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">//</td>
    <td class="lineNumber">42</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">//  - Break up each basic block into pseudo-BBs, composed of instructions which</td>
    <td class="lineNumber">43</td>
    <td class="codeline">//  - Break up each basic block into pseudo-BBs, composed of instructions which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">//    are guaranteed to transfer control to their successors.</td>
    <td class="lineNumber">44</td>
    <td class="codeline">//    are guaranteed to transfer control to their successors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">//  - Within a single pseudo-BB, find all loads, and group them into</td>
    <td class="lineNumber">45</td>
    <td class="codeline">//  - Within a single pseudo-BB, find all loads, and group them into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">//    "equivalence classes" according to getUnderlyingObject() and loaded</td>
    <td class="lineNumber">46</td>
    <td class="codeline">//    "equivalence classes" according to getUnderlyingObject() and loaded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">//    element size.  Do the same for stores.</td>
    <td class="lineNumber">47</td>
    <td class="codeline">//    element size.  Do the same for stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">//  - For each equivalence class, greedily build "chains".  Each chain has a</td>
    <td class="lineNumber">48</td>
    <td class="codeline">//  - For each equivalence class, greedily build "chains".  Each chain has a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">//    leader instruction, and every other member of the chain has a known</td>
    <td class="lineNumber">49</td>
    <td class="codeline">//    leader instruction, and every other member of the chain has a known</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">//    constant offset from the first instr in the chain.</td>
    <td class="lineNumber">50</td>
    <td class="codeline">//    constant offset from the first instr in the chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">//  - Break up chains so that they contain only contiguous accesses of legal</td>
    <td class="lineNumber">51</td>
    <td class="codeline">//  - Break up chains so that they contain only contiguous accesses of legal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">//    size with no intervening may-alias instrs.</td>
    <td class="lineNumber">52</td>
    <td class="codeline">//    size with no intervening may-alias instrs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">//  - Convert each chain to vector instructions.</td>
    <td class="lineNumber">53</td>
    <td class="codeline">//  - Convert each chain to vector instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">//</td>
    <td class="lineNumber">54</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">// The O(n^2) behavior of this pass comes from initially building the chains.</td>
    <td class="lineNumber">55</td>
    <td class="codeline">// The O(n^2) behavior of this pass comes from initially building the chains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">// In the worst case we have to compare each new instruction to all of those</td>
    <td class="lineNumber">56</td>
    <td class="codeline">// In the worst case we have to compare each new instruction to all of those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">// that came before. To limit this, we only calculate the offset to the leaders</td>
    <td class="lineNumber">57</td>
    <td class="codeline">// that came before. To limit this, we only calculate the offset to the leaders</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">// of the N most recently-used chains.</td>
    <td class="lineNumber">58</td>
    <td class="codeline">// of the N most recently-used chains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline"></td>
    <td class="lineNumber">59</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">#include "llvm/Transforms/Vectorize/LoadStoreVectorizer.h"</td>
    <td class="lineNumber">60</td>
    <td class="codeline">#include "llvm/Transforms/Vectorize/LoadStoreVectorizer.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">61</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">62</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">63</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">#include "llvm/ADT/MapVector.h"</td>
    <td class="lineNumber">64</td>
    <td class="codeline">#include "llvm/ADT/MapVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td class="lineNumber">65</td>
    <td class="codeline">#include "llvm/ADT/PostOrderIterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">66</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">#include "llvm/ADT/Sequence.h"</td>
    <td class="lineNumber">67</td>
    <td class="codeline">#include "llvm/ADT/Sequence.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">68</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">69</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">70</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">71</td>
    <td class="codeline">#include "llvm/ADT/iterator_range.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">72</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">73</td>
    <td class="codeline">#include "llvm/Analysis/AssumptionCache.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">74</td>
    <td class="codeline">#include "llvm/Analysis/MemoryLocation.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td class="lineNumber">75</td>
    <td class="codeline">#include "llvm/Analysis/ScalarEvolution.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">76</td>
    <td class="codeline">#include "llvm/Analysis/TargetTransformInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">77</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">#include "llvm/Analysis/VectorUtils.h"</td>
    <td class="lineNumber">78</td>
    <td class="codeline">#include "llvm/Analysis/VectorUtils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">79</td>
    <td class="codeline">#include "llvm/IR/Attributes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">80</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">#include "llvm/IR/ConstantRange.h"</td>
    <td class="lineNumber">81</td>
    <td class="codeline">#include "llvm/IR/ConstantRange.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">82</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">83</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">84</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">85</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">86</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td class="lineNumber">87</td>
    <td class="codeline">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">88</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">89</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">90</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">91</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">92</td>
    <td class="codeline">#include "llvm/IR/LLVMContext.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">93</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">94</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">95</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">96</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">97</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">#include "llvm/Support/Alignment.h"</td>
    <td class="lineNumber">98</td>
    <td class="codeline">#include "llvm/Support/Alignment.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">99</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">100</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">101</td>
    <td class="codeline">#include "llvm/Support/KnownBits.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">102</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">#include "llvm/Support/ModRef.h"</td>
    <td class="lineNumber">103</td>
    <td class="codeline">#include "llvm/Support/ModRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">104</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">105</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">#include "llvm/Transforms/Vectorize.h"</td>
    <td class="lineNumber">106</td>
    <td class="codeline">#include "llvm/Transforms/Vectorize.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">107</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">108</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">109</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">#include <cstdlib></td>
    <td class="lineNumber">110</td>
    <td class="codeline">#include <cstdlib></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">#include <iterator></td>
    <td class="lineNumber">111</td>
    <td class="codeline">#include <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">#include <limits></td>
    <td class="lineNumber">112</td>
    <td class="codeline">#include <limits></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">#include <numeric></td>
    <td class="lineNumber">113</td>
    <td class="codeline">#include <numeric></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">#include <optional></td>
    <td class="lineNumber">114</td>
    <td class="codeline">#include <optional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">#include <tuple></td>
    <td class="lineNumber">115</td>
    <td class="codeline">#include <tuple></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">#include <type_traits></td>
    <td class="lineNumber">116</td>
    <td class="codeline">#include <type_traits></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">117</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">#include <vector></td>
    <td class="lineNumber">118</td>
    <td class="codeline">#include <vector></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">120</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">#define DEBUG_TYPE "load-store-vectorizer"</td>
    <td class="lineNumber">122</td>
    <td class="codeline">#define DEBUG_TYPE "load-store-vectorizer"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline"></td>
    <td class="lineNumber">123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">STATISTIC(NumVectorInstructions, "Number of vector accesses generated");</td>
    <td class="lineNumber">124</td>
    <td class="codeline">STATISTIC(NumVectorInstructions, "Number of vector accesses generated");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">STATISTIC(NumScalarsVectorized, "Number of scalar accesses vectorized");</td>
    <td class="lineNumber">125</td>
    <td class="codeline">STATISTIC(NumScalarsVectorized, "Number of scalar accesses vectorized");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">127</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline"></td>
    <td class="lineNumber">128</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">// Equivalence class key, the initial tuple by which we group loads/stores.</td>
    <td class="lineNumber">129</td>
    <td class="codeline">// Equivalence class key, the initial tuple by which we group loads/stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">// Loads/stores with different EqClassKeys are never merged.</td>
    <td class="lineNumber">130</td>
    <td class="codeline">// Loads/stores with different EqClassKeys are never merged.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">//</td>
    <td class="lineNumber">131</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">// (We could in theory remove element-size from the this tuple.  We'd just need</td>
    <td class="lineNumber">132</td>
    <td class="codeline">// (We could in theory remove element-size from the this tuple.  We'd just need</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">// to fix up the vector packing/unpacking code.)</td>
    <td class="lineNumber">133</td>
    <td class="codeline">// to fix up the vector packing/unpacking code.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">using EqClassKey =</td>
    <td class="lineNumber">134</td>
    <td class="codeline">using EqClassKey =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">    std::tuple<const Value * /* result of getUnderlyingObject() */,</td>
    <td class="lineNumber">135</td>
    <td class="codeline">    std::tuple<const Value * /* result of getUnderlyingObject() */,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">               unsigned /* AddrSpace */,</td>
    <td class="lineNumber">136</td>
    <td class="codeline">               unsigned /* AddrSpace */,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">               unsigned /* Load/Store element size bits */,</td>
    <td class="lineNumber">137</td>
    <td class="codeline">               unsigned /* Load/Store element size bits */,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">               char /* IsLoad; char b/c bool can't be a DenseMap key */</td>
    <td class="lineNumber">138</td>
    <td class="codeline">               char /* IsLoad; char b/c bool can't be a DenseMap key */</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">               >;</td>
    <td class="lineNumber">139</td>
    <td class="codeline">               >;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">[[maybe_unused]] llvm::raw_ostream &operator<<(llvm::raw_ostream &OS,</td>
    <td class="lineNumber">140</td>
    <td class="codeline">[[maybe_unused]] llvm::raw_ostream &operator<<(llvm::raw_ostream &OS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">                                               const EqClassKey &K) {</td>
    <td class="lineNumber">141</td>
    <td class="codeline">                                               const EqClassKey &K) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">  const auto &[UnderlyingObject, AddrSpace, ElementSize, IsLoad] = K;</td>
    <td class="lineNumber">142</td>
    <td class="codeline">  const auto &[UnderlyingObject, AddrSpace, ElementSize, IsLoad] = K;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">  return OS << (IsLoad ? "load" : "store") << " of " << *UnderlyingObject</td>
    <td class="lineNumber">143</td>
    <td class="codeline">  return OS << (IsLoad ? "load" : "store") << " of " << *UnderlyingObject</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">            << " of element size " << ElementSize << " bits in addrspace "</td>
    <td class="lineNumber">144</td>
    <td class="codeline">            << " of element size " << ElementSize << " bits in addrspace "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">            << AddrSpace;</td>
    <td class="lineNumber">145</td>
    <td class="codeline">            << AddrSpace;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">}</td>
    <td class="lineNumber">146</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline"></td>
    <td class="lineNumber">147</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">// A Chain is a set of instructions such that:</td>
    <td class="lineNumber">148</td>
    <td class="codeline">// A Chain is a set of instructions such that:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">//  - All instructions have the same equivalence class, so in particular all are</td>
    <td class="lineNumber">149</td>
    <td class="codeline">//  - All instructions have the same equivalence class, so in particular all are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">//    loads, or all are stores.</td>
    <td class="lineNumber">150</td>
    <td class="codeline">//    loads, or all are stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">//  - We know the address accessed by the i'th chain elem relative to the</td>
    <td class="lineNumber">151</td>
    <td class="codeline">//  - We know the address accessed by the i'th chain elem relative to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">//    chain's leader instruction, which is the first instr of the chain in BB</td>
    <td class="lineNumber">152</td>
    <td class="codeline">//    chain's leader instruction, which is the first instr of the chain in BB</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">//    order.</td>
    <td class="lineNumber">153</td>
    <td class="codeline">//    order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">//</td>
    <td class="lineNumber">154</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">// Chains have two canonical orderings:</td>
    <td class="lineNumber">155</td>
    <td class="codeline">// Chains have two canonical orderings:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">//  - BB order, sorted by Instr->comesBefore.</td>
    <td class="lineNumber">156</td>
    <td class="codeline">//  - BB order, sorted by Instr->comesBefore.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">//  - Offset order, sorted by OffsetFromLeader.</td>
    <td class="lineNumber">157</td>
    <td class="codeline">//  - Offset order, sorted by OffsetFromLeader.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">// This pass switches back and forth between these orders.</td>
    <td class="lineNumber">158</td>
    <td class="codeline">// This pass switches back and forth between these orders.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">struct ChainElem {</td>
    <td class="lineNumber">159</td>
    <td class="codeline">struct ChainElem {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">  Instruction *Inst;</td>
    <td class="lineNumber">160</td>
    <td class="codeline">  Instruction *Inst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  APInt OffsetFromLeader;</td>
    <td class="lineNumber">161</td>
    <td class="codeline">  APInt OffsetFromLeader;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">};</td>
    <td class="lineNumber">162</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">using Chain = SmallVector<ChainElem, 1>;</td>
    <td class="lineNumber">163</td>
    <td class="codeline">using Chain = SmallVector<ChainElem, 1>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline"></td>
    <td class="lineNumber">164</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">void sortChainInBBOrder(Chain &C) {</td>
    <td class="lineNumber">165</td>
    <td class="codeline">void sortChainInBBOrder(Chain &C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  sort(C, [](auto &A, auto &B) { return A.Inst->comesBefore(B.Inst); });</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  sort(C, [](auto &A, auto &B) { return A.Inst->comesBefore(B.Inst); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">}</td>
    <td class="lineNumber">167</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline"></td>
    <td class="lineNumber">168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">void sortChainInOffsetOrder(Chain &C) {</td>
    <td class="lineNumber">169</td>
    <td class="codeline">void sortChainInOffsetOrder(Chain &C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  sort(C, [](const auto &A, const auto &B) {</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  sort(C, [](const auto &A, const auto &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">    if (A.OffsetFromLeader != B.OffsetFromLeader)</td>
    <td class="lineNumber">171</td>
    <td class="codeline">    if (A.OffsetFromLeader != B.OffsetFromLeader)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">      return A.OffsetFromLeader.slt(B.OffsetFromLeader);</td>
    <td class="lineNumber">172</td>
    <td class="codeline">      return A.OffsetFromLeader.slt(B.OffsetFromLeader);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">    return A.Inst->comesBefore(B.Inst); // stable tiebreaker</td>
    <td class="lineNumber">173</td>
    <td class="codeline">    return A.Inst->comesBefore(B.Inst); // stable tiebreaker</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">}</td>
    <td class="lineNumber">175</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline"></td>
    <td class="lineNumber">176</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">[[maybe_unused]] void dumpChain(ArrayRef<ChainElem> C) {</td>
    <td class="lineNumber">177</td>
    <td class="codeline">[[maybe_unused]] void dumpChain(ArrayRef<ChainElem> C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  for (const auto &E : C) {</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  for (const auto &E : C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">    dbgs() << "  " << *E.Inst << " (offset " << E.OffsetFromLeader << ")\n";</td>
    <td class="lineNumber">179</td>
    <td class="codeline">    dbgs() << "  " << *E.Inst << " (offset " << E.OffsetFromLeader << ")\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">180</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">}</td>
    <td class="lineNumber">181</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">using EquivalenceClassMap =</td>
    <td class="lineNumber">183</td>
    <td class="codeline">using EquivalenceClassMap =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">    MapVector<EqClassKey, SmallVector<Instruction *, 8>>;</td>
    <td class="lineNumber">184</td>
    <td class="codeline">    MapVector<EqClassKey, SmallVector<Instruction *, 8>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">// FIXME: Assuming stack alignment of 4 is always good enough</td>
    <td class="lineNumber">186</td>
    <td class="codeline">// FIXME: Assuming stack alignment of 4 is always good enough</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">constexpr unsigned StackAdjustedAlignment = 4;</td>
    <td class="lineNumber">187</td>
    <td class="codeline">constexpr unsigned StackAdjustedAlignment = 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline"></td>
    <td class="lineNumber">188</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">Instruction *propagateMetadata(Instruction *I, const Chain &C) {</td>
    <td class="lineNumber">189</td>
    <td class="codeline">Instruction *propagateMetadata(Instruction *I, const Chain &C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  SmallVector<Value *, 8> Values;</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  SmallVector<Value *, 8> Values;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  for (const ChainElem &E : C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">    Values.push_back(E.Inst);</td>
    <td class="lineNumber">192</td>
    <td class="codeline">    Values.push_back(E.Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  return propagateMetadata(I, Values);</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  return propagateMetadata(I, Values);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">}</td>
    <td class="lineNumber">194</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline"></td>
    <td class="lineNumber">195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">bool isInvariantLoad(const Instruction *I) {</td>
    <td class="lineNumber">196</td>
    <td class="codeline">bool isInvariantLoad(const Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  const LoadInst *LI = dyn_cast<LoadInst>(I);</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  const LoadInst *LI = dyn_cast<LoadInst>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  return LI != nullptr && LI->hasMetadata(LLVMContext::MD_invariant_load);</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  return LI != nullptr && LI->hasMetadata(LLVMContext::MD_invariant_load);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">}</td>
    <td class="lineNumber">199</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">/// Reorders the instructions that I depends on (the instructions defining its</td>
    <td class="lineNumber">201</td>
    <td class="codeline">/// Reorders the instructions that I depends on (the instructions defining its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">/// operands), to ensure they dominate I.</td>
    <td class="lineNumber">202</td>
    <td class="codeline">/// operands), to ensure they dominate I.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">void reorder(Instruction *I) {</td>
    <td class="lineNumber">203</td>
    <td class="codeline">void reorder(Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">  SmallPtrSet<Instruction *, 16> InstructionsToMove;</td>
    <td class="lineNumber">204</td>
    <td class="codeline">  SmallPtrSet<Instruction *, 16> InstructionsToMove;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  SmallVector<Instruction *, 16> Worklist;</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  SmallVector<Instruction *, 16> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  Worklist.push_back(I);</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  Worklist.push_back(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    Instruction *IW = Worklist.pop_back_val();</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    Instruction *IW = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">    int NumOperands = IW->getNumOperands();</td>
    <td class="lineNumber">210</td>
    <td class="codeline">    int NumOperands = IW->getNumOperands();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">    for (int i = 0; i < NumOperands; i++) {</td>
    <td class="lineNumber">211</td>
    <td class="codeline">    for (int i = 0; i < NumOperands; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">      Instruction *IM = dyn_cast<Instruction>(IW->getOperand(i));</td>
    <td class="lineNumber">212</td>
    <td class="codeline">      Instruction *IM = dyn_cast<Instruction>(IW->getOperand(i));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">      if (!IM || IM->getOpcode() == Instruction::PHI)</td>
    <td class="lineNumber">213</td>
    <td class="codeline">      if (!IM || IM->getOpcode() == Instruction::PHI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">214</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">      // If IM is in another BB, no need to move it, because this pass only</td>
    <td class="lineNumber">216</td>
    <td class="codeline">      // If IM is in another BB, no need to move it, because this pass only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">      // vectorizes instructions within one BB.</td>
    <td class="lineNumber">217</td>
    <td class="codeline">      // vectorizes instructions within one BB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">      if (IM->getParent() != I->getParent())</td>
    <td class="lineNumber">218</td>
    <td class="codeline">      if (IM->getParent() != I->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">219</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">      if (!IM->comesBefore(I)) {</td>
    <td class="lineNumber">221</td>
    <td class="codeline">      if (!IM->comesBefore(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">        InstructionsToMove.insert(IM);</td>
    <td class="lineNumber">222</td>
    <td class="codeline">        InstructionsToMove.insert(IM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">        Worklist.push_back(IM);</td>
    <td class="lineNumber">223</td>
    <td class="codeline">        Worklist.push_back(IM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">224</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">225</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">  // All instructions to move should follow I. Start from I, not from begin().</td>
    <td class="lineNumber">228</td>
    <td class="codeline">  // All instructions to move should follow I. Start from I, not from begin().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  for (auto BBI = I->getIterator(), E = I->getParent()->end(); BBI != E;) {</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  for (auto BBI = I->getIterator(), E = I->getParent()->end(); BBI != E;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">    Instruction *IM = &*(BBI++);</td>
    <td class="lineNumber">230</td>
    <td class="codeline">    Instruction *IM = &*(BBI++);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">    if (!InstructionsToMove.count(IM))</td>
    <td class="lineNumber">231</td>
    <td class="codeline">    if (!InstructionsToMove.count(IM))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">232</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">    IM->moveBefore(I);</td>
    <td class="lineNumber">233</td>
    <td class="codeline">    IM->moveBefore(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">}</td>
    <td class="lineNumber">235</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">class Vectorizer {</td>
    <td class="lineNumber">237</td>
    <td class="codeline">class Vectorizer {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  Function &F;</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  Function &F;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  AliasAnalysis &AA;</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  AliasAnalysis &AA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  AssumptionCache &AC;</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  AssumptionCache &AC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  DominatorTree &DT;</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  DominatorTree &DT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  ScalarEvolution &SE;</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  ScalarEvolution &SE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  TargetTransformInfo &TTI;</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  TargetTransformInfo &TTI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  const DataLayout &DL;</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  const DataLayout &DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  IRBuilder<> Builder;</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  IRBuilder<> Builder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  // We could erase instrs right after vectorizing them, but that can mess up</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  // We could erase instrs right after vectorizing them, but that can mess up</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">  // our BB iterators, and also can make the equivalence class keys point to</td>
    <td class="lineNumber">248</td>
    <td class="codeline">  // our BB iterators, and also can make the equivalence class keys point to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  // freed memory.  This is fixable, but it's simpler just to wait until we're</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  // freed memory.  This is fixable, but it's simpler just to wait until we're</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  // done with the BB and erase all at once.</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  // done with the BB and erase all at once.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  SmallVector<Instruction *, 128> ToErase;</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  SmallVector<Instruction *, 128> ToErase;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline"></td>
    <td class="lineNumber">252</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">253</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  Vectorizer(Function &F, AliasAnalysis &AA, AssumptionCache &AC,</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  Vectorizer(Function &F, AliasAnalysis &AA, AssumptionCache &AC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">             DominatorTree &DT, ScalarEvolution &SE, TargetTransformInfo &TTI)</td>
    <td class="lineNumber">255</td>
    <td class="codeline">             DominatorTree &DT, ScalarEvolution &SE, TargetTransformInfo &TTI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">      : F(F), AA(AA), AC(AC), DT(DT), SE(SE), TTI(TTI),</td>
    <td class="lineNumber">256</td>
    <td class="codeline">      : F(F), AA(AA), AC(AC), DT(DT), SE(SE), TTI(TTI),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">        DL(F.getParent()->getDataLayout()), Builder(SE.getContext()) {}</td>
    <td class="lineNumber">257</td>
    <td class="codeline">        DL(F.getParent()->getDataLayout()), Builder(SE.getContext()) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline"></td>
    <td class="lineNumber">258</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  bool run();</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  bool run();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline"></td>
    <td class="lineNumber">260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">261</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  static const unsigned MaxDepth = 3;</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  static const unsigned MaxDepth = 3;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline"></td>
    <td class="lineNumber">263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  /// Runs the vectorizer on a "pseudo basic block", which is a range of</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  /// Runs the vectorizer on a "pseudo basic block", which is a range of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  /// instructions [Begin, End) within one BB all of which have</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  /// instructions [Begin, End) within one BB all of which have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  /// isGuaranteedToTransferExecutionToSuccessor(I) == true.</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  /// isGuaranteedToTransferExecutionToSuccessor(I) == true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  bool runOnPseudoBB(BasicBlock::iterator Begin, BasicBlock::iterator End);</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  bool runOnPseudoBB(BasicBlock::iterator Begin, BasicBlock::iterator End);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline"></td>
    <td class="lineNumber">268</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  /// Runs the vectorizer on one equivalence class, i.e. one set of loads/stores</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  /// Runs the vectorizer on one equivalence class, i.e. one set of loads/stores</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  /// in the same BB with the same value for getUnderlyingObject() etc.</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  /// in the same BB with the same value for getUnderlyingObject() etc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  bool runOnEquivalenceClass(const EqClassKey &EqClassKey,</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  bool runOnEquivalenceClass(const EqClassKey &EqClassKey,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">                             ArrayRef<Instruction *> EqClass);</td>
    <td class="lineNumber">272</td>
    <td class="codeline">                             ArrayRef<Instruction *> EqClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  /// Runs the vectorizer on one chain, i.e. a subset of an equivalence class</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  /// Runs the vectorizer on one chain, i.e. a subset of an equivalence class</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  /// where all instructions access a known, constant offset from the first</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  /// where all instructions access a known, constant offset from the first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  /// instruction.</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  /// instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">  bool runOnChain(Chain &C);</td>
    <td class="lineNumber">277</td>
    <td class="codeline">  bool runOnChain(Chain &C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  /// Splits the chain into subchains of instructions which read/write a</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  /// Splits the chain into subchains of instructions which read/write a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  /// contiguous block of memory.  Discards any length-1 subchains (because</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  /// contiguous block of memory.  Discards any length-1 subchains (because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">  /// there's nothing to vectorize in there).</td>
    <td class="lineNumber">281</td>
    <td class="codeline">  /// there's nothing to vectorize in there).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">  std::vector<Chain> splitChainByContiguity(Chain &C);</td>
    <td class="lineNumber">282</td>
    <td class="codeline">  std::vector<Chain> splitChainByContiguity(Chain &C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline"></td>
    <td class="lineNumber">283</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  /// Splits the chain into subchains where it's safe to hoist loads up to the</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  /// Splits the chain into subchains where it's safe to hoist loads up to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  /// beginning of the sub-chain and it's safe to sink loads up to the end of</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  /// beginning of the sub-chain and it's safe to sink loads up to the end of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  /// the sub-chain.  Discards any length-1 subchains.</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  /// the sub-chain.  Discards any length-1 subchains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  std::vector<Chain> splitChainByMayAliasInstrs(Chain &C);</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  std::vector<Chain> splitChainByMayAliasInstrs(Chain &C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  /// Splits the chain into subchains that make legal, aligned accesses.</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  /// Splits the chain into subchains that make legal, aligned accesses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  /// Discards any length-1 subchains.</td>
    <td class="lineNumber">290</td>
    <td class="codeline">  /// Discards any length-1 subchains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  std::vector<Chain> splitChainByAlignment(Chain &C);</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  std::vector<Chain> splitChainByAlignment(Chain &C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  /// Converts the instrs in the chain into a single vectorized load or store.</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  /// Converts the instrs in the chain into a single vectorized load or store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  /// Adds the old scalar loads/stores to ToErase.</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  /// Adds the old scalar loads/stores to ToErase.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  bool vectorizeChain(Chain &C);</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  bool vectorizeChain(Chain &C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline"></td>
    <td class="lineNumber">296</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  /// Tries to compute the offset in bytes PtrB - PtrA.</td>
    <td class="lineNumber">297</td>
    <td class="codeline">  /// Tries to compute the offset in bytes PtrB - PtrA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  std::optional<APInt> getConstantOffset(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  std::optional<APInt> getConstantOffset(Value *PtrA, Value *PtrB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">                                         Instruction *ContextInst,</td>
    <td class="lineNumber">299</td>
    <td class="codeline">                                         Instruction *ContextInst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">                                         unsigned Depth = 0);</td>
    <td class="lineNumber">300</td>
    <td class="codeline">                                         unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  std::optional<APInt> getConstantOffsetComplexAddrs(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  std::optional<APInt> getConstantOffsetComplexAddrs(Value *PtrA, Value *PtrB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">                                                     Instruction *ContextInst,</td>
    <td class="lineNumber">302</td>
    <td class="codeline">                                                     Instruction *ContextInst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">                                                     unsigned Depth);</td>
    <td class="lineNumber">303</td>
    <td class="codeline">                                                     unsigned Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">  std::optional<APInt> getConstantOffsetSelects(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">304</td>
    <td class="codeline">  std::optional<APInt> getConstantOffsetSelects(Value *PtrA, Value *PtrB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">                                                Instruction *ContextInst,</td>
    <td class="lineNumber">305</td>
    <td class="codeline">                                                Instruction *ContextInst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">                                                unsigned Depth);</td>
    <td class="lineNumber">306</td>
    <td class="codeline">                                                unsigned Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline"></td>
    <td class="lineNumber">307</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">  /// Gets the element type of the vector that the chain will load or store.</td>
    <td class="lineNumber">308</td>
    <td class="codeline">  /// Gets the element type of the vector that the chain will load or store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  /// This is nontrivial because the chain may contain elements of different</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  /// This is nontrivial because the chain may contain elements of different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">  /// types; e.g. it's legal to have a chain that contains both i32 and float.</td>
    <td class="lineNumber">310</td>
    <td class="codeline">  /// types; e.g. it's legal to have a chain that contains both i32 and float.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">  Type *getChainElemTy(const Chain &C);</td>
    <td class="lineNumber">311</td>
    <td class="codeline">  Type *getChainElemTy(const Chain &C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline"></td>
    <td class="lineNumber">312</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">  /// Determines whether ChainElem can be moved up (if IsLoad) or down (if</td>
    <td class="lineNumber">313</td>
    <td class="codeline">  /// Determines whether ChainElem can be moved up (if IsLoad) or down (if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">  /// !IsLoad) to ChainBegin -- i.e. there are no intervening may-alias</td>
    <td class="lineNumber">314</td>
    <td class="codeline">  /// !IsLoad) to ChainBegin -- i.e. there are no intervening may-alias</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">  /// instructions.</td>
    <td class="lineNumber">315</td>
    <td class="codeline">  /// instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">316</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">  /// The map ChainElemOffsets must contain all of the elements in</td>
    <td class="lineNumber">317</td>
    <td class="codeline">  /// The map ChainElemOffsets must contain all of the elements in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">  /// [ChainBegin, ChainElem] and their offsets from some arbitrary base</td>
    <td class="lineNumber">318</td>
    <td class="codeline">  /// [ChainBegin, ChainElem] and their offsets from some arbitrary base</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">  /// address.  It's ok if it contains additional entries.</td>
    <td class="lineNumber">319</td>
    <td class="codeline">  /// address.  It's ok if it contains additional entries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">  template <bool IsLoadChain></td>
    <td class="lineNumber">320</td>
    <td class="codeline">  template <bool IsLoadChain></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">  bool isSafeToMove(</td>
    <td class="lineNumber">321</td>
    <td class="codeline">  bool isSafeToMove(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">      Instruction *ChainElem, Instruction *ChainBegin,</td>
    <td class="lineNumber">322</td>
    <td class="codeline">      Instruction *ChainElem, Instruction *ChainBegin,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">      const DenseMap<Instruction *, APInt /*OffsetFromLeader*/> &ChainOffsets);</td>
    <td class="lineNumber">323</td>
    <td class="codeline">      const DenseMap<Instruction *, APInt /*OffsetFromLeader*/> &ChainOffsets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline"></td>
    <td class="lineNumber">324</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">  /// Collects loads and stores grouped by "equivalence class", where:</td>
    <td class="lineNumber">325</td>
    <td class="codeline">  /// Collects loads and stores grouped by "equivalence class", where:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">  ///   - all elements in an eq class are a load or all are a store,</td>
    <td class="lineNumber">326</td>
    <td class="codeline">  ///   - all elements in an eq class are a load or all are a store,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">  ///   - they all load/store the same element size (it's OK to have e.g. i8 and</td>
    <td class="lineNumber">327</td>
    <td class="codeline">  ///   - they all load/store the same element size (it's OK to have e.g. i8 and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">  ///     <4 x i8> in the same class, but not i32 and <4 x i8>), and</td>
    <td class="lineNumber">328</td>
    <td class="codeline">  ///     <4 x i8> in the same class, but not i32 and <4 x i8>), and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  ///   - they all have the same value for getUnderlyingObject().</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  ///   - they all have the same value for getUnderlyingObject().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  EquivalenceClassMap collectEquivalenceClasses(BasicBlock::iterator Begin,</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  EquivalenceClassMap collectEquivalenceClasses(BasicBlock::iterator Begin,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">                                                BasicBlock::iterator End);</td>
    <td class="lineNumber">331</td>
    <td class="codeline">                                                BasicBlock::iterator End);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline"></td>
    <td class="lineNumber">332</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">  /// Partitions Instrs into "chains" where every instruction has a known</td>
    <td class="lineNumber">333</td>
    <td class="codeline">  /// Partitions Instrs into "chains" where every instruction has a known</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">  /// constant offset from the first instr in the chain.</td>
    <td class="lineNumber">334</td>
    <td class="codeline">  /// constant offset from the first instr in the chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">  /// Postcondition: For all i, ret[i][0].second == 0, because the first instr</td>
    <td class="lineNumber">336</td>
    <td class="codeline">  /// Postcondition: For all i, ret[i][0].second == 0, because the first instr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  /// in the chain is the leader, and an instr touches distance 0 from itself.</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  /// in the chain is the leader, and an instr touches distance 0 from itself.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">  std::vector<Chain> gatherChains(ArrayRef<Instruction *> Instrs);</td>
    <td class="lineNumber">338</td>
    <td class="codeline">  std::vector<Chain> gatherChains(ArrayRef<Instruction *> Instrs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">};</td>
    <td class="lineNumber">339</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline"></td>
    <td class="lineNumber">340</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">class LoadStoreVectorizerLegacyPass : public FunctionPass {</td>
    <td class="lineNumber">341</td>
    <td class="codeline">class LoadStoreVectorizerLegacyPass : public FunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">342</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  LoadStoreVectorizerLegacyPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  LoadStoreVectorizerLegacyPass() : FunctionPass(ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">    initializeLoadStoreVectorizerLegacyPassPass(</td>
    <td class="lineNumber">346</td>
    <td class="codeline">    initializeLoadStoreVectorizerLegacyPassPass(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">        *PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">347</td>
    <td class="codeline">        *PassRegistry::getPassRegistry());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">348</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline"></td>
    <td class="lineNumber">349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">350</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline"></td>
    <td class="lineNumber">351</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">  StringRef getPassName() const override {</td>
    <td class="lineNumber">352</td>
    <td class="codeline">  StringRef getPassName() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">    return "GPU Load and Store Vectorizer";</td>
    <td class="lineNumber">353</td>
    <td class="codeline">    return "GPU Load and Store Vectorizer";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline"></td>
    <td class="lineNumber">355</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">357</td>
    <td class="codeline">    AU.addRequired<AAResultsWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">358</td>
    <td class="codeline">    AU.addRequired<AssumptionCacheTracker>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td class="lineNumber">359</td>
    <td class="codeline">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">360</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td class="lineNumber">361</td>
    <td class="codeline">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">    AU.setPreservesCFG();</td>
    <td class="lineNumber">362</td>
    <td class="codeline">    AU.setPreservesCFG();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">};</td>
    <td class="lineNumber">364</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline"></td>
    <td class="lineNumber">365</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">366</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">char LoadStoreVectorizerLegacyPass::ID = 0;</td>
    <td class="lineNumber">368</td>
    <td class="codeline">char LoadStoreVectorizerLegacyPass::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(LoadStoreVectorizerLegacyPass, DEBUG_TYPE,</td>
    <td class="lineNumber">370</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(LoadStoreVectorizerLegacyPass, DEBUG_TYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">                      "Vectorize load and Store instructions", false, false)</td>
    <td class="lineNumber">371</td>
    <td class="codeline">                      "Vectorize load and Store instructions", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(SCEVAAWrapperPass)</td>
    <td class="lineNumber">372</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(SCEVAAWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker);</td>
    <td class="lineNumber">373</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">374</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">375</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(GlobalsAAWrapperPass)</td>
    <td class="lineNumber">376</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(GlobalsAAWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td class="lineNumber">377</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">INITIALIZE_PASS_END(LoadStoreVectorizerLegacyPass, DEBUG_TYPE,</td>
    <td class="lineNumber">378</td>
    <td class="codeline">INITIALIZE_PASS_END(LoadStoreVectorizerLegacyPass, DEBUG_TYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">                    "Vectorize load and store instructions", false, false)</td>
    <td class="lineNumber">379</td>
    <td class="codeline">                    "Vectorize load and store instructions", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline"></td>
    <td class="lineNumber">380</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">Pass *llvm::createLoadStoreVectorizerPass() {</td>
    <td class="lineNumber">381</td>
    <td class="codeline">Pass *llvm::createLoadStoreVectorizerPass() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">  return new LoadStoreVectorizerLegacyPass();</td>
    <td class="lineNumber">382</td>
    <td class="codeline">  return new LoadStoreVectorizerLegacyPass();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">}</td>
    <td class="lineNumber">383</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">bool LoadStoreVectorizerLegacyPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">385</td>
    <td class="codeline">bool LoadStoreVectorizerLegacyPass::runOnFunction(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">  // Don't vectorize when the attribute NoImplicitFloat is used.</td>
    <td class="lineNumber">386</td>
    <td class="codeline">  // Don't vectorize when the attribute NoImplicitFloat is used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  if (skipFunction(F) || F.hasFnAttribute(Attribute::NoImplicitFloat))</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  if (skipFunction(F) || F.hasFnAttribute(Attribute::NoImplicitFloat))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">388</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  AliasAnalysis &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  AliasAnalysis &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">  DominatorTree &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">391</td>
    <td class="codeline">  DominatorTree &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">  ScalarEvolution &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td class="lineNumber">392</td>
    <td class="codeline">  ScalarEvolution &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  TargetTransformInfo &TTI =</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  TargetTransformInfo &TTI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">      getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td class="lineNumber">394</td>
    <td class="codeline">      getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  AssumptionCache &AC =</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  AssumptionCache &AC =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">      getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">397</td>
    <td class="codeline">      getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline"></td>
    <td class="lineNumber">398</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">  return Vectorizer(F, AA, AC, DT, SE, TTI).run();</td>
    <td class="lineNumber">399</td>
    <td class="codeline">  return Vectorizer(F, AA, AC, DT, SE, TTI).run();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">}</td>
    <td class="lineNumber">400</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">PreservedAnalyses LoadStoreVectorizerPass::run(Function &F,</td>
    <td class="lineNumber">402</td>
    <td class="codeline">PreservedAnalyses LoadStoreVectorizerPass::run(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">                                               FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">403</td>
    <td class="codeline">                                               FunctionAnalysisManager &AM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  // Don't vectorize when the attribute NoImplicitFloat is used.</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  // Don't vectorize when the attribute NoImplicitFloat is used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  if (F.hasFnAttribute(Attribute::NoImplicitFloat))</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  if (F.hasFnAttribute(Attribute::NoImplicitFloat))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    return PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline"></td>
    <td class="lineNumber">407</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">  AliasAnalysis &AA = AM.getResult<AAManager>(F);</td>
    <td class="lineNumber">408</td>
    <td class="codeline">  AliasAnalysis &AA = AM.getResult<AAManager>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">  ScalarEvolution &SE = AM.getResult<ScalarEvolutionAnalysis>(F);</td>
    <td class="lineNumber">410</td>
    <td class="codeline">  ScalarEvolution &SE = AM.getResult<ScalarEvolutionAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  TargetTransformInfo &TTI = AM.getResult<TargetIRAnalysis>(F);</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  TargetTransformInfo &TTI = AM.getResult<TargetIRAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  AssumptionCache &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  AssumptionCache &AC = AM.getResult<AssumptionAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline"></td>
    <td class="lineNumber">413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">  bool Changed = Vectorizer(F, AA, AC, DT, SE, TTI).run();</td>
    <td class="lineNumber">414</td>
    <td class="codeline">  bool Changed = Vectorizer(F, AA, AC, DT, SE, TTI).run();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  PreservedAnalyses PA;</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  PreservedAnalyses PA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">  PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">416</td>
    <td class="codeline">  PA.preserveSet<CFGAnalyses>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">  return Changed ? PA : PreservedAnalyses::all();</td>
    <td class="lineNumber">417</td>
    <td class="codeline">  return Changed ? PA : PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">}</td>
    <td class="lineNumber">418</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline"></td>
    <td class="lineNumber">419</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">bool Vectorizer::run() {</td>
    <td class="lineNumber">420</td>
    <td class="codeline">bool Vectorizer::run() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">421</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  // Break up the BB if there are any instrs which aren't guaranteed to transfer</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  // Break up the BB if there are any instrs which aren't guaranteed to transfer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  // execution to their successor.</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  // execution to their successor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  // Consider, for example:</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  // Consider, for example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  //   def assert_arr_len(int n) { if (n < 2) exit(); }</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  //   def assert_arr_len(int n) { if (n < 2) exit(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  //   load arr[0]</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  //   load arr[0]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  //   call assert_array_len(arr.length)</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  //   call assert_array_len(arr.length)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  //   load arr[1]</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  //   load arr[1]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  // Even though assert_arr_len does not read or write any memory, we can't</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  // Even though assert_arr_len does not read or write any memory, we can't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">  // speculate the second load before the call.  More info at</td>
    <td class="lineNumber">434</td>
    <td class="codeline">  // speculate the second load before the call.  More info at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  // https://github.com/llvm/llvm-project/issues/52950.</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  // https://github.com/llvm/llvm-project/issues/52950.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  for (BasicBlock *BB : post_order(&F)) {</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  for (BasicBlock *BB : post_order(&F)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">    // BB must at least have a terminator.</td>
    <td class="lineNumber">437</td>
    <td class="codeline">    // BB must at least have a terminator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">    assert(!BB->empty());</td>
    <td class="lineNumber">438</td>
    <td class="codeline">    assert(!BB->empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline"></td>
    <td class="lineNumber">439</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">    SmallVector<BasicBlock::iterator, 8> Barriers;</td>
    <td class="lineNumber">440</td>
    <td class="codeline">    SmallVector<BasicBlock::iterator, 8> Barriers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">    Barriers.push_back(BB->begin());</td>
    <td class="lineNumber">441</td>
    <td class="codeline">    Barriers.push_back(BB->begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">    for (Instruction &I : *BB)</td>
    <td class="lineNumber">442</td>
    <td class="codeline">    for (Instruction &I : *BB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">      if (!isGuaranteedToTransferExecutionToSuccessor(&I))</td>
    <td class="lineNumber">443</td>
    <td class="codeline">      if (!isGuaranteedToTransferExecutionToSuccessor(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">        Barriers.push_back(I.getIterator());</td>
    <td class="lineNumber">444</td>
    <td class="codeline">        Barriers.push_back(I.getIterator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">    Barriers.push_back(BB->end());</td>
    <td class="lineNumber">445</td>
    <td class="codeline">    Barriers.push_back(BB->end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline"></td>
    <td class="lineNumber">446</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">    for (auto It = Barriers.begin(), End = std::prev(Barriers.end()); It != End;</td>
    <td class="lineNumber">447</td>
    <td class="codeline">    for (auto It = Barriers.begin(), End = std::prev(Barriers.end()); It != End;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">         ++It)</td>
    <td class="lineNumber">448</td>
    <td class="codeline">         ++It)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">      Changed |= runOnPseudoBB(*It, *std::next(It));</td>
    <td class="lineNumber">449</td>
    <td class="codeline">      Changed |= runOnPseudoBB(*It, *std::next(It));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline"></td>
    <td class="lineNumber">450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">    for (Instruction *I : ToErase) {</td>
    <td class="lineNumber">451</td>
    <td class="codeline">    for (Instruction *I : ToErase) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">      auto *PtrOperand = getLoadStorePointerOperand(I);</td>
    <td class="lineNumber">452</td>
    <td class="codeline">      auto *PtrOperand = getLoadStorePointerOperand(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">      if (I->use_empty())</td>
    <td class="lineNumber">453</td>
    <td class="codeline">      if (I->use_empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">        I->eraseFromParent();</td>
    <td class="lineNumber">454</td>
    <td class="codeline">        I->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">      RecursivelyDeleteTriviallyDeadInstructions(PtrOperand);</td>
    <td class="lineNumber">455</td>
    <td class="codeline">      RecursivelyDeleteTriviallyDeadInstructions(PtrOperand);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">456</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">    ToErase.clear();</td>
    <td class="lineNumber">457</td>
    <td class="codeline">    ToErase.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">458</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline"></td>
    <td class="lineNumber">459</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">460</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">}</td>
    <td class="lineNumber">461</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">bool Vectorizer::runOnPseudoBB(BasicBlock::iterator Begin,</td>
    <td class="lineNumber">463</td>
    <td class="codeline">bool Vectorizer::runOnPseudoBB(BasicBlock::iterator Begin,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">                               BasicBlock::iterator End) {</td>
    <td class="lineNumber">464</td>
    <td class="codeline">                               BasicBlock::iterator End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">    dbgs() << "LSV: Running on pseudo-BB [" << *Begin << " ... ";</td>
    <td class="lineNumber">466</td>
    <td class="codeline">    dbgs() << "LSV: Running on pseudo-BB [" << *Begin << " ... ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">    if (End != Begin->getParent()->end())</td>
    <td class="lineNumber">467</td>
    <td class="codeline">    if (End != Begin->getParent()->end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">      dbgs() << *End;</td>
    <td class="lineNumber">468</td>
    <td class="codeline">      dbgs() << *End;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">469</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">      dbgs() << "<BB end>";</td>
    <td class="lineNumber">470</td>
    <td class="codeline">      dbgs() << "<BB end>";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">    dbgs() << ")\n";</td>
    <td class="lineNumber">471</td>
    <td class="codeline">    dbgs() << ")\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline"></td>
    <td class="lineNumber">473</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  for (const auto &[EqClassKey, EqClass] :</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  for (const auto &[EqClassKey, EqClass] :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">       collectEquivalenceClasses(Begin, End))</td>
    <td class="lineNumber">476</td>
    <td class="codeline">       collectEquivalenceClasses(Begin, End))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">    Changed |= runOnEquivalenceClass(EqClassKey, EqClass);</td>
    <td class="lineNumber">477</td>
    <td class="codeline">    Changed |= runOnEquivalenceClass(EqClassKey, EqClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline"></td>
    <td class="lineNumber">478</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">}</td>
    <td class="lineNumber">480</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">bool Vectorizer::runOnEquivalenceClass(const EqClassKey &EqClassKey,</td>
    <td class="lineNumber">482</td>
    <td class="codeline">bool Vectorizer::runOnEquivalenceClass(const EqClassKey &EqClassKey,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">                                       ArrayRef<Instruction *> EqClass) {</td>
    <td class="lineNumber">483</td>
    <td class="codeline">                                       ArrayRef<Instruction *> EqClass) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">    dbgs() << "LSV: Running on equivalence class of size " << EqClass.size()</td>
    <td class="lineNumber">487</td>
    <td class="codeline">    dbgs() << "LSV: Running on equivalence class of size " << EqClass.size()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">           << " keyed on " << EqClassKey << ":\n";</td>
    <td class="lineNumber">488</td>
    <td class="codeline">           << " keyed on " << EqClassKey << ":\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">    for (Instruction *I : EqClass)</td>
    <td class="lineNumber">489</td>
    <td class="codeline">    for (Instruction *I : EqClass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">      dbgs() << "  " << *I << "\n";</td>
    <td class="lineNumber">490</td>
    <td class="codeline">      dbgs() << "  " << *I << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline"></td>
    <td class="lineNumber">492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  std::vector<Chain> Chains = gatherChains(EqClass);</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  std::vector<Chain> Chains = gatherChains(EqClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: Got " << Chains.size()</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: Got " << Chains.size()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">                    << " nontrivial chains.\n";);</td>
    <td class="lineNumber">495</td>
    <td class="codeline">                    << " nontrivial chains.\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  for (Chain &C : Chains)</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  for (Chain &C : Chains)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">    Changed |= runOnChain(C);</td>
    <td class="lineNumber">497</td>
    <td class="codeline">    Changed |= runOnChain(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">498</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">}</td>
    <td class="lineNumber">499</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline"></td>
    <td class="lineNumber">500</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">bool Vectorizer::runOnChain(Chain &C) {</td>
    <td class="lineNumber">501</td>
    <td class="codeline">bool Vectorizer::runOnChain(Chain &C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">502</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">    dbgs() << "LSV: Running on chain with " << C.size() << " instructions:\n";</td>
    <td class="lineNumber">503</td>
    <td class="codeline">    dbgs() << "LSV: Running on chain with " << C.size() << " instructions:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">    dumpChain(C);</td>
    <td class="lineNumber">504</td>
    <td class="codeline">    dumpChain(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">505</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline"></td>
    <td class="lineNumber">506</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">  // Split up the chain into increasingly smaller chains, until we can finally</td>
    <td class="lineNumber">507</td>
    <td class="codeline">  // Split up the chain into increasingly smaller chains, until we can finally</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  // vectorize the chains.</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  // vectorize the chains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  // (Don't be scared by the depth of the loop nest here.  These operations are</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  // (Don't be scared by the depth of the loop nest here.  These operations are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  // all at worst O(n lg n) in the number of instructions, and splitting chains</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  // all at worst O(n lg n) in the number of instructions, and splitting chains</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  // doesn't change the number of instrs.  So the whole loop nest is O(n lg n).)</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  // doesn't change the number of instrs.  So the whole loop nest is O(n lg n).)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">513</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  for (auto &C : splitChainByMayAliasInstrs(C))</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  for (auto &C : splitChainByMayAliasInstrs(C))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">    for (auto &C : splitChainByContiguity(C))</td>
    <td class="lineNumber">515</td>
    <td class="codeline">    for (auto &C : splitChainByContiguity(C))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">      for (auto &C : splitChainByAlignment(C))</td>
    <td class="lineNumber">516</td>
    <td class="codeline">      for (auto &C : splitChainByAlignment(C))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">        Changed |= vectorizeChain(C);</td>
    <td class="lineNumber">517</td>
    <td class="codeline">        Changed |= vectorizeChain(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">518</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">}</td>
    <td class="lineNumber">519</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">std::vector<Chain> Vectorizer::splitChainByMayAliasInstrs(Chain &C) {</td>
    <td class="lineNumber">521</td>
    <td class="codeline">std::vector<Chain> Vectorizer::splitChainByMayAliasInstrs(Chain &C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  if (C.empty())</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  if (C.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">    return {};</td>
    <td class="lineNumber">523</td>
    <td class="codeline">    return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  sortChainInBBOrder(C);</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  sortChainInBBOrder(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">    dbgs() << "LSV: splitChainByMayAliasInstrs considering chain:\n";</td>
    <td class="lineNumber">528</td>
    <td class="codeline">    dbgs() << "LSV: splitChainByMayAliasInstrs considering chain:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">    dumpChain(C);</td>
    <td class="lineNumber">529</td>
    <td class="codeline">    dumpChain(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline"></td>
    <td class="lineNumber">531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">  // We know that elements in the chain with nonverlapping offsets can't</td>
    <td class="lineNumber">532</td>
    <td class="codeline">  // We know that elements in the chain with nonverlapping offsets can't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">  // alias, but AA may not be smart enough to figure this out.  Use a</td>
    <td class="lineNumber">533</td>
    <td class="codeline">  // alias, but AA may not be smart enough to figure this out.  Use a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">  // hashtable.</td>
    <td class="lineNumber">534</td>
    <td class="codeline">  // hashtable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">  DenseMap<Instruction *, APInt /*OffsetFromLeader*/> ChainOffsets;</td>
    <td class="lineNumber">535</td>
    <td class="codeline">  DenseMap<Instruction *, APInt /*OffsetFromLeader*/> ChainOffsets;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  for (const auto &E : C)</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  for (const auto &E : C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">    ChainOffsets.insert({&*E.Inst, E.OffsetFromLeader});</td>
    <td class="lineNumber">537</td>
    <td class="codeline">    ChainOffsets.insert({&*E.Inst, E.OffsetFromLeader});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline"></td>
    <td class="lineNumber">538</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  // Loads get hoisted up to the first load in the chain.  Stores get sunk</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  // Loads get hoisted up to the first load in the chain.  Stores get sunk</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">  // down to the last store in the chain.  Our algorithm for loads is:</td>
    <td class="lineNumber">540</td>
    <td class="codeline">  // down to the last store in the chain.  Our algorithm for loads is:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  //  - Take the first element of the chain.  This is the start of a new chain.</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  //  - Take the first element of the chain.  This is the start of a new chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">  //  - Take the next element of `Chain` and check for may-alias instructions</td>
    <td class="lineNumber">543</td>
    <td class="codeline">  //  - Take the next element of `Chain` and check for may-alias instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">  //    up to the start of NewChain.  If no may-alias instrs, add it to</td>
    <td class="lineNumber">544</td>
    <td class="codeline">  //    up to the start of NewChain.  If no may-alias instrs, add it to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">  //    NewChain.  Otherwise, start a new NewChain.</td>
    <td class="lineNumber">545</td>
    <td class="codeline">  //    NewChain.  Otherwise, start a new NewChain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">546</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  // For stores it's the same except in the reverse direction.</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  // For stores it's the same except in the reverse direction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">  // We expect IsLoad to be an std::bool_constant.</td>
    <td class="lineNumber">549</td>
    <td class="codeline">  // We expect IsLoad to be an std::bool_constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  auto Impl = [&](auto IsLoad) {</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  auto Impl = [&](auto IsLoad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">    // MSVC is unhappy if IsLoad is a capture, so pass it as an arg.</td>
    <td class="lineNumber">551</td>
    <td class="codeline">    // MSVC is unhappy if IsLoad is a capture, so pass it as an arg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">    auto [ChainBegin, ChainEnd] = [&](auto IsLoad) {</td>
    <td class="lineNumber">552</td>
    <td class="codeline">    auto [ChainBegin, ChainEnd] = [&](auto IsLoad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">      if constexpr (IsLoad())</td>
    <td class="lineNumber">553</td>
    <td class="codeline">      if constexpr (IsLoad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">        return std::make_pair(C.begin(), C.end());</td>
    <td class="lineNumber">554</td>
    <td class="codeline">        return std::make_pair(C.begin(), C.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">555</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">        return std::make_pair(C.rbegin(), C.rend());</td>
    <td class="lineNumber">556</td>
    <td class="codeline">        return std::make_pair(C.rbegin(), C.rend());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">    }(IsLoad);</td>
    <td class="lineNumber">557</td>
    <td class="codeline">    }(IsLoad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">    assert(ChainBegin != ChainEnd);</td>
    <td class="lineNumber">558</td>
    <td class="codeline">    assert(ChainBegin != ChainEnd);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">    std::vector<Chain> Chains;</td>
    <td class="lineNumber">560</td>
    <td class="codeline">    std::vector<Chain> Chains;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">    SmallVector<ChainElem, 1> NewChain;</td>
    <td class="lineNumber">561</td>
    <td class="codeline">    SmallVector<ChainElem, 1> NewChain;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">    NewChain.push_back(*ChainBegin);</td>
    <td class="lineNumber">562</td>
    <td class="codeline">    NewChain.push_back(*ChainBegin);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">    for (auto ChainIt = std::next(ChainBegin); ChainIt != ChainEnd; ++ChainIt) {</td>
    <td class="lineNumber">563</td>
    <td class="codeline">    for (auto ChainIt = std::next(ChainBegin); ChainIt != ChainEnd; ++ChainIt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">      if (isSafeToMove<IsLoad>(ChainIt->Inst, NewChain.front().Inst,</td>
    <td class="lineNumber">564</td>
    <td class="codeline">      if (isSafeToMove<IsLoad>(ChainIt->Inst, NewChain.front().Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">                               ChainOffsets)) {</td>
    <td class="lineNumber">565</td>
    <td class="codeline">                               ChainOffsets)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "LSV: No intervening may-alias instrs; can merge "</td>
    <td class="lineNumber">566</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "LSV: No intervening may-alias instrs; can merge "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">                          << *ChainIt->Inst << " into " << *ChainBegin->Inst</td>
    <td class="lineNumber">567</td>
    <td class="codeline">                          << *ChainIt->Inst << " into " << *ChainBegin->Inst</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">                          << "\n");</td>
    <td class="lineNumber">568</td>
    <td class="codeline">                          << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">        NewChain.push_back(*ChainIt);</td>
    <td class="lineNumber">569</td>
    <td class="codeline">        NewChain.push_back(*ChainIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">570</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">        LLVM_DEBUG(</td>
    <td class="lineNumber">571</td>
    <td class="codeline">        LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">            dbgs() << "LSV: Found intervening may-alias instrs; cannot merge "</td>
    <td class="lineNumber">572</td>
    <td class="codeline">            dbgs() << "LSV: Found intervening may-alias instrs; cannot merge "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">                   << *ChainIt->Inst << " into " << *ChainBegin->Inst << "\n");</td>
    <td class="lineNumber">573</td>
    <td class="codeline">                   << *ChainIt->Inst << " into " << *ChainBegin->Inst << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">        if (NewChain.size() > 1) {</td>
    <td class="lineNumber">574</td>
    <td class="codeline">        if (NewChain.size() > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">          LLVM_DEBUG({</td>
    <td class="lineNumber">575</td>
    <td class="codeline">          LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">            dbgs() << "LSV: got nontrivial chain without aliasing instrs:\n";</td>
    <td class="lineNumber">576</td>
    <td class="codeline">            dbgs() << "LSV: got nontrivial chain without aliasing instrs:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">            dumpChain(NewChain);</td>
    <td class="lineNumber">577</td>
    <td class="codeline">            dumpChain(NewChain);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">          });</td>
    <td class="lineNumber">578</td>
    <td class="codeline">          });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">          Chains.push_back(std::move(NewChain));</td>
    <td class="lineNumber">579</td>
    <td class="codeline">          Chains.push_back(std::move(NewChain));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">580</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">        // Start a new chain.</td>
    <td class="lineNumber">582</td>
    <td class="codeline">        // Start a new chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">        NewChain = SmallVector<ChainElem, 1>({*ChainIt});</td>
    <td class="lineNumber">583</td>
    <td class="codeline">        NewChain = SmallVector<ChainElem, 1>({*ChainIt});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">584</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">585</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">    if (NewChain.size() > 1) {</td>
    <td class="lineNumber">586</td>
    <td class="codeline">    if (NewChain.size() > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">      LLVM_DEBUG({</td>
    <td class="lineNumber">587</td>
    <td class="codeline">      LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">        dbgs() << "LSV: got nontrivial chain without aliasing instrs:\n";</td>
    <td class="lineNumber">588</td>
    <td class="codeline">        dbgs() << "LSV: got nontrivial chain without aliasing instrs:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">        dumpChain(NewChain);</td>
    <td class="lineNumber">589</td>
    <td class="codeline">        dumpChain(NewChain);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">      });</td>
    <td class="lineNumber">590</td>
    <td class="codeline">      });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">      Chains.push_back(std::move(NewChain));</td>
    <td class="lineNumber">591</td>
    <td class="codeline">      Chains.push_back(std::move(NewChain));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">592</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    return Chains;</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    return Chains;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">594</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline"></td>
    <td class="lineNumber">595</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  if (isa<LoadInst>(C[0].Inst))</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  if (isa<LoadInst>(C[0].Inst))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">    return Impl(/*IsLoad=*/std::bool_constant<true>());</td>
    <td class="lineNumber">597</td>
    <td class="codeline">    return Impl(/*IsLoad=*/std::bool_constant<true>());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  assert(isa<StoreInst>(C[0].Inst));</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  assert(isa<StoreInst>(C[0].Inst));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  return Impl(/*IsLoad=*/std::bool_constant<false>());</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  return Impl(/*IsLoad=*/std::bool_constant<false>());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">}</td>
    <td class="lineNumber">601</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">std::vector<Chain> Vectorizer::splitChainByContiguity(Chain &C) {</td>
    <td class="lineNumber">603</td>
    <td class="codeline">std::vector<Chain> Vectorizer::splitChainByContiguity(Chain &C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  if (C.empty())</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  if (C.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    return {};</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline"></td>
    <td class="lineNumber">606</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">  sortChainInOffsetOrder(C);</td>
    <td class="lineNumber">607</td>
    <td class="codeline">  sortChainInOffsetOrder(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline"></td>
    <td class="lineNumber">608</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">609</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">    dbgs() << "LSV: splitChainByContiguity considering chain:\n";</td>
    <td class="lineNumber">610</td>
    <td class="codeline">    dbgs() << "LSV: splitChainByContiguity considering chain:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">    dumpChain(C);</td>
    <td class="lineNumber">611</td>
    <td class="codeline">    dumpChain(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">612</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">  std::vector<Chain> Ret;</td>
    <td class="lineNumber">614</td>
    <td class="codeline">  std::vector<Chain> Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  Ret.push_back({C.front()});</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  Ret.push_back({C.front()});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline"></td>
    <td class="lineNumber">616</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  for (auto It = std::next(C.begin()), End = C.end(); It != End; ++It) {</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  for (auto It = std::next(C.begin()), End = C.end(); It != End; ++It) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">    // `prev` accesses offsets [PrevDistFromBase, PrevReadEnd).</td>
    <td class="lineNumber">618</td>
    <td class="codeline">    // `prev` accesses offsets [PrevDistFromBase, PrevReadEnd).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">    auto &CurChain = Ret.back();</td>
    <td class="lineNumber">619</td>
    <td class="codeline">    auto &CurChain = Ret.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">    const ChainElem &Prev = CurChain.back();</td>
    <td class="lineNumber">620</td>
    <td class="codeline">    const ChainElem &Prev = CurChain.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">    unsigned SzBits = DL.getTypeSizeInBits(getLoadStoreType(&*Prev.Inst));</td>
    <td class="lineNumber">621</td>
    <td class="codeline">    unsigned SzBits = DL.getTypeSizeInBits(getLoadStoreType(&*Prev.Inst));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">    assert(SzBits % 8 == 0 && "Non-byte sizes should have been filtered out by "</td>
    <td class="lineNumber">622</td>
    <td class="codeline">    assert(SzBits % 8 == 0 && "Non-byte sizes should have been filtered out by "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">                              "collectEquivalenceClass");</td>
    <td class="lineNumber">623</td>
    <td class="codeline">                              "collectEquivalenceClass");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">    APInt PrevReadEnd = Prev.OffsetFromLeader + SzBits / 8;</td>
    <td class="lineNumber">624</td>
    <td class="codeline">    APInt PrevReadEnd = Prev.OffsetFromLeader + SzBits / 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline"></td>
    <td class="lineNumber">625</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">    // Add this instruction to the end of the current chain, or start a new one.</td>
    <td class="lineNumber">626</td>
    <td class="codeline">    // Add this instruction to the end of the current chain, or start a new one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">    bool AreContiguous = It->OffsetFromLeader == PrevReadEnd;</td>
    <td class="lineNumber">627</td>
    <td class="codeline">    bool AreContiguous = It->OffsetFromLeader == PrevReadEnd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "LSV: Instructions are "</td>
    <td class="lineNumber">628</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "LSV: Instructions are "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">                      << (AreContiguous ? "" : "not ") << "contiguous: "</td>
    <td class="lineNumber">629</td>
    <td class="codeline">                      << (AreContiguous ? "" : "not ") << "contiguous: "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">                      << *Prev.Inst << " (ends at offset " << PrevReadEnd</td>
    <td class="lineNumber">630</td>
    <td class="codeline">                      << *Prev.Inst << " (ends at offset " << PrevReadEnd</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">                      << ") -> " << *It->Inst << " (starts at offset "</td>
    <td class="lineNumber">631</td>
    <td class="codeline">                      << ") -> " << *It->Inst << " (starts at offset "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">                      << It->OffsetFromLeader << ")\n");</td>
    <td class="lineNumber">632</td>
    <td class="codeline">                      << It->OffsetFromLeader << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">    if (AreContiguous)</td>
    <td class="lineNumber">633</td>
    <td class="codeline">    if (AreContiguous)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">      CurChain.push_back(*It);</td>
    <td class="lineNumber">634</td>
    <td class="codeline">      CurChain.push_back(*It);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">635</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">      Ret.push_back({*It});</td>
    <td class="lineNumber">636</td>
    <td class="codeline">      Ret.push_back({*It});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">637</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline"></td>
    <td class="lineNumber">638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">  // Filter out length-1 chains, these are uninteresting.</td>
    <td class="lineNumber">639</td>
    <td class="codeline">  // Filter out length-1 chains, these are uninteresting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">  llvm::erase_if(Ret, [](const auto &Chain) { return Chain.size() <= 1; });</td>
    <td class="lineNumber">640</td>
    <td class="codeline">  llvm::erase_if(Ret, [](const auto &Chain) { return Chain.size() <= 1; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">}</td>
    <td class="lineNumber">642</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline"></td>
    <td class="lineNumber">643</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">Type *Vectorizer::getChainElemTy(const Chain &C) {</td>
    <td class="lineNumber">644</td>
    <td class="codeline">Type *Vectorizer::getChainElemTy(const Chain &C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  assert(!C.empty());</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  assert(!C.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">  // The rules are:</td>
    <td class="lineNumber">646</td>
    <td class="codeline">  // The rules are:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  //  - If there are any pointer types in the chain, use an integer type.</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  //  - If there are any pointer types in the chain, use an integer type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">  //  - Prefer an integer type if it appears in the chain.</td>
    <td class="lineNumber">648</td>
    <td class="codeline">  //  - Prefer an integer type if it appears in the chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  //  - Otherwise, use the first type in the chain.</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  //  - Otherwise, use the first type in the chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">650</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  // The rule about pointer types is a simplification when we merge e.g.  a load</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  // The rule about pointer types is a simplification when we merge e.g.  a load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">  // of a ptr and a double.  There's no direct conversion from a ptr to a</td>
    <td class="lineNumber">652</td>
    <td class="codeline">  // of a ptr and a double.  There's no direct conversion from a ptr to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">  // double; it requires a ptrtoint followed by a bitcast.</td>
    <td class="lineNumber">653</td>
    <td class="codeline">  // double; it requires a ptrtoint followed by a bitcast.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  // It's unclear to me if the other rules have any practical effect, but we do</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  // It's unclear to me if the other rules have any practical effect, but we do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  // it to match this pass's previous behavior.</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  // it to match this pass's previous behavior.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">  if (any_of(C, [](const ChainElem &E) {</td>
    <td class="lineNumber">657</td>
    <td class="codeline">  if (any_of(C, [](const ChainElem &E) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">        return getLoadStoreType(E.Inst)->getScalarType()->isPointerTy();</td>
    <td class="lineNumber">658</td>
    <td class="codeline">        return getLoadStoreType(E.Inst)->getScalarType()->isPointerTy();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">      })) {</td>
    <td class="lineNumber">659</td>
    <td class="codeline">      })) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">    return Type::getIntNTy(</td>
    <td class="lineNumber">660</td>
    <td class="codeline">    return Type::getIntNTy(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">        F.getContext(),</td>
    <td class="lineNumber">661</td>
    <td class="codeline">        F.getContext(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">        DL.getTypeSizeInBits(getLoadStoreType(C[0].Inst)->getScalarType()));</td>
    <td class="lineNumber">662</td>
    <td class="codeline">        DL.getTypeSizeInBits(getLoadStoreType(C[0].Inst)->getScalarType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">663</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline"></td>
    <td class="lineNumber">664</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">665</td>
    <td class="codeline">  for (const ChainElem &E : C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">    if (Type *T = getLoadStoreType(E.Inst)->getScalarType(); T->isIntegerTy())</td>
    <td class="lineNumber">666</td>
    <td class="codeline">    if (Type *T = getLoadStoreType(E.Inst)->getScalarType(); T->isIntegerTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">      return T;</td>
    <td class="lineNumber">667</td>
    <td class="codeline">      return T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  return getLoadStoreType(C[0].Inst)->getScalarType();</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  return getLoadStoreType(C[0].Inst)->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">}</td>
    <td class="lineNumber">669</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline"></td>
    <td class="lineNumber">670</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">std::vector<Chain> Vectorizer::splitChainByAlignment(Chain &C) {</td>
    <td class="lineNumber">671</td>
    <td class="codeline">std::vector<Chain> Vectorizer::splitChainByAlignment(Chain &C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">  // We use a simple greedy algorithm.</td>
    <td class="lineNumber">672</td>
    <td class="codeline">  // We use a simple greedy algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  //  - Given a chain of length N, find all prefixes that</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  //  - Given a chain of length N, find all prefixes that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  //    (a) are not longer than the max register length, and</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  //    (a) are not longer than the max register length, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">  //    (b) are a power of 2.</td>
    <td class="lineNumber">675</td>
    <td class="codeline">  //    (b) are a power of 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">  //  - Starting from the longest prefix, try to create a vector of that length.</td>
    <td class="lineNumber">676</td>
    <td class="codeline">  //  - Starting from the longest prefix, try to create a vector of that length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">  //  - If one of them works, great.  Repeat the algorithm on any remaining</td>
    <td class="lineNumber">677</td>
    <td class="codeline">  //  - If one of them works, great.  Repeat the algorithm on any remaining</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">  //    elements in the chain.</td>
    <td class="lineNumber">678</td>
    <td class="codeline">  //    elements in the chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  //  - If none of them work, discard the first element and repeat on a chain</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  //  - If none of them work, discard the first element and repeat on a chain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  //    of length N-1.</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  //    of length N-1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  if (C.empty())</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  if (C.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">    return {};</td>
    <td class="lineNumber">682</td>
    <td class="codeline">    return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  sortChainInOffsetOrder(C);</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  sortChainInOffsetOrder(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">    dbgs() << "LSV: splitChainByAlignment considering chain:\n";</td>
    <td class="lineNumber">687</td>
    <td class="codeline">    dbgs() << "LSV: splitChainByAlignment considering chain:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">    dumpChain(C);</td>
    <td class="lineNumber">688</td>
    <td class="codeline">    dumpChain(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline"></td>
    <td class="lineNumber">690</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">  bool IsLoadChain = isa<LoadInst>(C[0].Inst);</td>
    <td class="lineNumber">691</td>
    <td class="codeline">  bool IsLoadChain = isa<LoadInst>(C[0].Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  auto getVectorFactor = [&](unsigned VF, unsigned LoadStoreSize,</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  auto getVectorFactor = [&](unsigned VF, unsigned LoadStoreSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">                             unsigned ChainSizeBytes, VectorType *VecTy) {</td>
    <td class="lineNumber">693</td>
    <td class="codeline">                             unsigned ChainSizeBytes, VectorType *VecTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">    return IsLoadChain ? TTI.getLoadVectorFactor(VF, LoadStoreSize,</td>
    <td class="lineNumber">694</td>
    <td class="codeline">    return IsLoadChain ? TTI.getLoadVectorFactor(VF, LoadStoreSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">                                                 ChainSizeBytes, VecTy)</td>
    <td class="lineNumber">695</td>
    <td class="codeline">                                                 ChainSizeBytes, VecTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">                       : TTI.getStoreVectorFactor(VF, LoadStoreSize,</td>
    <td class="lineNumber">696</td>
    <td class="codeline">                       : TTI.getStoreVectorFactor(VF, LoadStoreSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">                                                  ChainSizeBytes, VecTy);</td>
    <td class="lineNumber">697</td>
    <td class="codeline">                                                  ChainSizeBytes, VecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline"></td>
    <td class="lineNumber">699</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">700</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">  for (const auto &E : C) {</td>
    <td class="lineNumber">701</td>
    <td class="codeline">  for (const auto &E : C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">    Type *Ty = getLoadStoreType(E.Inst)->getScalarType();</td>
    <td class="lineNumber">702</td>
    <td class="codeline">    Type *Ty = getLoadStoreType(E.Inst)->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">    assert(isPowerOf2_32(DL.getTypeSizeInBits(Ty)) &&</td>
    <td class="lineNumber">703</td>
    <td class="codeline">    assert(isPowerOf2_32(DL.getTypeSizeInBits(Ty)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">           "Should have filtered out non-power-of-two elements in "</td>
    <td class="lineNumber">704</td>
    <td class="codeline">           "Should have filtered out non-power-of-two elements in "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">           "collectEquivalenceClasses.");</td>
    <td class="lineNumber">705</td>
    <td class="codeline">           "collectEquivalenceClasses.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">706</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">707</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  unsigned AS = getLoadStoreAddressSpace(C[0].Inst);</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  unsigned AS = getLoadStoreAddressSpace(C[0].Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">  unsigned VecRegBytes = TTI.getLoadStoreVecRegBitWidth(AS) / 8;</td>
    <td class="lineNumber">710</td>
    <td class="codeline">  unsigned VecRegBytes = TTI.getLoadStoreVecRegBitWidth(AS) / 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">  std::vector<Chain> Ret;</td>
    <td class="lineNumber">712</td>
    <td class="codeline">  std::vector<Chain> Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">  for (unsigned CBegin = 0; CBegin < C.size(); ++CBegin) {</td>
    <td class="lineNumber">713</td>
    <td class="codeline">  for (unsigned CBegin = 0; CBegin < C.size(); ++CBegin) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">    // Find candidate chains of size not greater than the largest vector reg.</td>
    <td class="lineNumber">714</td>
    <td class="codeline">    // Find candidate chains of size not greater than the largest vector reg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">    // These chains are over the closed interval [CBegin, CEnd].</td>
    <td class="lineNumber">715</td>
    <td class="codeline">    // These chains are over the closed interval [CBegin, CEnd].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">    SmallVector<std::pair<unsigned /*CEnd*/, unsigned /*SizeBytes*/>, 8></td>
    <td class="lineNumber">716</td>
    <td class="codeline">    SmallVector<std::pair<unsigned /*CEnd*/, unsigned /*SizeBytes*/>, 8></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">        CandidateChains;</td>
    <td class="lineNumber">717</td>
    <td class="codeline">        CandidateChains;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">    for (unsigned CEnd = CBegin + 1, Size = C.size(); CEnd < Size; ++CEnd) {</td>
    <td class="lineNumber">718</td>
    <td class="codeline">    for (unsigned CEnd = CBegin + 1, Size = C.size(); CEnd < Size; ++CEnd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">      APInt Sz = C[CEnd].OffsetFromLeader +</td>
    <td class="lineNumber">719</td>
    <td class="codeline">      APInt Sz = C[CEnd].OffsetFromLeader +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">                 DL.getTypeStoreSize(getLoadStoreType(C[CEnd].Inst)) -</td>
    <td class="lineNumber">720</td>
    <td class="codeline">                 DL.getTypeStoreSize(getLoadStoreType(C[CEnd].Inst)) -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">                 C[CBegin].OffsetFromLeader;</td>
    <td class="lineNumber">721</td>
    <td class="codeline">                 C[CBegin].OffsetFromLeader;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">      if (Sz.sgt(VecRegBytes))</td>
    <td class="lineNumber">722</td>
    <td class="codeline">      if (Sz.sgt(VecRegBytes))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">723</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">      CandidateChains.push_back(</td>
    <td class="lineNumber">724</td>
    <td class="codeline">      CandidateChains.push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">          {CEnd, static_cast<unsigned>(Sz.getLimitedValue())});</td>
    <td class="lineNumber">725</td>
    <td class="codeline">          {CEnd, static_cast<unsigned>(Sz.getLimitedValue())});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">726</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline"></td>
    <td class="lineNumber">727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">    // Consider the longest chain first.</td>
    <td class="lineNumber">728</td>
    <td class="codeline">    // Consider the longest chain first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">    for (auto It = CandidateChains.rbegin(), End = CandidateChains.rend();</td>
    <td class="lineNumber">729</td>
    <td class="codeline">    for (auto It = CandidateChains.rbegin(), End = CandidateChains.rend();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">         It != End; ++It) {</td>
    <td class="lineNumber">730</td>
    <td class="codeline">         It != End; ++It) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">      auto [CEnd, SizeBytes] = *It;</td>
    <td class="lineNumber">731</td>
    <td class="codeline">      auto [CEnd, SizeBytes] = *It;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">      LLVM_DEBUG(</td>
    <td class="lineNumber">732</td>
    <td class="codeline">      LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">          dbgs() << "LSV: splitChainByAlignment considering candidate chain ["</td>
    <td class="lineNumber">733</td>
    <td class="codeline">          dbgs() << "LSV: splitChainByAlignment considering candidate chain ["</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">                 << *C[CBegin].Inst << " ... " << *C[CEnd].Inst << "]\n");</td>
    <td class="lineNumber">734</td>
    <td class="codeline">                 << *C[CBegin].Inst << " ... " << *C[CEnd].Inst << "]\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline"></td>
    <td class="lineNumber">735</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">      Type *VecElemTy = getChainElemTy(C);</td>
    <td class="lineNumber">736</td>
    <td class="codeline">      Type *VecElemTy = getChainElemTy(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">      // Note, VecElemTy is a power of 2, but might be less than one byte.  For</td>
    <td class="lineNumber">737</td>
    <td class="codeline">      // Note, VecElemTy is a power of 2, but might be less than one byte.  For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">      // example, we can vectorize 2 x <2 x i4> to <4 x i4>, and in this case</td>
    <td class="lineNumber">738</td>
    <td class="codeline">      // example, we can vectorize 2 x <2 x i4> to <4 x i4>, and in this case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">      // VecElemTy would be i4.</td>
    <td class="lineNumber">739</td>
    <td class="codeline">      // VecElemTy would be i4.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">      unsigned VecElemBits = DL.getTypeSizeInBits(VecElemTy);</td>
    <td class="lineNumber">740</td>
    <td class="codeline">      unsigned VecElemBits = DL.getTypeSizeInBits(VecElemTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">      // SizeBytes and VecElemBits are powers of 2, so they divide evenly.</td>
    <td class="lineNumber">742</td>
    <td class="codeline">      // SizeBytes and VecElemBits are powers of 2, so they divide evenly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">      assert((8 * SizeBytes) % VecElemBits == 0);</td>
    <td class="lineNumber">743</td>
    <td class="codeline">      assert((8 * SizeBytes) % VecElemBits == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">      unsigned NumVecElems = 8 * SizeBytes / VecElemBits;</td>
    <td class="lineNumber">744</td>
    <td class="codeline">      unsigned NumVecElems = 8 * SizeBytes / VecElemBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">      FixedVectorType *VecTy = FixedVectorType::get(VecElemTy, NumVecElems);</td>
    <td class="lineNumber">745</td>
    <td class="codeline">      FixedVectorType *VecTy = FixedVectorType::get(VecElemTy, NumVecElems);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">      unsigned VF = 8 * VecRegBytes / VecElemBits;</td>
    <td class="lineNumber">746</td>
    <td class="codeline">      unsigned VF = 8 * VecRegBytes / VecElemBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline"></td>
    <td class="lineNumber">747</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">      // Check that TTI is happy with this vectorization factor.</td>
    <td class="lineNumber">748</td>
    <td class="codeline">      // Check that TTI is happy with this vectorization factor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">      unsigned TargetVF = getVectorFactor(VF, VecElemBits,</td>
    <td class="lineNumber">749</td>
    <td class="codeline">      unsigned TargetVF = getVectorFactor(VF, VecElemBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">                                          VecElemBits * NumVecElems / 8, VecTy);</td>
    <td class="lineNumber">750</td>
    <td class="codeline">                                          VecElemBits * NumVecElems / 8, VecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">      if (TargetVF != VF && TargetVF < NumVecElems) {</td>
    <td class="lineNumber">751</td>
    <td class="codeline">      if (TargetVF != VF && TargetVF < NumVecElems) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">        LLVM_DEBUG(</td>
    <td class="lineNumber">752</td>
    <td class="codeline">        LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td class="lineNumber">753</td>
    <td class="codeline">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">                      "because TargetVF="</td>
    <td class="lineNumber">754</td>
    <td class="codeline">                      "because TargetVF="</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">                   << TargetVF << " != VF=" << VF</td>
    <td class="lineNumber">755</td>
    <td class="codeline">                   << TargetVF << " != VF=" << VF</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">                   << " and TargetVF < NumVecElems=" << NumVecElems << "\n");</td>
    <td class="lineNumber">756</td>
    <td class="codeline">                   << " and TargetVF < NumVecElems=" << NumVecElems << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">757</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">758</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline"></td>
    <td class="lineNumber">759</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">      // Is a load/store with this alignment allowed by TTI and at least as fast</td>
    <td class="lineNumber">760</td>
    <td class="codeline">      // Is a load/store with this alignment allowed by TTI and at least as fast</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">      // as an unvectorized load/store?</td>
    <td class="lineNumber">761</td>
    <td class="codeline">      // as an unvectorized load/store?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">762</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">      // TTI and F are passed as explicit captures to WAR an MSVC misparse (??).</td>
    <td class="lineNumber">763</td>
    <td class="codeline">      // TTI and F are passed as explicit captures to WAR an MSVC misparse (??).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">      auto IsAllowedAndFast = [&, SizeBytes = SizeBytes, &TTI = TTI,</td>
    <td class="lineNumber">764</td>
    <td class="codeline">      auto IsAllowedAndFast = [&, SizeBytes = SizeBytes, &TTI = TTI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">                               &F = F](Align Alignment) {</td>
    <td class="lineNumber">765</td>
    <td class="codeline">                               &F = F](Align Alignment) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">        if (Alignment.value() % SizeBytes == 0)</td>
    <td class="lineNumber">766</td>
    <td class="codeline">        if (Alignment.value() % SizeBytes == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">767</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">        unsigned VectorizedSpeed = 0;</td>
    <td class="lineNumber">768</td>
    <td class="codeline">        unsigned VectorizedSpeed = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">        bool AllowsMisaligned = TTI.allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">769</td>
    <td class="codeline">        bool AllowsMisaligned = TTI.allowsMisalignedMemoryAccesses(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">            F.getContext(), SizeBytes * 8, AS, Alignment, &VectorizedSpeed);</td>
    <td class="lineNumber">770</td>
    <td class="codeline">            F.getContext(), SizeBytes * 8, AS, Alignment, &VectorizedSpeed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">        if (!AllowsMisaligned) {</td>
    <td class="lineNumber">771</td>
    <td class="codeline">        if (!AllowsMisaligned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">772</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">                     << "LSV: Access of " << SizeBytes << "B in addrspace "</td>
    <td class="lineNumber">773</td>
    <td class="codeline">                     << "LSV: Access of " << SizeBytes << "B in addrspace "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">                     << AS << " with alignment " << Alignment.value()</td>
    <td class="lineNumber">774</td>
    <td class="codeline">                     << AS << " with alignment " << Alignment.value()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">                     << " is misaligned, and therefore can't be vectorized.\n");</td>
    <td class="lineNumber">775</td>
    <td class="codeline">                     << " is misaligned, and therefore can't be vectorized.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">776</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">777</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">        unsigned ElementwiseSpeed = 0;</td>
    <td class="lineNumber">779</td>
    <td class="codeline">        unsigned ElementwiseSpeed = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">        (TTI).allowsMisalignedMemoryAccesses((F).getContext(), VecElemBits, AS,</td>
    <td class="lineNumber">780</td>
    <td class="codeline">        (TTI).allowsMisalignedMemoryAccesses((F).getContext(), VecElemBits, AS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">                                             Alignment, &ElementwiseSpeed);</td>
    <td class="lineNumber">781</td>
    <td class="codeline">                                             Alignment, &ElementwiseSpeed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">        if (VectorizedSpeed < ElementwiseSpeed) {</td>
    <td class="lineNumber">782</td>
    <td class="codeline">        if (VectorizedSpeed < ElementwiseSpeed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">783</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">                     << "LSV: Access of " << SizeBytes << "B in addrspace "</td>
    <td class="lineNumber">784</td>
    <td class="codeline">                     << "LSV: Access of " << SizeBytes << "B in addrspace "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">                     << AS << " with alignment " << Alignment.value()</td>
    <td class="lineNumber">785</td>
    <td class="codeline">                     << AS << " with alignment " << Alignment.value()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">                     << " has relative speed " << VectorizedSpeed</td>
    <td class="lineNumber">786</td>
    <td class="codeline">                     << " has relative speed " << VectorizedSpeed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">                     << ", which is lower than the elementwise speed of "</td>
    <td class="lineNumber">787</td>
    <td class="codeline">                     << ", which is lower than the elementwise speed of "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">                     << ElementwiseSpeed</td>
    <td class="lineNumber">788</td>
    <td class="codeline">                     << ElementwiseSpeed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">                     << ".  Therefore this access won't be vectorized.\n");</td>
    <td class="lineNumber">789</td>
    <td class="codeline">                     << ".  Therefore this access won't be vectorized.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">790</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">791</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">792</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">      };</td>
    <td class="lineNumber">793</td>
    <td class="codeline">      };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline"></td>
    <td class="lineNumber">794</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">      // If we're loading/storing from an alloca, align it if possible.</td>
    <td class="lineNumber">795</td>
    <td class="codeline">      // If we're loading/storing from an alloca, align it if possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">796</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">      // FIXME: We eagerly upgrade the alignment, regardless of whether TTI</td>
    <td class="lineNumber">797</td>
    <td class="codeline">      // FIXME: We eagerly upgrade the alignment, regardless of whether TTI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">      // tells us this is beneficial.  This feels a bit odd, but it matches</td>
    <td class="lineNumber">798</td>
    <td class="codeline">      // tells us this is beneficial.  This feels a bit odd, but it matches</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">      // existing tests.  This isn't *so* bad, because at most we align to 4</td>
    <td class="lineNumber">799</td>
    <td class="codeline">      // existing tests.  This isn't *so* bad, because at most we align to 4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">      // bytes (current value of StackAdjustedAlignment).</td>
    <td class="lineNumber">800</td>
    <td class="codeline">      // bytes (current value of StackAdjustedAlignment).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">801</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">      // FIXME: We will upgrade the alignment of the alloca even if it turns out</td>
    <td class="lineNumber">802</td>
    <td class="codeline">      // FIXME: We will upgrade the alignment of the alloca even if it turns out</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">      // we can't vectorize for some other reason.</td>
    <td class="lineNumber">803</td>
    <td class="codeline">      // we can't vectorize for some other reason.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">      Value *PtrOperand = getLoadStorePointerOperand(C[CBegin].Inst);</td>
    <td class="lineNumber">804</td>
    <td class="codeline">      Value *PtrOperand = getLoadStorePointerOperand(C[CBegin].Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">      bool IsAllocaAccess = AS == DL.getAllocaAddrSpace() &&</td>
    <td class="lineNumber">805</td>
    <td class="codeline">      bool IsAllocaAccess = AS == DL.getAllocaAddrSpace() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">                            isa<AllocaInst>(PtrOperand->stripPointerCasts());</td>
    <td class="lineNumber">806</td>
    <td class="codeline">                            isa<AllocaInst>(PtrOperand->stripPointerCasts());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">      Align Alignment = getLoadStoreAlignment(C[CBegin].Inst);</td>
    <td class="lineNumber">807</td>
    <td class="codeline">      Align Alignment = getLoadStoreAlignment(C[CBegin].Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">      Align PrefAlign = Align(StackAdjustedAlignment);</td>
    <td class="lineNumber">808</td>
    <td class="codeline">      Align PrefAlign = Align(StackAdjustedAlignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">      if (IsAllocaAccess && Alignment.value() % SizeBytes != 0 &&</td>
    <td class="lineNumber">809</td>
    <td class="codeline">      if (IsAllocaAccess && Alignment.value() % SizeBytes != 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">          IsAllowedAndFast(PrefAlign)) {</td>
    <td class="lineNumber">810</td>
    <td class="codeline">          IsAllowedAndFast(PrefAlign)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">        Align NewAlign = getOrEnforceKnownAlignment(</td>
    <td class="lineNumber">811</td>
    <td class="codeline">        Align NewAlign = getOrEnforceKnownAlignment(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">            PtrOperand, PrefAlign, DL, C[CBegin].Inst, nullptr, &DT);</td>
    <td class="lineNumber">812</td>
    <td class="codeline">            PtrOperand, PrefAlign, DL, C[CBegin].Inst, nullptr, &DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">        if (NewAlign >= Alignment) {</td>
    <td class="lineNumber">813</td>
    <td class="codeline">        if (NewAlign >= Alignment) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">814</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">                     << "LSV: splitByChain upgrading alloca alignment from "</td>
    <td class="lineNumber">815</td>
    <td class="codeline">                     << "LSV: splitByChain upgrading alloca alignment from "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">                     << Alignment.value() << " to " << NewAlign.value()</td>
    <td class="lineNumber">816</td>
    <td class="codeline">                     << Alignment.value() << " to " << NewAlign.value()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">                     << "\n");</td>
    <td class="lineNumber">817</td>
    <td class="codeline">                     << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">          Alignment = NewAlign;</td>
    <td class="lineNumber">818</td>
    <td class="codeline">          Alignment = NewAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">819</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">820</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline"></td>
    <td class="lineNumber">821</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">      if (!IsAllowedAndFast(Alignment)) {</td>
    <td class="lineNumber">822</td>
    <td class="codeline">      if (!IsAllowedAndFast(Alignment)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">        LLVM_DEBUG(</td>
    <td class="lineNumber">823</td>
    <td class="codeline">        LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td class="lineNumber">824</td>
    <td class="codeline">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">                      "because its alignment is not AllowedAndFast: "</td>
    <td class="lineNumber">825</td>
    <td class="codeline">                      "because its alignment is not AllowedAndFast: "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">                   << Alignment.value() << "\n");</td>
    <td class="lineNumber">826</td>
    <td class="codeline">                   << Alignment.value() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">827</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">828</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline"></td>
    <td class="lineNumber">829</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">      if ((IsLoadChain &&</td>
    <td class="lineNumber">830</td>
    <td class="codeline">      if ((IsLoadChain &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">           !TTI.isLegalToVectorizeLoadChain(SizeBytes, Alignment, AS)) ||</td>
    <td class="lineNumber">831</td>
    <td class="codeline">           !TTI.isLegalToVectorizeLoadChain(SizeBytes, Alignment, AS)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">          (!IsLoadChain &&</td>
    <td class="lineNumber">832</td>
    <td class="codeline">          (!IsLoadChain &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">           !TTI.isLegalToVectorizeStoreChain(SizeBytes, Alignment, AS))) {</td>
    <td class="lineNumber">833</td>
    <td class="codeline">           !TTI.isLegalToVectorizeStoreChain(SizeBytes, Alignment, AS))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">        LLVM_DEBUG(</td>
    <td class="lineNumber">834</td>
    <td class="codeline">        LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td class="lineNumber">835</td>
    <td class="codeline">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">                      "because !isLegalToVectorizeLoad/StoreChain.");</td>
    <td class="lineNumber">836</td>
    <td class="codeline">                      "because !isLegalToVectorizeLoad/StoreChain.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">837</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">838</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline"></td>
    <td class="lineNumber">839</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">      // Hooray, we can vectorize this chain!</td>
    <td class="lineNumber">840</td>
    <td class="codeline">      // Hooray, we can vectorize this chain!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">      Chain &NewChain = Ret.emplace_back();</td>
    <td class="lineNumber">841</td>
    <td class="codeline">      Chain &NewChain = Ret.emplace_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">      for (unsigned I = CBegin; I <= CEnd; ++I)</td>
    <td class="lineNumber">842</td>
    <td class="codeline">      for (unsigned I = CBegin; I <= CEnd; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">        NewChain.push_back(C[I]);</td>
    <td class="lineNumber">843</td>
    <td class="codeline">        NewChain.push_back(C[I]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">      CBegin = CEnd; // Skip over the instructions we've added to the chain.</td>
    <td class="lineNumber">844</td>
    <td class="codeline">      CBegin = CEnd; // Skip over the instructions we've added to the chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">845</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">846</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">}</td>
    <td class="lineNumber">849</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">bool Vectorizer::vectorizeChain(Chain &C) {</td>
    <td class="lineNumber">851</td>
    <td class="codeline">bool Vectorizer::vectorizeChain(Chain &C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">  if (C.size() < 2)</td>
    <td class="lineNumber">852</td>
    <td class="codeline">  if (C.size() < 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">853</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline"></td>
    <td class="lineNumber">854</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">  sortChainInOffsetOrder(C);</td>
    <td class="lineNumber">855</td>
    <td class="codeline">  sortChainInOffsetOrder(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline"></td>
    <td class="lineNumber">856</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">857</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">    dbgs() << "LSV: Vectorizing chain of " << C.size() << " instructions:\n";</td>
    <td class="lineNumber">858</td>
    <td class="codeline">    dbgs() << "LSV: Vectorizing chain of " << C.size() << " instructions:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">    dumpChain(C);</td>
    <td class="lineNumber">859</td>
    <td class="codeline">    dumpChain(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline"></td>
    <td class="lineNumber">861</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">  Type *VecElemTy = getChainElemTy(C);</td>
    <td class="lineNumber">862</td>
    <td class="codeline">  Type *VecElemTy = getChainElemTy(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  bool IsLoadChain = isa<LoadInst>(C[0].Inst);</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  bool IsLoadChain = isa<LoadInst>(C[0].Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">  unsigned AS = getLoadStoreAddressSpace(C[0].Inst);</td>
    <td class="lineNumber">864</td>
    <td class="codeline">  unsigned AS = getLoadStoreAddressSpace(C[0].Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">  unsigned ChainBytes = std::accumulate(</td>
    <td class="lineNumber">865</td>
    <td class="codeline">  unsigned ChainBytes = std::accumulate(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">      C.begin(), C.end(), 0u, [&](unsigned Bytes, const ChainElem &E) {</td>
    <td class="lineNumber">866</td>
    <td class="codeline">      C.begin(), C.end(), 0u, [&](unsigned Bytes, const ChainElem &E) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">        return Bytes + DL.getTypeStoreSize(getLoadStoreType(E.Inst));</td>
    <td class="lineNumber">867</td>
    <td class="codeline">        return Bytes + DL.getTypeStoreSize(getLoadStoreType(E.Inst));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">      });</td>
    <td class="lineNumber">868</td>
    <td class="codeline">      });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">  assert(ChainBytes % DL.getTypeStoreSize(VecElemTy) == 0);</td>
    <td class="lineNumber">869</td>
    <td class="codeline">  assert(ChainBytes % DL.getTypeStoreSize(VecElemTy) == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  // VecTy is a power of 2 and 1 byte at smallest, but VecElemTy may be smaller</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  // VecTy is a power of 2 and 1 byte at smallest, but VecElemTy may be smaller</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">  // than 1 byte (e.g. VecTy == <32 x i1>).</td>
    <td class="lineNumber">871</td>
    <td class="codeline">  // than 1 byte (e.g. VecTy == <32 x i1>).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">  Type *VecTy = FixedVectorType::get(</td>
    <td class="lineNumber">872</td>
    <td class="codeline">  Type *VecTy = FixedVectorType::get(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">      VecElemTy, 8 * ChainBytes / DL.getTypeSizeInBits(VecElemTy));</td>
    <td class="lineNumber">873</td>
    <td class="codeline">      VecElemTy, 8 * ChainBytes / DL.getTypeSizeInBits(VecElemTy));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  Align Alignment = getLoadStoreAlignment(C[0].Inst);</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  Align Alignment = getLoadStoreAlignment(C[0].Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  // If this is a load/store of an alloca, we might have upgraded the alloca's</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  // If this is a load/store of an alloca, we might have upgraded the alloca's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">  // alignment earlier.  Get the new alignment.</td>
    <td class="lineNumber">877</td>
    <td class="codeline">  // alignment earlier.  Get the new alignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">  if (AS == DL.getAllocaAddrSpace()) {</td>
    <td class="lineNumber">878</td>
    <td class="codeline">  if (AS == DL.getAllocaAddrSpace()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">    Alignment = std::max(</td>
    <td class="lineNumber">879</td>
    <td class="codeline">    Alignment = std::max(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">        Alignment,</td>
    <td class="lineNumber">880</td>
    <td class="codeline">        Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">        getOrEnforceKnownAlignment(getLoadStorePointerOperand(C[0].Inst),</td>
    <td class="lineNumber">881</td>
    <td class="codeline">        getOrEnforceKnownAlignment(getLoadStorePointerOperand(C[0].Inst),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">                                   MaybeAlign(), DL, C[0].Inst, nullptr, &DT));</td>
    <td class="lineNumber">882</td>
    <td class="codeline">                                   MaybeAlign(), DL, C[0].Inst, nullptr, &DT));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">883</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline"></td>
    <td class="lineNumber">884</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">  // All elements of the chain must have the same scalar-type size.</td>
    <td class="lineNumber">885</td>
    <td class="codeline">  // All elements of the chain must have the same scalar-type size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">886</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  for (const ChainElem &E : C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">    assert(DL.getTypeStoreSize(getLoadStoreType(E.Inst)->getScalarType()) ==</td>
    <td class="lineNumber">888</td>
    <td class="codeline">    assert(DL.getTypeStoreSize(getLoadStoreType(E.Inst)->getScalarType()) ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">           DL.getTypeStoreSize(VecElemTy));</td>
    <td class="lineNumber">889</td>
    <td class="codeline">           DL.getTypeStoreSize(VecElemTy));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">890</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline"></td>
    <td class="lineNumber">891</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">  Instruction *VecInst;</td>
    <td class="lineNumber">892</td>
    <td class="codeline">  Instruction *VecInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">  if (IsLoadChain) {</td>
    <td class="lineNumber">893</td>
    <td class="codeline">  if (IsLoadChain) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">    // Loads get hoisted to the location of the first load in the chain.  We may</td>
    <td class="lineNumber">894</td>
    <td class="codeline">    // Loads get hoisted to the location of the first load in the chain.  We may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">    // also need to hoist the (transitive) operands of the loads.</td>
    <td class="lineNumber">895</td>
    <td class="codeline">    // also need to hoist the (transitive) operands of the loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">    Builder.SetInsertPoint(</td>
    <td class="lineNumber">896</td>
    <td class="codeline">    Builder.SetInsertPoint(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">        std::min_element(C.begin(), C.end(), [](const auto &A, const auto &B) {</td>
    <td class="lineNumber">897</td>
    <td class="codeline">        std::min_element(C.begin(), C.end(), [](const auto &A, const auto &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">          return A.Inst->comesBefore(B.Inst);</td>
    <td class="lineNumber">898</td>
    <td class="codeline">          return A.Inst->comesBefore(B.Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">        })->Inst);</td>
    <td class="lineNumber">899</td>
    <td class="codeline">        })->Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline"></td>
    <td class="lineNumber">900</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">    // Chain is in offset order, so C[0] is the instr with the lowest offset,</td>
    <td class="lineNumber">901</td>
    <td class="codeline">    // Chain is in offset order, so C[0] is the instr with the lowest offset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">    // i.e. the root of the vector.</td>
    <td class="lineNumber">902</td>
    <td class="codeline">    // i.e. the root of the vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">    Value *Bitcast = Builder.CreateBitCast(</td>
    <td class="lineNumber">903</td>
    <td class="codeline">    Value *Bitcast = Builder.CreateBitCast(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">        getLoadStorePointerOperand(C[0].Inst), VecTy->getPointerTo(AS));</td>
    <td class="lineNumber">904</td>
    <td class="codeline">        getLoadStorePointerOperand(C[0].Inst), VecTy->getPointerTo(AS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">    VecInst = Builder.CreateAlignedLoad(VecTy, Bitcast, Alignment);</td>
    <td class="lineNumber">905</td>
    <td class="codeline">    VecInst = Builder.CreateAlignedLoad(VecTy, Bitcast, Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">    unsigned VecIdx = 0;</td>
    <td class="lineNumber">907</td>
    <td class="codeline">    unsigned VecIdx = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">    for (const ChainElem &E : C) {</td>
    <td class="lineNumber">908</td>
    <td class="codeline">    for (const ChainElem &E : C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">      Instruction *I = E.Inst;</td>
    <td class="lineNumber">909</td>
    <td class="codeline">      Instruction *I = E.Inst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">      Value *V;</td>
    <td class="lineNumber">910</td>
    <td class="codeline">      Value *V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">      Type *T = getLoadStoreType(I);</td>
    <td class="lineNumber">911</td>
    <td class="codeline">      Type *T = getLoadStoreType(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">      if (auto *VT = dyn_cast<FixedVectorType>(T)) {</td>
    <td class="lineNumber">912</td>
    <td class="codeline">      if (auto *VT = dyn_cast<FixedVectorType>(T)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">        auto Mask = llvm::to_vector<8>(</td>
    <td class="lineNumber">913</td>
    <td class="codeline">        auto Mask = llvm::to_vector<8>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">            llvm::seq<int>(VecIdx, VecIdx + VT->getNumElements()));</td>
    <td class="lineNumber">914</td>
    <td class="codeline">            llvm::seq<int>(VecIdx, VecIdx + VT->getNumElements()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">        V = Builder.CreateShuffleVector(VecInst, Mask, I->getName());</td>
    <td class="lineNumber">915</td>
    <td class="codeline">        V = Builder.CreateShuffleVector(VecInst, Mask, I->getName());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">        VecIdx += VT->getNumElements();</td>
    <td class="lineNumber">916</td>
    <td class="codeline">        VecIdx += VT->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">917</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">        V = Builder.CreateExtractElement(VecInst, Builder.getInt32(VecIdx),</td>
    <td class="lineNumber">918</td>
    <td class="codeline">        V = Builder.CreateExtractElement(VecInst, Builder.getInt32(VecIdx),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">                                         I->getName());</td>
    <td class="lineNumber">919</td>
    <td class="codeline">                                         I->getName());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">        ++VecIdx;</td>
    <td class="lineNumber">920</td>
    <td class="codeline">        ++VecIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">921</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">      if (V->getType() != I->getType())</td>
    <td class="lineNumber">922</td>
    <td class="codeline">      if (V->getType() != I->getType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">        V = Builder.CreateBitOrPointerCast(V, I->getType());</td>
    <td class="lineNumber">923</td>
    <td class="codeline">        V = Builder.CreateBitOrPointerCast(V, I->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">      I->replaceAllUsesWith(V);</td>
    <td class="lineNumber">924</td>
    <td class="codeline">      I->replaceAllUsesWith(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">925</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline"></td>
    <td class="lineNumber">926</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">    // Finally, we need to reorder the instrs in the BB so that the (transitive)</td>
    <td class="lineNumber">927</td>
    <td class="codeline">    // Finally, we need to reorder the instrs in the BB so that the (transitive)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">    // operands of VecInst appear before it.  To see why, suppose we have</td>
    <td class="lineNumber">928</td>
    <td class="codeline">    // operands of VecInst appear before it.  To see why, suppose we have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">    // vectorized the following code:</td>
    <td class="lineNumber">929</td>
    <td class="codeline">    // vectorized the following code:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">930</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">    //   ptr1  = gep a, 1</td>
    <td class="lineNumber">931</td>
    <td class="codeline">    //   ptr1  = gep a, 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">    //   load1 = load i32 ptr1</td>
    <td class="lineNumber">932</td>
    <td class="codeline">    //   load1 = load i32 ptr1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">    //   ptr0  = gep a, 0</td>
    <td class="lineNumber">933</td>
    <td class="codeline">    //   ptr0  = gep a, 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">    //   load0 = load i32 ptr0</td>
    <td class="lineNumber">934</td>
    <td class="codeline">    //   load0 = load i32 ptr0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">935</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">    // We will put the vectorized load at the location of the earliest load in</td>
    <td class="lineNumber">936</td>
    <td class="codeline">    // We will put the vectorized load at the location of the earliest load in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">    // the BB, i.e. load1.  We get:</td>
    <td class="lineNumber">937</td>
    <td class="codeline">    // the BB, i.e. load1.  We get:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">938</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">    //   ptr1  = gep a, 1</td>
    <td class="lineNumber">939</td>
    <td class="codeline">    //   ptr1  = gep a, 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">    //   loadv = load <2 x i32> ptr0</td>
    <td class="lineNumber">940</td>
    <td class="codeline">    //   loadv = load <2 x i32> ptr0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">    //   load0 = extractelement loadv, 0</td>
    <td class="lineNumber">941</td>
    <td class="codeline">    //   load0 = extractelement loadv, 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">    //   load1 = extractelement loadv, 1</td>
    <td class="lineNumber">942</td>
    <td class="codeline">    //   load1 = extractelement loadv, 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">    //   ptr0 = gep a, 0</td>
    <td class="lineNumber">943</td>
    <td class="codeline">    //   ptr0 = gep a, 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">944</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">    // Notice that loadv uses ptr0, which is defined *after* it!</td>
    <td class="lineNumber">945</td>
    <td class="codeline">    // Notice that loadv uses ptr0, which is defined *after* it!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">    reorder(VecInst);</td>
    <td class="lineNumber">946</td>
    <td class="codeline">    reorder(VecInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">947</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">    // Stores get sunk to the location of the last store in the chain.</td>
    <td class="lineNumber">948</td>
    <td class="codeline">    // Stores get sunk to the location of the last store in the chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">    Builder.SetInsertPoint(</td>
    <td class="lineNumber">949</td>
    <td class="codeline">    Builder.SetInsertPoint(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">        std::max_element(C.begin(), C.end(), [](auto &A, auto &B) {</td>
    <td class="lineNumber">950</td>
    <td class="codeline">        std::max_element(C.begin(), C.end(), [](auto &A, auto &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">          return A.Inst->comesBefore(B.Inst);</td>
    <td class="lineNumber">951</td>
    <td class="codeline">          return A.Inst->comesBefore(B.Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">        })->Inst);</td>
    <td class="lineNumber">952</td>
    <td class="codeline">        })->Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline"></td>
    <td class="lineNumber">953</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">    // Build the vector to store.</td>
    <td class="lineNumber">954</td>
    <td class="codeline">    // Build the vector to store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">    Value *Vec = PoisonValue::get(VecTy);</td>
    <td class="lineNumber">955</td>
    <td class="codeline">    Value *Vec = PoisonValue::get(VecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">    unsigned VecIdx = 0;</td>
    <td class="lineNumber">956</td>
    <td class="codeline">    unsigned VecIdx = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">    auto InsertElem = [&](Value *V) {</td>
    <td class="lineNumber">957</td>
    <td class="codeline">    auto InsertElem = [&](Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">      if (V->getType() != VecElemTy)</td>
    <td class="lineNumber">958</td>
    <td class="codeline">      if (V->getType() != VecElemTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">        V = Builder.CreateBitOrPointerCast(V, VecElemTy);</td>
    <td class="lineNumber">959</td>
    <td class="codeline">        V = Builder.CreateBitOrPointerCast(V, VecElemTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">      Vec = Builder.CreateInsertElement(Vec, V, Builder.getInt32(VecIdx++));</td>
    <td class="lineNumber">960</td>
    <td class="codeline">      Vec = Builder.CreateInsertElement(Vec, V, Builder.getInt32(VecIdx++));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">961</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">    for (const ChainElem &E : C) {</td>
    <td class="lineNumber">962</td>
    <td class="codeline">    for (const ChainElem &E : C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">      auto I = cast<StoreInst>(E.Inst);</td>
    <td class="lineNumber">963</td>
    <td class="codeline">      auto I = cast<StoreInst>(E.Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">      if (FixedVectorType *VT =</td>
    <td class="lineNumber">964</td>
    <td class="codeline">      if (FixedVectorType *VT =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">              dyn_cast<FixedVectorType>(getLoadStoreType(I))) {</td>
    <td class="lineNumber">965</td>
    <td class="codeline">              dyn_cast<FixedVectorType>(getLoadStoreType(I))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">        for (int J = 0, JE = VT->getNumElements(); J < JE; ++J) {</td>
    <td class="lineNumber">966</td>
    <td class="codeline">        for (int J = 0, JE = VT->getNumElements(); J < JE; ++J) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">          InsertElem(Builder.CreateExtractElement(I->getValueOperand(),</td>
    <td class="lineNumber">967</td>
    <td class="codeline">          InsertElem(Builder.CreateExtractElement(I->getValueOperand(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">                                                  Builder.getInt32(J)));</td>
    <td class="lineNumber">968</td>
    <td class="codeline">                                                  Builder.getInt32(J)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">969</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">970</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">        InsertElem(I->getValueOperand());</td>
    <td class="lineNumber">971</td>
    <td class="codeline">        InsertElem(I->getValueOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">972</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">973</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline"></td>
    <td class="lineNumber">974</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">    // Chain is in offset order, so C[0] is the instr with the lowest offset,</td>
    <td class="lineNumber">975</td>
    <td class="codeline">    // Chain is in offset order, so C[0] is the instr with the lowest offset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">    // i.e. the root of the vector.</td>
    <td class="lineNumber">976</td>
    <td class="codeline">    // i.e. the root of the vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">    VecInst = Builder.CreateAlignedStore(</td>
    <td class="lineNumber">977</td>
    <td class="codeline">    VecInst = Builder.CreateAlignedStore(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">        Vec,</td>
    <td class="lineNumber">978</td>
    <td class="codeline">        Vec,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">        Builder.CreateBitCast(getLoadStorePointerOperand(C[0].Inst),</td>
    <td class="lineNumber">979</td>
    <td class="codeline">        Builder.CreateBitCast(getLoadStorePointerOperand(C[0].Inst),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">                              VecTy->getPointerTo(AS)),</td>
    <td class="lineNumber">980</td>
    <td class="codeline">                              VecTy->getPointerTo(AS)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">        Alignment);</td>
    <td class="lineNumber">981</td>
    <td class="codeline">        Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">982</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline"></td>
    <td class="lineNumber">983</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">  propagateMetadata(VecInst, C);</td>
    <td class="lineNumber">984</td>
    <td class="codeline">  propagateMetadata(VecInst, C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">986</td>
    <td class="codeline">  for (const ChainElem &E : C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">    ToErase.push_back(E.Inst);</td>
    <td class="lineNumber">987</td>
    <td class="codeline">    ToErase.push_back(E.Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  ++NumVectorInstructions;</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  ++NumVectorInstructions;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">  NumScalarsVectorized += C.size();</td>
    <td class="lineNumber">990</td>
    <td class="codeline">  NumScalarsVectorized += C.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">991</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">}</td>
    <td class="lineNumber">992</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">template <bool IsLoadChain></td>
    <td class="lineNumber">994</td>
    <td class="codeline">template <bool IsLoadChain></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">bool Vectorizer::isSafeToMove(</td>
    <td class="lineNumber">995</td>
    <td class="codeline">bool Vectorizer::isSafeToMove(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">    Instruction *ChainElem, Instruction *ChainBegin,</td>
    <td class="lineNumber">996</td>
    <td class="codeline">    Instruction *ChainElem, Instruction *ChainBegin,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">    const DenseMap<Instruction *, APInt /*OffsetFromLeader*/> &ChainOffsets) {</td>
    <td class="lineNumber">997</td>
    <td class="codeline">    const DenseMap<Instruction *, APInt /*OffsetFromLeader*/> &ChainOffsets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: isSafeToMove(" << *ChainElem << " -> "</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: isSafeToMove(" << *ChainElem << " -> "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">                    << *ChainBegin << ")\n");</td>
    <td class="lineNumber">999</td>
    <td class="codeline">                    << *ChainBegin << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline"></td>
    <td class="lineNumber">1000</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">  assert(isa<LoadInst>(ChainElem) == IsLoadChain);</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">  assert(isa<LoadInst>(ChainElem) == IsLoadChain);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">  if (ChainElem == ChainBegin)</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">  if (ChainElem == ChainBegin)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline"></td>
    <td class="lineNumber">1004</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">  // Invariant loads can always be reordered; by definition they are not</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">  // Invariant loads can always be reordered; by definition they are not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">  // clobbered by stores.</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">  // clobbered by stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">  if (isInvariantLoad(ChainElem))</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">  if (isInvariantLoad(ChainElem))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline"></td>
    <td class="lineNumber">1009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">  auto BBIt = std::next([&] {</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">  auto BBIt = std::next([&] {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">    if constexpr (IsLoadChain)</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">    if constexpr (IsLoadChain)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">      return BasicBlock::reverse_iterator(ChainElem);</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">      return BasicBlock::reverse_iterator(ChainElem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">      return BasicBlock::iterator(ChainElem);</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">      return BasicBlock::iterator(ChainElem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">  }());</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">  }());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">  auto BBItEnd = std::next([&] {</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">  auto BBItEnd = std::next([&] {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">    if constexpr (IsLoadChain)</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">    if constexpr (IsLoadChain)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">      return BasicBlock::reverse_iterator(ChainBegin);</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">      return BasicBlock::reverse_iterator(ChainBegin);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">      return BasicBlock::iterator(ChainBegin);</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">      return BasicBlock::iterator(ChainBegin);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">  }());</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">  }());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline"></td>
    <td class="lineNumber">1022</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">  const APInt &ChainElemOffset = ChainOffsets.at(ChainElem);</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">  const APInt &ChainElemOffset = ChainOffsets.at(ChainElem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">  const unsigned ChainElemSize =</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">  const unsigned ChainElemSize =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">      DL.getTypeStoreSize(getLoadStoreType(ChainElem));</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">      DL.getTypeStoreSize(getLoadStoreType(ChainElem));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline"></td>
    <td class="lineNumber">1026</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  for (; BBIt != BBItEnd; ++BBIt) {</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  for (; BBIt != BBItEnd; ++BBIt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">    Instruction *I = &*BBIt;</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">    Instruction *I = &*BBIt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline"></td>
    <td class="lineNumber">1029</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">    if (!I->mayReadOrWriteMemory())</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">    if (!I->mayReadOrWriteMemory())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline"></td>
    <td class="lineNumber">1032</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">    // Loads can be reordered with other loads.</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">    // Loads can be reordered with other loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">    if (IsLoadChain && isa<LoadInst>(I))</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">    if (IsLoadChain && isa<LoadInst>(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline"></td>
    <td class="lineNumber">1036</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">    // Stores can be sunk below invariant loads.</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">    // Stores can be sunk below invariant loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">    if (!IsLoadChain && isInvariantLoad(I))</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">    if (!IsLoadChain && isInvariantLoad(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline"></td>
    <td class="lineNumber">1040</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">    // If I is in the chain, we can tell whether it aliases ChainIt by checking</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">    // If I is in the chain, we can tell whether it aliases ChainIt by checking</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">    // what offset ChainIt accesses.  This may be better than AA is able to do.</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">    // what offset ChainIt accesses.  This may be better than AA is able to do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">    // We should really only have duplicate offsets for stores (the duplicate</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">    // We should really only have duplicate offsets for stores (the duplicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">    // loads should be CSE'ed), but in case we have a duplicate load, we'll</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">    // loads should be CSE'ed), but in case we have a duplicate load, we'll</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">    // split the chain so we don't have to handle this case specially.</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">    // split the chain so we don't have to handle this case specially.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">    if (auto OffsetIt = ChainOffsets.find(I); OffsetIt != ChainOffsets.end()) {</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">    if (auto OffsetIt = ChainOffsets.find(I); OffsetIt != ChainOffsets.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">      // I and ChainElem overlap if:</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">      // I and ChainElem overlap if:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">      //   - I and ChainElem have the same offset, OR</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">      //   - I and ChainElem have the same offset, OR</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">      //   - I's offset is less than ChainElem's, but I touches past the</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">      //   - I's offset is less than ChainElem's, but I touches past the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">      //     beginning of ChainElem, OR</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">      //     beginning of ChainElem, OR</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">      //   - ChainElem's offset is less than I's, but ChainElem touches past the</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">      //   - ChainElem's offset is less than I's, but ChainElem touches past the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">      //     beginning of I.</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">      //     beginning of I.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">      const APInt &IOffset = OffsetIt->second;</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">      const APInt &IOffset = OffsetIt->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">      unsigned IElemSize = DL.getTypeStoreSize(getLoadStoreType(I));</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">      unsigned IElemSize = DL.getTypeStoreSize(getLoadStoreType(I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">      if (IOffset == ChainElemOffset ||</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">      if (IOffset == ChainElemOffset ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">          (IOffset.sle(ChainElemOffset) &&</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">          (IOffset.sle(ChainElemOffset) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">           (IOffset + IElemSize).sgt(ChainElemOffset)) ||</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">           (IOffset + IElemSize).sgt(ChainElemOffset)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">          (ChainElemOffset.sle(IOffset) &&</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">          (ChainElemOffset.sle(IOffset) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">           (ChainElemOffset + ChainElemSize).sgt(OffsetIt->second))) {</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">           (ChainElemOffset + ChainElemSize).sgt(OffsetIt->second))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">        LLVM_DEBUG({</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">        LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">          // Double check that AA also sees this alias.  If not, we probably</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">          // Double check that AA also sees this alias.  If not, we probably</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">          // have a bug.</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">          // have a bug.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">          ModRefInfo MR = AA.getModRefInfo(I, MemoryLocation::get(ChainElem));</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">          ModRefInfo MR = AA.getModRefInfo(I, MemoryLocation::get(ChainElem));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">          assert(IsLoadChain ? isModSet(MR) : isModOrRefSet(MR));</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">          assert(IsLoadChain ? isModSet(MR) : isModOrRefSet(MR));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">          dbgs() << "LSV: Found alias in chain: " << *I << "\n";</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">          dbgs() << "LSV: Found alias in chain: " << *I << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">        return false; // We found an aliasing instruction; bail.</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">        return false; // We found an aliasing instruction; bail.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline"></td>
    <td class="lineNumber">1070</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">      continue; // We're confident there's no alias.</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">      continue; // We're confident there's no alias.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline"></td>
    <td class="lineNumber">1073</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "LSV: Querying AA for " << *I << "\n");</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "LSV: Querying AA for " << *I << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">    ModRefInfo MR = AA.getModRefInfo(I, MemoryLocation::get(ChainElem));</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">    ModRefInfo MR = AA.getModRefInfo(I, MemoryLocation::get(ChainElem));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">    if (IsLoadChain ? isModSet(MR) : isModOrRefSet(MR)) {</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">    if (IsLoadChain ? isModSet(MR) : isModOrRefSet(MR)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "LSV: Found alias in chain:\n"</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "LSV: Found alias in chain:\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">                        << "  Aliasing instruction:\n"</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">                        << "  Aliasing instruction:\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">                        << "    " << *I << '\n'</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">                        << "    " << *I << '\n'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">                        << "  Aliased instruction and pointer:\n"</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">                        << "  Aliased instruction and pointer:\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">                        << "    " << *ChainElem << '\n'</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">                        << "    " << *ChainElem << '\n'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">                        << "    " << *getLoadStorePointerOperand(ChainElem)</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">                        << "    " << *getLoadStorePointerOperand(ChainElem)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">                        << '\n');</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">                        << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline"></td>
    <td class="lineNumber">1084</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline"></td>
    <td class="lineNumber">1090</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">static bool checkNoWrapFlags(Instruction *I, bool Signed) {</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">static bool checkNoWrapFlags(Instruction *I, bool Signed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">  BinaryOperator *BinOpI = cast<BinaryOperator>(I);</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">  BinaryOperator *BinOpI = cast<BinaryOperator>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">  return (Signed && BinOpI->hasNoSignedWrap()) ||</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">  return (Signed && BinOpI->hasNoSignedWrap()) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">         (!Signed && BinOpI->hasNoUnsignedWrap());</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">         (!Signed && BinOpI->hasNoUnsignedWrap());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">static bool checkIfSafeAddSequence(const APInt &IdxDiff, Instruction *AddOpA,</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">static bool checkIfSafeAddSequence(const APInt &IdxDiff, Instruction *AddOpA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">                                   unsigned MatchingOpIdxA, Instruction *AddOpB,</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">                                   unsigned MatchingOpIdxA, Instruction *AddOpB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">                                   unsigned MatchingOpIdxB, bool Signed) {</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">                                   unsigned MatchingOpIdxB, bool Signed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: checkIfSafeAddSequence IdxDiff=" << IdxDiff</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: checkIfSafeAddSequence IdxDiff=" << IdxDiff</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">                    << ", AddOpA=" << *AddOpA << ", MatchingOpIdxA="</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">                    << ", AddOpA=" << *AddOpA << ", MatchingOpIdxA="</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">                    << MatchingOpIdxA << ", AddOpB=" << *AddOpB</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">                    << MatchingOpIdxA << ", AddOpB=" << *AddOpB</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">                    << ", MatchingOpIdxB=" << MatchingOpIdxB</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">                    << ", MatchingOpIdxB=" << MatchingOpIdxB</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">                    << ", Signed=" << Signed << "\n");</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">                    << ", Signed=" << Signed << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  // If both OpA and OpB are adds with NSW/NUW and with one of the operands</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  // If both OpA and OpB are adds with NSW/NUW and with one of the operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">  // being the same, we can guarantee that the transformation is safe if we can</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">  // being the same, we can guarantee that the transformation is safe if we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">  // prove that OpA won't overflow when Ret added to the other operand of OpA.</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">  // prove that OpA won't overflow when Ret added to the other operand of OpA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">  // For example:</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">  // For example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">  //  %tmp7 = add nsw i32 %tmp2, %v0</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">  //  %tmp7 = add nsw i32 %tmp2, %v0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">  //  %tmp8 = sext i32 %tmp7 to i64</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">  //  %tmp8 = sext i32 %tmp7 to i64</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">  //  ...</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">  //  ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">  //  %tmp11 = add nsw i32 %v0, 1</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">  //  %tmp11 = add nsw i32 %v0, 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">  //  %tmp12 = add nsw i32 %tmp2, %tmp11</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">  //  %tmp12 = add nsw i32 %tmp2, %tmp11</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  //  %tmp13 = sext i32 %tmp12 to i64</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  //  %tmp13 = sext i32 %tmp12 to i64</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">  //  Both %tmp7 and %tmp12 have the nsw flag and the first operand is %tmp2.</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">  //  Both %tmp7 and %tmp12 have the nsw flag and the first operand is %tmp2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">  //  It's guaranteed that adding 1 to %tmp7 won't overflow because %tmp11 adds</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">  //  It's guaranteed that adding 1 to %tmp7 won't overflow because %tmp11 adds</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">  //  1 to %v0 and both %tmp11 and %tmp12 have the nsw flag.</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">  //  1 to %v0 and both %tmp11 and %tmp12 have the nsw flag.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">  assert(AddOpA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">  assert(AddOpA->getOpcode() == Instruction::Add &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">         AddOpB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">         AddOpB->getOpcode() == Instruction::Add &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">         checkNoWrapFlags(AddOpA, Signed) && checkNoWrapFlags(AddOpB, Signed));</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">         checkNoWrapFlags(AddOpA, Signed) && checkNoWrapFlags(AddOpB, Signed));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">  if (AddOpA->getOperand(MatchingOpIdxA) ==</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">  if (AddOpA->getOperand(MatchingOpIdxA) ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">      AddOpB->getOperand(MatchingOpIdxB)) {</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">      AddOpB->getOperand(MatchingOpIdxB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">    Value *OtherOperandA = AddOpA->getOperand(MatchingOpIdxA == 1 ? 0 : 1);</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">    Value *OtherOperandA = AddOpA->getOperand(MatchingOpIdxA == 1 ? 0 : 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">    Value *OtherOperandB = AddOpB->getOperand(MatchingOpIdxB == 1 ? 0 : 1);</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">    Value *OtherOperandB = AddOpB->getOperand(MatchingOpIdxB == 1 ? 0 : 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">    Instruction *OtherInstrA = dyn_cast<Instruction>(OtherOperandA);</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">    Instruction *OtherInstrA = dyn_cast<Instruction>(OtherOperandA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">    Instruction *OtherInstrB = dyn_cast<Instruction>(OtherOperandB);</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">    Instruction *OtherInstrB = dyn_cast<Instruction>(OtherOperandB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">    // Match `x +nsw/nuw y` and `x +nsw/nuw (y +nsw/nuw IdxDiff)`.</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">    // Match `x +nsw/nuw y` and `x +nsw/nuw (y +nsw/nuw IdxDiff)`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">    if (OtherInstrB && OtherInstrB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">    if (OtherInstrB && OtherInstrB->getOpcode() == Instruction::Add &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">        checkNoWrapFlags(OtherInstrB, Signed) &&</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">        checkNoWrapFlags(OtherInstrB, Signed) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">        isa<ConstantInt>(OtherInstrB->getOperand(1))) {</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">        isa<ConstantInt>(OtherInstrB->getOperand(1))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">      int64_t CstVal =</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">      int64_t CstVal =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">          cast<ConstantInt>(OtherInstrB->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">          cast<ConstantInt>(OtherInstrB->getOperand(1))->getSExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">      if (OtherInstrB->getOperand(0) == OtherOperandA &&</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">      if (OtherInstrB->getOperand(0) == OtherOperandA &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">          IdxDiff.getSExtValue() == CstVal)</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">          IdxDiff.getSExtValue() == CstVal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">    // Match `x +nsw/nuw (y +nsw/nuw -Idx)` and `x +nsw/nuw (y +nsw/nuw x)`.</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">    // Match `x +nsw/nuw (y +nsw/nuw -Idx)` and `x +nsw/nuw (y +nsw/nuw x)`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">    if (OtherInstrA && OtherInstrA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">    if (OtherInstrA && OtherInstrA->getOpcode() == Instruction::Add &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">        checkNoWrapFlags(OtherInstrA, Signed) &&</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">        checkNoWrapFlags(OtherInstrA, Signed) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">        isa<ConstantInt>(OtherInstrA->getOperand(1))) {</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">        isa<ConstantInt>(OtherInstrA->getOperand(1))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">      int64_t CstVal =</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">      int64_t CstVal =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">          cast<ConstantInt>(OtherInstrA->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">          cast<ConstantInt>(OtherInstrA->getOperand(1))->getSExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">      if (OtherInstrA->getOperand(0) == OtherOperandB &&</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">      if (OtherInstrA->getOperand(0) == OtherOperandB &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">          IdxDiff.getSExtValue() == -CstVal)</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">          IdxDiff.getSExtValue() == -CstVal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">    // Match `x +nsw/nuw (y +nsw/nuw c)` and</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">    // Match `x +nsw/nuw (y +nsw/nuw c)` and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">    // `x +nsw/nuw (y +nsw/nuw (c + IdxDiff))`.</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">    // `x +nsw/nuw (y +nsw/nuw (c + IdxDiff))`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">    if (OtherInstrA && OtherInstrB &&</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">    if (OtherInstrA && OtherInstrB &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">        OtherInstrA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">        OtherInstrA->getOpcode() == Instruction::Add &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">        OtherInstrB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">        OtherInstrB->getOpcode() == Instruction::Add &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">        checkNoWrapFlags(OtherInstrA, Signed) &&</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">        checkNoWrapFlags(OtherInstrA, Signed) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">        checkNoWrapFlags(OtherInstrB, Signed) &&</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">        checkNoWrapFlags(OtherInstrB, Signed) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">        isa<ConstantInt>(OtherInstrA->getOperand(1)) &&</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">        isa<ConstantInt>(OtherInstrA->getOperand(1)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">        isa<ConstantInt>(OtherInstrB->getOperand(1))) {</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">        isa<ConstantInt>(OtherInstrB->getOperand(1))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">      int64_t CstValA =</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">      int64_t CstValA =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">          cast<ConstantInt>(OtherInstrA->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">          cast<ConstantInt>(OtherInstrA->getOperand(1))->getSExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">      int64_t CstValB =</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">      int64_t CstValB =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">          cast<ConstantInt>(OtherInstrB->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">          cast<ConstantInt>(OtherInstrB->getOperand(1))->getSExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">      if (OtherInstrA->getOperand(0) == OtherInstrB->getOperand(0) &&</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">      if (OtherInstrA->getOperand(0) == OtherInstrB->getOperand(0) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">          IdxDiff.getSExtValue() == (CstValB - CstValA))</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">          IdxDiff.getSExtValue() == (CstValB - CstValA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline"></td>
    <td class="lineNumber">1168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">std::optional<APInt> Vectorizer::getConstantOffsetComplexAddrs(</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">std::optional<APInt> Vectorizer::getConstantOffsetComplexAddrs(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">    Value *PtrA, Value *PtrB, Instruction *ContextInst, unsigned Depth) {</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">    Value *PtrA, Value *PtrB, Instruction *ContextInst, unsigned Depth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetComplexAddrs PtrA=" << *PtrA</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetComplexAddrs PtrA=" << *PtrA</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">                    << " PtrB=" << *PtrB << " ContextInst=" << *ContextInst</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">                    << " PtrB=" << *PtrB << " ContextInst=" << *ContextInst</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">                    << " Depth=" << Depth << "\n");</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">                    << " Depth=" << Depth << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">  auto *GEPA = dyn_cast<GetElementPtrInst>(PtrA);</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">  auto *GEPA = dyn_cast<GetElementPtrInst>(PtrA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">  auto *GEPB = dyn_cast<GetElementPtrInst>(PtrB);</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">  auto *GEPB = dyn_cast<GetElementPtrInst>(PtrB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">  if (!GEPA || !GEPB)</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">  if (!GEPA || !GEPB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">    return getConstantOffsetSelects(PtrA, PtrB, ContextInst, Depth);</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">    return getConstantOffsetSelects(PtrA, PtrB, ContextInst, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline"></td>
    <td class="lineNumber">1178</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">  // Look through GEPs after checking they're the same except for the last</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">  // Look through GEPs after checking they're the same except for the last</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">  // index.</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">  // index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">  if (GEPA->getNumOperands() != GEPB->getNumOperands() ||</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">  if (GEPA->getNumOperands() != GEPB->getNumOperands() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">      GEPA->getPointerOperand() != GEPB->getPointerOperand())</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">      GEPA->getPointerOperand() != GEPB->getPointerOperand())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">  gep_type_iterator GTIA = gep_type_begin(GEPA);</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">  gep_type_iterator GTIA = gep_type_begin(GEPA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">  gep_type_iterator GTIB = gep_type_begin(GEPB);</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">  gep_type_iterator GTIB = gep_type_begin(GEPB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">  for (unsigned I = 0, E = GEPA->getNumIndices() - 1; I < E; ++I) {</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">  for (unsigned I = 0, E = GEPA->getNumIndices() - 1; I < E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">    if (GTIA.getOperand() != GTIB.getOperand())</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">    if (GTIA.getOperand() != GTIB.getOperand())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">      return std::nullopt;</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">      return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">    ++GTIA;</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">    ++GTIA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">    ++GTIB;</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">    ++GTIB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">  Instruction *OpA = dyn_cast<Instruction>(GTIA.getOperand());</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">  Instruction *OpA = dyn_cast<Instruction>(GTIA.getOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">  Instruction *OpB = dyn_cast<Instruction>(GTIB.getOperand());</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">  Instruction *OpB = dyn_cast<Instruction>(GTIB.getOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">  if (!OpA || !OpB || OpA->getOpcode() != OpB->getOpcode() ||</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">  if (!OpA || !OpB || OpA->getOpcode() != OpB->getOpcode() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">      OpA->getType() != OpB->getType())</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">      OpA->getType() != OpB->getType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline"></td>
    <td class="lineNumber">1198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">  uint64_t Stride = DL.getTypeAllocSize(GTIA.getIndexedType());</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">  uint64_t Stride = DL.getTypeAllocSize(GTIA.getIndexedType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline"></td>
    <td class="lineNumber">1200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">  // Only look through a ZExt/SExt.</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">  // Only look through a ZExt/SExt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">  if (!isa<SExtInst>(OpA) && !isa<ZExtInst>(OpA))</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">  if (!isa<SExtInst>(OpA) && !isa<ZExtInst>(OpA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  bool Signed = isa<SExtInst>(OpA);</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  bool Signed = isa<SExtInst>(OpA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline"></td>
    <td class="lineNumber">1206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">  // At this point A could be a function parameter, i.e. not an instruction</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">  // At this point A could be a function parameter, i.e. not an instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">  Value *ValA = OpA->getOperand(0);</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">  Value *ValA = OpA->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">  OpB = dyn_cast<Instruction>(OpB->getOperand(0));</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">  OpB = dyn_cast<Instruction>(OpB->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">  if (!OpB || ValA->getType() != OpB->getType())</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">  if (!OpB || ValA->getType() != OpB->getType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">  const SCEV *OffsetSCEVA = SE.getSCEV(ValA);</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">  const SCEV *OffsetSCEVA = SE.getSCEV(ValA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  const SCEV *OffsetSCEVB = SE.getSCEV(OpB);</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  const SCEV *OffsetSCEVB = SE.getSCEV(OpB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">  const SCEV *IdxDiffSCEV = SE.getMinusSCEV(OffsetSCEVB, OffsetSCEVA);</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">  const SCEV *IdxDiffSCEV = SE.getMinusSCEV(OffsetSCEVB, OffsetSCEVA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">  if (IdxDiffSCEV == SE.getCouldNotCompute())</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">  if (IdxDiffSCEV == SE.getCouldNotCompute())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline"></td>
    <td class="lineNumber">1218</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">  ConstantRange IdxDiffRange = SE.getSignedRange(IdxDiffSCEV);</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">  ConstantRange IdxDiffRange = SE.getSignedRange(IdxDiffSCEV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">  if (!IdxDiffRange.isSingleElement())</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">  if (!IdxDiffRange.isSingleElement())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  APInt IdxDiff = *IdxDiffRange.getSingleElement();</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  APInt IdxDiff = *IdxDiffRange.getSingleElement();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline"></td>
    <td class="lineNumber">1223</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetComplexAddrs IdxDiff=" << IdxDiff</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetComplexAddrs IdxDiff=" << IdxDiff</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">                    << "\n");</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">                    << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline"></td>
    <td class="lineNumber">1226</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  // Now we need to prove that adding IdxDiff to ValA won't overflow.</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  // Now we need to prove that adding IdxDiff to ValA won't overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">  bool Safe = false;</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">  bool Safe = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline"></td>
    <td class="lineNumber">1229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  // First attempt: if OpB is an add with NSW/NUW, and OpB is IdxDiff added to</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  // First attempt: if OpB is an add with NSW/NUW, and OpB is IdxDiff added to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">  // ValA, we're okay.</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">  // ValA, we're okay.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  if (OpB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  if (OpB->getOpcode() == Instruction::Add &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">      isa<ConstantInt>(OpB->getOperand(1)) &&</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">      isa<ConstantInt>(OpB->getOperand(1)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">      IdxDiff.sle(cast<ConstantInt>(OpB->getOperand(1))->getSExtValue()) &&</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">      IdxDiff.sle(cast<ConstantInt>(OpB->getOperand(1))->getSExtValue()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">      checkNoWrapFlags(OpB, Signed))</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">      checkNoWrapFlags(OpB, Signed))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">    Safe = true;</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">    Safe = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline"></td>
    <td class="lineNumber">1237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">  // Second attempt: check if we have eligible add NSW/NUW instruction</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">  // Second attempt: check if we have eligible add NSW/NUW instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">  // sequences.</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">  // sequences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">  OpA = dyn_cast<Instruction>(ValA);</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">  OpA = dyn_cast<Instruction>(ValA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  if (!Safe && OpA && OpA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  if (!Safe && OpA && OpA->getOpcode() == Instruction::Add &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">      OpB->getOpcode() == Instruction::Add && checkNoWrapFlags(OpA, Signed) &&</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">      OpB->getOpcode() == Instruction::Add && checkNoWrapFlags(OpA, Signed) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">      checkNoWrapFlags(OpB, Signed)) {</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">      checkNoWrapFlags(OpB, Signed)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">    // In the checks below a matching operand in OpA and OpB is an operand which</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">    // In the checks below a matching operand in OpA and OpB is an operand which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">    // is the same in those two instructions.  Below we account for possible</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">    // is the same in those two instructions.  Below we account for possible</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">    // orders of the operands of these add instructions.</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">    // orders of the operands of these add instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">    for (unsigned MatchingOpIdxA : {0, 1})</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">    for (unsigned MatchingOpIdxA : {0, 1})</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">      for (unsigned MatchingOpIdxB : {0, 1})</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">      for (unsigned MatchingOpIdxB : {0, 1})</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">        if (!Safe)</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">        if (!Safe)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">          Safe = checkIfSafeAddSequence(IdxDiff, OpA, MatchingOpIdxA, OpB,</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">          Safe = checkIfSafeAddSequence(IdxDiff, OpA, MatchingOpIdxA, OpB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">                                        MatchingOpIdxB, Signed);</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">                                        MatchingOpIdxB, Signed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline"></td>
    <td class="lineNumber">1253</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">  unsigned BitWidth = ValA->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">  unsigned BitWidth = ValA->getType()->getScalarSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline"></td>
    <td class="lineNumber">1255</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  // Third attempt:</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  // Third attempt:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  // Assuming IdxDiff is positive: If all set bits of IdxDiff or any higher</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  // Assuming IdxDiff is positive: If all set bits of IdxDiff or any higher</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">  // order bit other than the sign bit are known to be zero in ValA, we can add</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">  // order bit other than the sign bit are known to be zero in ValA, we can add</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  // Diff to it while guaranteeing no overflow of any sort.</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  // Diff to it while guaranteeing no overflow of any sort.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">  // If IdxDiff is negative, do the same, but swap ValA and ValB.</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">  // If IdxDiff is negative, do the same, but swap ValA and ValB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">  if (!Safe) {</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">  if (!Safe) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">    // When computing known bits, use the GEPs as context instructions, since</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">    // When computing known bits, use the GEPs as context instructions, since</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">    // they likely are in the same BB as the load/store.</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">    // they likely are in the same BB as the load/store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">    KnownBits Known(BitWidth);</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">    KnownBits Known(BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">    computeKnownBits((IdxDiff.sge(0) ? ValA : OpB), Known, DL, 0, &AC,</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">    computeKnownBits((IdxDiff.sge(0) ? ValA : OpB), Known, DL, 0, &AC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">                     ContextInst, &DT);</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">                     ContextInst, &DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">    APInt BitsAllowedToBeSet = Known.Zero.zext(IdxDiff.getBitWidth());</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">    APInt BitsAllowedToBeSet = Known.Zero.zext(IdxDiff.getBitWidth());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">    if (Signed)</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">    if (Signed)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">      BitsAllowedToBeSet.clearBit(BitWidth - 1);</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">      BitsAllowedToBeSet.clearBit(BitWidth - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">    if (BitsAllowedToBeSet.ult(IdxDiff.abs()))</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">    if (BitsAllowedToBeSet.ult(IdxDiff.abs()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">      return std::nullopt;</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">      return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">    Safe = true;</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">    Safe = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">  if (Safe)</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">  if (Safe)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">    return IdxDiff * Stride;</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">    return IdxDiff * Stride;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">  return std::nullopt;</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">  return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline"></td>
    <td class="lineNumber">1281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">std::optional<APInt> Vectorizer::getConstantOffsetSelects(</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">std::optional<APInt> Vectorizer::getConstantOffsetSelects(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">    Value *PtrA, Value *PtrB, Instruction *ContextInst, unsigned Depth) {</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">    Value *PtrA, Value *PtrB, Instruction *ContextInst, unsigned Depth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">  if (Depth++ == MaxDepth)</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">  if (Depth++ == MaxDepth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline"></td>
    <td class="lineNumber">1286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  if (auto *SelectA = dyn_cast<SelectInst>(PtrA)) {</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  if (auto *SelectA = dyn_cast<SelectInst>(PtrA)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">    if (auto *SelectB = dyn_cast<SelectInst>(PtrB)) {</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">    if (auto *SelectB = dyn_cast<SelectInst>(PtrB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">      if (SelectA->getCondition() != SelectB->getCondition())</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">      if (SelectA->getCondition() != SelectB->getCondition())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">        return std::nullopt;</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">        return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetSelects, PtrA=" << *PtrA</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetSelects, PtrA=" << *PtrA</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">                        << ", PtrB=" << *PtrB << ", ContextInst="</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">                        << ", PtrB=" << *PtrB << ", ContextInst="</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">                        << *ContextInst << ", Depth=" << Depth << "\n");</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">                        << *ContextInst << ", Depth=" << Depth << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">      std::optional<APInt> TrueDiff = getConstantOffset(</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">      std::optional<APInt> TrueDiff = getConstantOffset(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">          SelectA->getTrueValue(), SelectB->getTrueValue(), ContextInst, Depth);</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">          SelectA->getTrueValue(), SelectB->getTrueValue(), ContextInst, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">      if (!TrueDiff.has_value())</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">      if (!TrueDiff.has_value())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">        return std::nullopt;</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">        return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">      std::optional<APInt> FalseDiff =</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">      std::optional<APInt> FalseDiff =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">          getConstantOffset(SelectA->getFalseValue(), SelectB->getFalseValue(),</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">          getConstantOffset(SelectA->getFalseValue(), SelectB->getFalseValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">                            ContextInst, Depth);</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">                            ContextInst, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">      if (TrueDiff == FalseDiff)</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">      if (TrueDiff == FalseDiff)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">        return TrueDiff;</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">        return TrueDiff;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">  return std::nullopt;</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">  return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline"></td>
    <td class="lineNumber">1307</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">EquivalenceClassMap</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">EquivalenceClassMap</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">Vectorizer::collectEquivalenceClasses(BasicBlock::iterator Begin,</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">Vectorizer::collectEquivalenceClasses(BasicBlock::iterator Begin,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">                                      BasicBlock::iterator End) {</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">                                      BasicBlock::iterator End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">  EquivalenceClassMap Ret;</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">  EquivalenceClassMap Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline"></td>
    <td class="lineNumber">1312</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  auto getUnderlyingObject = [](const Value *Ptr) -> const Value * {</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  auto getUnderlyingObject = [](const Value *Ptr) -> const Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">    const Value *ObjPtr = llvm::getUnderlyingObject(Ptr);</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">    const Value *ObjPtr = llvm::getUnderlyingObject(Ptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">    if (const auto *Sel = dyn_cast<SelectInst>(ObjPtr)) {</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">    if (const auto *Sel = dyn_cast<SelectInst>(ObjPtr)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">      // The select's themselves are distinct instructions even if they share</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">      // The select's themselves are distinct instructions even if they share</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">      // the same condition and evaluate to consecutive pointers for true and</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">      // the same condition and evaluate to consecutive pointers for true and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">      // false values of the condition. Therefore using the select's themselves</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">      // false values of the condition. Therefore using the select's themselves</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">      // for grouping instructions would put consecutive accesses into different</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">      // for grouping instructions would put consecutive accesses into different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">      // lists and they won't be even checked for being consecutive, and won't</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">      // lists and they won't be even checked for being consecutive, and won't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">      // be vectorized.</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">      // be vectorized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">      return Sel->getCondition();</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">      return Sel->getCondition();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">    return ObjPtr;</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">    return ObjPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline"></td>
    <td class="lineNumber">1326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">  for (Instruction &I : make_range(Begin, End)) {</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">  for (Instruction &I : make_range(Begin, End)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">    auto *LI = dyn_cast<LoadInst>(&I);</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">    auto *LI = dyn_cast<LoadInst>(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">    auto *SI = dyn_cast<StoreInst>(&I);</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">    auto *SI = dyn_cast<StoreInst>(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">    if (!LI && !SI)</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">    if (!LI && !SI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline"></td>
    <td class="lineNumber">1332</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">    if ((LI && !LI->isSimple()) || (SI && !SI->isSimple()))</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">    if ((LI && !LI->isSimple()) || (SI && !SI->isSimple()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline"></td>
    <td class="lineNumber">1335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">    if ((LI && !TTI.isLegalToVectorizeLoad(LI)) ||</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">    if ((LI && !TTI.isLegalToVectorizeLoad(LI)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">        (SI && !TTI.isLegalToVectorizeStore(SI)))</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">        (SI && !TTI.isLegalToVectorizeStore(SI)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline"></td>
    <td class="lineNumber">1339</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">    Type *Ty = getLoadStoreType(&I);</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">    Type *Ty = getLoadStoreType(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">    if (!VectorType::isValidElementType(Ty->getScalarType()))</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">    if (!VectorType::isValidElementType(Ty->getScalarType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">    // Skip weird non-byte sizes. They probably aren't worth the effort of</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">    // Skip weird non-byte sizes. They probably aren't worth the effort of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">    // handling correctly.</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">    // handling correctly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">    unsigned TySize = DL.getTypeSizeInBits(Ty);</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">    unsigned TySize = DL.getTypeSizeInBits(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">    if ((TySize % 8) != 0)</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">    if ((TySize % 8) != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">    // Skip vectors of pointers. The vectorizeLoadChain/vectorizeStoreChain</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">    // Skip vectors of pointers. The vectorizeLoadChain/vectorizeStoreChain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">    // functions are currently using an integer type for the vectorized</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">    // functions are currently using an integer type for the vectorized</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">    // load/store, and does not support casting between the integer type and a</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">    // load/store, and does not support casting between the integer type and a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">    // vector of pointers (e.g. i64 to <2 x i16*>)</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">    // vector of pointers (e.g. i64 to <2 x i16*>)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">    if (Ty->isVectorTy() && Ty->isPtrOrPtrVectorTy())</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">    if (Ty->isVectorTy() && Ty->isPtrOrPtrVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline"></td>
    <td class="lineNumber">1356</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">    Value *Ptr = getLoadStorePointerOperand(&I);</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">    Value *Ptr = getLoadStorePointerOperand(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">    unsigned AS = Ptr->getType()->getPointerAddressSpace();</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">    unsigned AS = Ptr->getType()->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">    unsigned VecRegSize = TTI.getLoadStoreVecRegBitWidth(AS);</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">    unsigned VecRegSize = TTI.getLoadStoreVecRegBitWidth(AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline"></td>
    <td class="lineNumber">1360</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">    unsigned VF = VecRegSize / TySize;</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">    unsigned VF = VecRegSize / TySize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">    VectorType *VecTy = dyn_cast<VectorType>(Ty);</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">    VectorType *VecTy = dyn_cast<VectorType>(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline"></td>
    <td class="lineNumber">1363</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">    // Only handle power-of-two sized elements.</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">    // Only handle power-of-two sized elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">    if ((!VecTy && !isPowerOf2_32(DL.getTypeSizeInBits(Ty))) ||</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">    if ((!VecTy && !isPowerOf2_32(DL.getTypeSizeInBits(Ty))) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">        (VecTy && !isPowerOf2_32(DL.getTypeSizeInBits(VecTy->getScalarType()))))</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">        (VecTy && !isPowerOf2_32(DL.getTypeSizeInBits(VecTy->getScalarType()))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline"></td>
    <td class="lineNumber">1368</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">    // No point in looking at these if they're too big to vectorize.</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">    // No point in looking at these if they're too big to vectorize.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">    if (TySize > VecRegSize / 2 ||</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">    if (TySize > VecRegSize / 2 ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">        (VecTy && TTI.getLoadVectorFactor(VF, TySize, TySize / 8, VecTy) == 0))</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">        (VecTy && TTI.getLoadVectorFactor(VF, TySize, TySize / 8, VecTy) == 0))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline"></td>
    <td class="lineNumber">1373</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">    Ret[{getUnderlyingObject(Ptr), AS,</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">    Ret[{getUnderlyingObject(Ptr), AS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">         DL.getTypeSizeInBits(getLoadStoreType(&I)->getScalarType()),</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">         DL.getTypeSizeInBits(getLoadStoreType(&I)->getScalarType()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">         /*IsLoad=*/LI != nullptr}]</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">         /*IsLoad=*/LI != nullptr}]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">        .push_back(&I);</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">        .push_back(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline"></td>
    <td class="lineNumber">1379</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">std::vector<Chain> Vectorizer::gatherChains(ArrayRef<Instruction *> Instrs) {</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">std::vector<Chain> Vectorizer::gatherChains(ArrayRef<Instruction *> Instrs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">  if (Instrs.empty())</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">  if (Instrs.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">    return {};</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">    return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline"></td>
    <td class="lineNumber">1386</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">  unsigned AS = getLoadStoreAddressSpace(Instrs[0]);</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">  unsigned AS = getLoadStoreAddressSpace(Instrs[0]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">  unsigned ASPtrBits = DL.getIndexSizeInBits(AS);</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">  unsigned ASPtrBits = DL.getIndexSizeInBits(AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">  // Check that Instrs is in BB order and all have the same addr space.</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">  // Check that Instrs is in BB order and all have the same addr space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">  for (size_t I = 1; I < Instrs.size(); ++I) {</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">  for (size_t I = 1; I < Instrs.size(); ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">    assert(Instrs[I - 1]->comesBefore(Instrs[I]));</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">    assert(Instrs[I - 1]->comesBefore(Instrs[I]));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">    assert(getLoadStoreAddressSpace(Instrs[I]) == AS);</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">    assert(getLoadStoreAddressSpace(Instrs[I]) == AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline"></td>
    <td class="lineNumber">1397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">  // Machinery to build an MRU-hashtable of Chains.</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">  // Machinery to build an MRU-hashtable of Chains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">  // (Ideally this could be done with MapVector, but as currently implemented,</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">  // (Ideally this could be done with MapVector, but as currently implemented,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">  // moving an element to the front of a MapVector is O(n).)</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">  // moving an element to the front of a MapVector is O(n).)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">  struct InstrListElem : ilist_node<InstrListElem>,</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">  struct InstrListElem : ilist_node<InstrListElem>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">                         std::pair<Instruction *, Chain> {</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">                         std::pair<Instruction *, Chain> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">    explicit InstrListElem(Instruction *I)</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">    explicit InstrListElem(Instruction *I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">        : std::pair<Instruction *, Chain>(I, {}) {}</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">        : std::pair<Instruction *, Chain>(I, {}) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">  struct InstrListElemDenseMapInfo {</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">  struct InstrListElemDenseMapInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">    using PtrInfo = DenseMapInfo<InstrListElem *>;</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">    using PtrInfo = DenseMapInfo<InstrListElem *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">    using IInfo = DenseMapInfo<Instruction *>;</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">    using IInfo = DenseMapInfo<Instruction *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">    static InstrListElem *getEmptyKey() { return PtrInfo::getEmptyKey(); }</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">    static InstrListElem *getEmptyKey() { return PtrInfo::getEmptyKey(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">    static InstrListElem *getTombstoneKey() {</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">    static InstrListElem *getTombstoneKey() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">      return PtrInfo::getTombstoneKey();</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">      return PtrInfo::getTombstoneKey();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">    static unsigned getHashValue(const InstrListElem *E) {</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">    static unsigned getHashValue(const InstrListElem *E) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">      return IInfo::getHashValue(E->first);</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">      return IInfo::getHashValue(E->first);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">    static bool isEqual(const InstrListElem *A, const InstrListElem *B) {</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">    static bool isEqual(const InstrListElem *A, const InstrListElem *B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">      if (A == getEmptyKey() || B == getEmptyKey())</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">      if (A == getEmptyKey() || B == getEmptyKey())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">        return A == getEmptyKey() && B == getEmptyKey();</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">        return A == getEmptyKey() && B == getEmptyKey();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">      if (A == getTombstoneKey() || B == getTombstoneKey())</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">      if (A == getTombstoneKey() || B == getTombstoneKey())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">        return A == getTombstoneKey() && B == getTombstoneKey();</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">        return A == getTombstoneKey() && B == getTombstoneKey();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">      return IInfo::isEqual(A->first, B->first);</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">      return IInfo::isEqual(A->first, B->first);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">  SpecificBumpPtrAllocator<InstrListElem> Allocator;</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">  SpecificBumpPtrAllocator<InstrListElem> Allocator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">  simple_ilist<InstrListElem> MRU;</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">  simple_ilist<InstrListElem> MRU;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">  DenseSet<InstrListElem *, InstrListElemDenseMapInfo> Chains;</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">  DenseSet<InstrListElem *, InstrListElemDenseMapInfo> Chains;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline"></td>
    <td class="lineNumber">1428</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">  // Compare each instruction in `instrs` to leader of the N most recently-used</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">  // Compare each instruction in `instrs` to leader of the N most recently-used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">  // chains.  This limits the O(n^2) behavior of this pass while also allowing</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">  // chains.  This limits the O(n^2) behavior of this pass while also allowing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">  // us to build arbitrarily long chains.</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">  // us to build arbitrarily long chains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">  for (Instruction *I : Instrs) {</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">  for (Instruction *I : Instrs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">    constexpr int MaxChainsToTry = 64;</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">    constexpr int MaxChainsToTry = 64;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">    bool MatchFound = false;</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">    bool MatchFound = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">    auto ChainIter = MRU.begin();</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">    auto ChainIter = MRU.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">    for (size_t J = 0; J < MaxChainsToTry && ChainIter != MRU.end();</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">    for (size_t J = 0; J < MaxChainsToTry && ChainIter != MRU.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">         ++J, ++ChainIter) {</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">         ++J, ++ChainIter) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">      std::optional<APInt> Offset = getConstantOffset(</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">      std::optional<APInt> Offset = getConstantOffset(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">          getLoadStorePointerOperand(ChainIter->first),</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">          getLoadStorePointerOperand(ChainIter->first),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">          getLoadStorePointerOperand(I),</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">          getLoadStorePointerOperand(I),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">          /*ContextInst=*/</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">          /*ContextInst=*/</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">          (ChainIter->first->comesBefore(I) ? I : ChainIter->first));</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">          (ChainIter->first->comesBefore(I) ? I : ChainIter->first));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">      if (Offset.has_value()) {</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">      if (Offset.has_value()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">        // `Offset` might not have the expected number of bits, if e.g. AS has a</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">        // `Offset` might not have the expected number of bits, if e.g. AS has a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">        // different number of bits than opaque pointers.</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">        // different number of bits than opaque pointers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">        ChainIter->second.push_back(ChainElem{I, Offset.value()});</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">        ChainIter->second.push_back(ChainElem{I, Offset.value()});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">        // Move ChainIter to the front of the MRU list.</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">        // Move ChainIter to the front of the MRU list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">        MRU.remove(*ChainIter);</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">        MRU.remove(*ChainIter);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">        MRU.push_front(*ChainIter);</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">        MRU.push_front(*ChainIter);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">        MatchFound = true;</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">        MatchFound = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline"></td>
    <td class="lineNumber">1455</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">    if (!MatchFound) {</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">    if (!MatchFound) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">      APInt ZeroOffset(ASPtrBits, 0);</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">      APInt ZeroOffset(ASPtrBits, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">      InstrListElem *E = new (Allocator.Allocate()) InstrListElem(I);</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">      InstrListElem *E = new (Allocator.Allocate()) InstrListElem(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">      E->second.push_back(ChainElem{I, ZeroOffset});</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">      E->second.push_back(ChainElem{I, ZeroOffset});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">      MRU.push_front(*E);</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">      MRU.push_front(*E);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">      Chains.insert(E);</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">      Chains.insert(E);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline"></td>
    <td class="lineNumber">1464</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">  std::vector<Chain> Ret;</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">  std::vector<Chain> Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">  Ret.reserve(Chains.size());</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">  Ret.reserve(Chains.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">  // Iterate over MRU rather than Chains so the order is deterministic.</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">  // Iterate over MRU rather than Chains so the order is deterministic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  for (auto &E : MRU)</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  for (auto &E : MRU)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">    if (E.second.size() > 1)</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">    if (E.second.size() > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">      Ret.push_back(std::move(E.second));</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">      Ret.push_back(std::move(E.second));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">  return Ret;</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">  return Ret;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline"></td>
    <td class="lineNumber">1473</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">std::optional<APInt> Vectorizer::getConstantOffset(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">std::optional<APInt> Vectorizer::getConstantOffset(Value *PtrA, Value *PtrB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">                                                   Instruction *ContextInst,</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">                                                   Instruction *ContextInst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">                                                   unsigned Depth) {</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">                                                   unsigned Depth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffset, PtrA=" << *PtrA</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffset, PtrA=" << *PtrA</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">                    << ", PtrB=" << *PtrB << ", ContextInst= " << *ContextInst</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">                    << ", PtrB=" << *PtrB << ", ContextInst= " << *ContextInst</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">                    << ", Depth=" << Depth << "\n");</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">                    << ", Depth=" << Depth << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">  // We'll ultimately return a value of this bit width, even if computations</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">  // We'll ultimately return a value of this bit width, even if computations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">  // happen in a different width.</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">  // happen in a different width.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">  unsigned OrigBitWidth = DL.getIndexTypeSizeInBits(PtrA->getType());</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">  unsigned OrigBitWidth = DL.getIndexTypeSizeInBits(PtrA->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">  APInt OffsetA(OrigBitWidth, 0);</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">  APInt OffsetA(OrigBitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">  APInt OffsetB(OrigBitWidth, 0);</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">  APInt OffsetB(OrigBitWidth, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">  PtrA = PtrA->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetA);</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">  PtrA = PtrA->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">  PtrB = PtrB->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetB);</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">  PtrB = PtrB->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">  unsigned NewPtrBitWidth = DL.getTypeStoreSizeInBits(PtrA->getType());</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">  unsigned NewPtrBitWidth = DL.getTypeStoreSizeInBits(PtrA->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">  if (NewPtrBitWidth != DL.getTypeStoreSizeInBits(PtrB->getType()))</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">  if (NewPtrBitWidth != DL.getTypeStoreSizeInBits(PtrB->getType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline"></td>
    <td class="lineNumber">1490</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">  // If we have to shrink the pointer, stripAndAccumulateInBoundsConstantOffsets</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">  // If we have to shrink the pointer, stripAndAccumulateInBoundsConstantOffsets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">  // should properly handle a possible overflow and the value should fit into</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">  // should properly handle a possible overflow and the value should fit into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  // the smallest data type used in the cast/gep chain.</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  // the smallest data type used in the cast/gep chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">  assert(OffsetA.getSignificantBits() <= NewPtrBitWidth &&</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">  assert(OffsetA.getSignificantBits() <= NewPtrBitWidth &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">         OffsetB.getSignificantBits() <= NewPtrBitWidth);</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">         OffsetB.getSignificantBits() <= NewPtrBitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline"></td>
    <td class="lineNumber">1496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  OffsetA = OffsetA.sextOrTrunc(NewPtrBitWidth);</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  OffsetA = OffsetA.sextOrTrunc(NewPtrBitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">  OffsetB = OffsetB.sextOrTrunc(NewPtrBitWidth);</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">  OffsetB = OffsetB.sextOrTrunc(NewPtrBitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">  if (PtrA == PtrB)</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">  if (PtrA == PtrB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">    return (OffsetB - OffsetA).sextOrTrunc(OrigBitWidth);</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">    return (OffsetB - OffsetA).sextOrTrunc(OrigBitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline"></td>
    <td class="lineNumber">1501</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">  // Try to compute B - A.</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">  // Try to compute B - A.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">  const SCEV *DistScev = SE.getMinusSCEV(SE.getSCEV(PtrB), SE.getSCEV(PtrA));</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">  const SCEV *DistScev = SE.getMinusSCEV(SE.getSCEV(PtrB), SE.getSCEV(PtrA));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">  if (DistScev != SE.getCouldNotCompute()) {</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">  if (DistScev != SE.getCouldNotCompute()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "LSV: SCEV PtrB - PtrA =" << *DistScev << "\n");</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "LSV: SCEV PtrB - PtrA =" << *DistScev << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">    ConstantRange DistRange = SE.getSignedRange(DistScev);</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">    ConstantRange DistRange = SE.getSignedRange(DistScev);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">    if (DistRange.isSingleElement()) {</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">    if (DistRange.isSingleElement()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">      // Handle index width (the width of Dist) != pointer width (the width of</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">      // Handle index width (the width of Dist) != pointer width (the width of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">      // the Offset*s at this point).</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">      // the Offset*s at this point).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">      APInt Dist = DistRange.getSingleElement()->sextOrTrunc(NewPtrBitWidth);</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">      APInt Dist = DistRange.getSingleElement()->sextOrTrunc(NewPtrBitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">      return (OffsetB - OffsetA + Dist).sextOrTrunc(OrigBitWidth);</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">      return (OffsetB - OffsetA + Dist).sextOrTrunc(OrigBitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">  std::optional<APInt> Diff =</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">  std::optional<APInt> Diff =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">      getConstantOffsetComplexAddrs(PtrA, PtrB, ContextInst, Depth);</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">      getConstantOffsetComplexAddrs(PtrA, PtrB, ContextInst, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">  if (Diff.has_value())</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">  if (Diff.has_value())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">    return (OffsetB - OffsetA + Diff->sext(OffsetB.getBitWidth()))</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">    return (OffsetB - OffsetA + Diff->sext(OffsetB.getBitWidth()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">        .sextOrTrunc(OrigBitWidth);</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">        .sextOrTrunc(OrigBitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">  return std::nullopt;</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">  return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline"></td>
    <td class="lineNumber">1521</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This pass merges loads/stores to/from sequential memory addresses into vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This pass merges loads/stores to/from sequential memory addresses into vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// loads/stores.  Although there's nothing GPU-specific in here, this pass is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// loads/stores.  Although there's nothing GPU-specific in here, this pass is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">// motivated by the microarchitectural quirks of nVidia and AMD GPUs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">// motivated by the microarchitectural quirks of nVidia and AMD GPUs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">// (For simplicity below we talk about loads only, but everything also applies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">// (For simplicity below we talk about loads only, but everything also applies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">// to stores.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">// to stores.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">// This pass is intended to be run late in the pipeline, after other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">// This pass is intended to be run late in the pipeline, after other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">// vectorization opportunities have been exploited.  So the assumption here is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">// vectorization opportunities have been exploited.  So the assumption here is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">// that immediately following our new vector load we'll need to extract out the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">// that immediately following our new vector load we'll need to extract out the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">// individual elements of the load, so we can operate on them individually.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">// individual elements of the load, so we can operate on them individually.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">// On CPUs this transformation is usually not beneficial, because extracting the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">// On CPUs this transformation is usually not beneficial, because extracting the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">// elements of a vector register is expensive on most architectures.  It's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">// elements of a vector register is expensive on most architectures.  It's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">// usually better just to load each element individually into its own scalar</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">// usually better just to load each element individually into its own scalar</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">// register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">// register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">// However, nVidia and AMD GPUs don't have proper vector registers.  Instead, a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">// However, nVidia and AMD GPUs don't have proper vector registers.  Instead, a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">// "vector load" loads directly into a series of scalar registers.  In effect,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">// "vector load" loads directly into a series of scalar registers.  In effect,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">// extracting the elements of the vector is free.  It's therefore always</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">// extracting the elements of the vector is free.  It's therefore always</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">// beneficial to vectorize a sequence of loads on these architectures.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">// beneficial to vectorize a sequence of loads on these architectures.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">// Vectorizing (perhaps a better name might be "coalescing") loads can have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">// Vectorizing (perhaps a better name might be "coalescing") loads can have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">// large performance impacts on GPU kernels, and opportunities for vectorizing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">// large performance impacts on GPU kernels, and opportunities for vectorizing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">// are common in GPU code.  This pass tries very hard to find such</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">// are common in GPU code.  This pass tries very hard to find such</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">// opportunities; its runtime is quadratic in the number of loads in a BB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">// opportunities; its runtime is quadratic in the number of loads in a BB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">// Some CPU architectures, such as ARM, have instructions that load into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">// Some CPU architectures, such as ARM, have instructions that load into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">// multiple scalar registers, similar to a GPU vectorized load.  In theory ARM</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">// multiple scalar registers, similar to a GPU vectorized load.  In theory ARM</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">// could use this pass (with some modifications), but currently it implements</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">// could use this pass (with some modifications), but currently it implements</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">// its own pass to do something similar to what we do here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">// its own pass to do something similar to what we do here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">// Overview of the algorithm and terminology in this pass:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">// Overview of the algorithm and terminology in this pass:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">//  - Break up each basic block into pseudo-BBs, composed of instructions which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">//  - Break up each basic block into pseudo-BBs, composed of instructions which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">//    are guaranteed to transfer control to their successors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">//    are guaranteed to transfer control to their successors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">//  - Within a single pseudo-BB, find all loads, and group them into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">//  - Within a single pseudo-BB, find all loads, and group them into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">//    "equivalence classes" according to getUnderlyingObject() and loaded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">//    "equivalence classes" according to getUnderlyingObject() and loaded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">//    element size.  Do the same for stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">//    element size.  Do the same for stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">//  - For each equivalence class, greedily build "chains".  Each chain has a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">//  - For each equivalence class, greedily build "chains".  Each chain has a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">//    leader instruction, and every other member of the chain has a known</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">//    leader instruction, and every other member of the chain has a known</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">//    constant offset from the first instr in the chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">//    constant offset from the first instr in the chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">//  - Break up chains so that they contain only contiguous accesses of legal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">//  - Break up chains so that they contain only contiguous accesses of legal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">//    size with no intervening may-alias instrs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">//    size with no intervening may-alias instrs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">//  - Convert each chain to vector instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">//  - Convert each chain to vector instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">// The O(n^2) behavior of this pass comes from initially building the chains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">// The O(n^2) behavior of this pass comes from initially building the chains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">// In the worst case we have to compare each new instruction to all of those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">// In the worst case we have to compare each new instruction to all of those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">// that came before. To limit this, we only calculate the offset to the leaders</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">// that came before. To limit this, we only calculate the offset to the leaders</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">// of the N most recently-used chains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">// of the N most recently-used chains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">#include "llvm/Transforms/Vectorize/LoadStoreVectorizer.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">#include "llvm/Transforms/Vectorize/LoadStoreVectorizer.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">#include "llvm/ADT/MapVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">#include "llvm/ADT/MapVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">#include "llvm/ADT/Sequence.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">#include "llvm/ADT/Sequence.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">#include "llvm/Analysis/ScalarEvolution.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">#include "llvm/Analysis/VectorUtils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">#include "llvm/Analysis/VectorUtils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">#include "llvm/IR/ConstantRange.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">#include "llvm/IR/ConstantRange.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">#include "llvm/Support/Alignment.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">#include "llvm/Support/Alignment.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">#include "llvm/Support/KnownBits.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">#include "llvm/Support/ModRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">#include "llvm/Support/ModRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">#include "llvm/Transforms/Vectorize.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">#include "llvm/Transforms/Vectorize.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">#include <cstdlib></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">#include <cstdlib></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">#include <limits></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">#include <limits></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">#include <numeric></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">#include <numeric></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">#include <type_traits></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">#include <type_traits></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">#define DEBUG_TYPE "load-store-vectorizer"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">#define DEBUG_TYPE "load-store-vectorizer"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">STATISTIC(NumVectorInstructions, "Number of vector accesses generated");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">STATISTIC(NumVectorInstructions, "Number of vector accesses generated");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">STATISTIC(NumScalarsVectorized, "Number of scalar accesses vectorized");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">STATISTIC(NumScalarsVectorized, "Number of scalar accesses vectorized");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">// Equivalence class key, the initial tuple by which we group loads/stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">// Equivalence class key, the initial tuple by which we group loads/stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">// Loads/stores with different EqClassKeys are never merged.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">// Loads/stores with different EqClassKeys are never merged.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">// (We could in theory remove element-size from the this tuple.  We'd just need</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">// (We could in theory remove element-size from the this tuple.  We'd just need</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">// to fix up the vector packing/unpacking code.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">// to fix up the vector packing/unpacking code.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">using EqClassKey =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">using EqClassKey =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">    std::tuple<const Value * /* result of getUnderlyingObject() */,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">    std::tuple<const Value * /* result of getUnderlyingObject() */,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">               unsigned /* AddrSpace */,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">               unsigned /* AddrSpace */,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">               unsigned /* Load/Store element size bits */,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">               unsigned /* Load/Store element size bits */,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">               char /* IsLoad; char b/c bool can't be a DenseMap key */</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">               char /* IsLoad; char b/c bool can't be a DenseMap key */</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">               >;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">               >;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">[[maybe_unused]] llvm::raw_ostream &operator<<(llvm::raw_ostream &OS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">[[maybe_unused]] llvm::raw_ostream &operator<<(llvm::raw_ostream &OS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">                                               const EqClassKey &K) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">                                               const EqClassKey &K) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">  const auto &[UnderlyingObject, AddrSpace, ElementSize, IsLoad] = K;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">  const auto &[UnderlyingObject, AddrSpace, ElementSize, IsLoad] = K;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">  return OS << (IsLoad ? "load" : "store") << " of " << *UnderlyingObject</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">  return OS << (IsLoad ? "load" : "store") << " of " << *UnderlyingObject</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">            << " of element size " << ElementSize << " bits in addrspace "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">            << " of element size " << ElementSize << " bits in addrspace "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">            << AddrSpace;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">            << AddrSpace;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">// A Chain is a set of instructions such that:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">// A Chain is a set of instructions such that:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">//  - All instructions have the same equivalence class, so in particular all are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">//  - All instructions have the same equivalence class, so in particular all are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">//    loads, or all are stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">//    loads, or all are stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">//  - We know the address accessed by the i'th chain elem relative to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">//  - We know the address accessed by the i'th chain elem relative to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">//    chain's leader instruction, which is the first instr of the chain in BB</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">//    chain's leader instruction, which is the first instr of the chain in BB</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">//    order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">//    order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">// Chains have two canonical orderings:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">// Chains have two canonical orderings:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">//  - BB order, sorted by Instr->comesBefore.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">//  - BB order, sorted by Instr->comesBefore.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">//  - Offset order, sorted by OffsetFromLeader.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">//  - Offset order, sorted by OffsetFromLeader.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">// This pass switches back and forth between these orders.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">// This pass switches back and forth between these orders.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">struct ChainElem {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">struct ChainElem {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">  Instruction *Inst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">  Instruction *Inst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  APInt OffsetFromLeader;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  APInt OffsetFromLeader;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">using Chain = SmallVector<ChainElem, 1>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">using Chain = SmallVector<ChainElem, 1>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">void sortChainInBBOrder(Chain &C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">void sortChainInBBOrder(Chain &C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  sort(C, [](auto &A, auto &B) { return A.Inst->comesBefore(B.Inst); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  sort(C, [](auto &A, auto &B) { return A.Inst->comesBefore(B.Inst); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">void sortChainInOffsetOrder(Chain &C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">void sortChainInOffsetOrder(Chain &C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  sort(C, [](const auto &A, const auto &B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  sort(C, [](const auto &A, const auto &B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">    if (A.OffsetFromLeader != B.OffsetFromLeader)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">    if (A.OffsetFromLeader != B.OffsetFromLeader)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">      return A.OffsetFromLeader.slt(B.OffsetFromLeader);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">      return A.OffsetFromLeader.slt(B.OffsetFromLeader);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">    return A.Inst->comesBefore(B.Inst); // stable tiebreaker</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">    return A.Inst->comesBefore(B.Inst); // stable tiebreaker</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">[[maybe_unused]] void dumpChain(ArrayRef<ChainElem> C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">[[maybe_unused]] void dumpChain(ArrayRef<ChainElem> C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  for (const auto &E : C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  for (const auto &E : C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">    dbgs() << "  " << *E.Inst << " (offset " << E.OffsetFromLeader << ")\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">    dbgs() << "  " << *E.Inst << " (offset " << E.OffsetFromLeader << ")\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">using EquivalenceClassMap =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">using EquivalenceClassMap =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">    MapVector<EqClassKey, SmallVector<Instruction *, 8>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">    MapVector<EqClassKey, SmallVector<Instruction *, 8>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">// FIXME: Assuming stack alignment of 4 is always good enough</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">// FIXME: Assuming stack alignment of 4 is always good enough</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">constexpr unsigned StackAdjustedAlignment = 4;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">constexpr unsigned StackAdjustedAlignment = 4;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">Instruction *propagateMetadata(Instruction *I, const Chain &C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">Instruction *propagateMetadata(Instruction *I, const Chain &C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  SmallVector<Value *, 8> Values;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  SmallVector<Value *, 8> Values;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">    Values.push_back(E.Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">    Values.push_back(E.Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  return propagateMetadata(I, Values);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  return propagateMetadata(I, Values);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">bool isInvariantLoad(const Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">bool isInvariantLoad(const Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  const LoadInst *LI = dyn_cast<LoadInst>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  const LoadInst *LI = dyn_cast<LoadInst>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  return LI != nullptr && LI->hasMetadata(LLVMContext::MD_invariant_load);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  return LI != nullptr && LI->hasMetadata(LLVMContext::MD_invariant_load);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">/// Reorders the instructions that I depends on (the instructions defining its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">/// Reorders the instructions that I depends on (the instructions defining its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">/// operands), to ensure they dominate I.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">/// operands), to ensure they dominate I.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">void reorder(Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">void reorder(Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">  SmallPtrSet<Instruction *, 16> InstructionsToMove;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">  SmallPtrSet<Instruction *, 16> InstructionsToMove;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  SmallVector<Instruction *, 16> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  SmallVector<Instruction *, 16> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  Worklist.push_back(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  Worklist.push_back(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    Instruction *IW = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    Instruction *IW = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">    int NumOperands = IW->getNumOperands();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">    int NumOperands = IW->getNumOperands();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">    for (int i = 0; i < NumOperands; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">    for (int i = 0; i < NumOperands; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">      Instruction *IM = dyn_cast<Instruction>(IW->getOperand(i));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">      Instruction *IM = dyn_cast<Instruction>(IW->getOperand(i));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">      if (!IM || IM->getOpcode() == Instruction::PHI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">      if (!IM || IM->getOpcode() == Instruction::PHI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">      // If IM is in another BB, no need to move it, because this pass only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">      // If IM is in another BB, no need to move it, because this pass only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">      // vectorizes instructions within one BB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">      // vectorizes instructions within one BB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">      if (IM->getParent() != I->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">      if (IM->getParent() != I->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">      if (!IM->comesBefore(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">      if (!IM->comesBefore(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">        InstructionsToMove.insert(IM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">        InstructionsToMove.insert(IM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">        Worklist.push_back(IM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">        Worklist.push_back(IM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">  // All instructions to move should follow I. Start from I, not from begin().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">  // All instructions to move should follow I. Start from I, not from begin().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  for (auto BBI = I->getIterator(), E = I->getParent()->end(); BBI != E;) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  for (auto BBI = I->getIterator(), E = I->getParent()->end(); BBI != E;) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">    Instruction *IM = &*(BBI++);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">    Instruction *IM = &*(BBI++);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">    if (!InstructionsToMove.count(IM))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">    if (!InstructionsToMove.count(IM))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">    IM->moveBefore(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">    IM->moveBefore(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">class Vectorizer {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">class Vectorizer {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  Function &F;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  Function &F;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  AliasAnalysis &AA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  AliasAnalysis &AA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  AssumptionCache &AC;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  AssumptionCache &AC;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  DominatorTree &DT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  DominatorTree &DT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  ScalarEvolution &SE;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  ScalarEvolution &SE;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  TargetTransformInfo &TTI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  TargetTransformInfo &TTI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">  IRBuilder<> Builder;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">  IRBuilder<> Builder;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  // We could erase instrs right after vectorizing them, but that can mess up</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  // We could erase instrs right after vectorizing them, but that can mess up</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">  // our BB iterators, and also can make the equivalence class keys point to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">  // our BB iterators, and also can make the equivalence class keys point to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  // freed memory.  This is fixable, but it's simpler just to wait until we're</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  // freed memory.  This is fixable, but it's simpler just to wait until we're</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  // done with the BB and erase all at once.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  // done with the BB and erase all at once.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  SmallVector<Instruction *, 128> ToErase;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  SmallVector<Instruction *, 128> ToErase;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  Vectorizer(Function &F, AliasAnalysis &AA, AssumptionCache &AC,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  Vectorizer(Function &F, AliasAnalysis &AA, AssumptionCache &AC,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">             DominatorTree &DT, ScalarEvolution &SE, TargetTransformInfo &TTI)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">             DominatorTree &DT, ScalarEvolution &SE, TargetTransformInfo &TTI)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">      : F(F), AA(AA), AC(AC), DT(DT), SE(SE), TTI(TTI),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">      : F(F), AA(AA), AC(AC), DT(DT), SE(SE), TTI(TTI),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">        DL(F.getParent()->getDataLayout()), Builder(SE.getContext()) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">        DL(F.getParent()->getDataLayout()), Builder(SE.getContext()) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">  bool run();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  bool run();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  static const unsigned MaxDepth = 3;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  static const unsigned MaxDepth = 3;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  /// Runs the vectorizer on a "pseudo basic block", which is a range of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  /// Runs the vectorizer on a "pseudo basic block", which is a range of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  /// instructions [Begin, End) within one BB all of which have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  /// instructions [Begin, End) within one BB all of which have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  /// isGuaranteedToTransferExecutionToSuccessor(I) == true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  /// isGuaranteedToTransferExecutionToSuccessor(I) == true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  bool runOnPseudoBB(BasicBlock::iterator Begin, BasicBlock::iterator End);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  bool runOnPseudoBB(BasicBlock::iterator Begin, BasicBlock::iterator End);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  /// Runs the vectorizer on one equivalence class, i.e. one set of loads/stores</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  /// Runs the vectorizer on one equivalence class, i.e. one set of loads/stores</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  /// in the same BB with the same value for getUnderlyingObject() etc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  /// in the same BB with the same value for getUnderlyingObject() etc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  bool runOnEquivalenceClass(const EqClassKey &EqClassKey,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  bool runOnEquivalenceClass(const EqClassKey &EqClassKey,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">                             ArrayRef<Instruction *> EqClass);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">                             ArrayRef<Instruction *> EqClass);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  /// Runs the vectorizer on one chain, i.e. a subset of an equivalence class</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  /// Runs the vectorizer on one chain, i.e. a subset of an equivalence class</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  /// where all instructions access a known, constant offset from the first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  /// where all instructions access a known, constant offset from the first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  /// instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  /// instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">  bool runOnChain(Chain &C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">  bool runOnChain(Chain &C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">  /// Splits the chain into subchains of instructions which read/write a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">  /// Splits the chain into subchains of instructions which read/write a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  /// contiguous block of memory.  Discards any length-1 subchains (because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  /// contiguous block of memory.  Discards any length-1 subchains (because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">  /// there's nothing to vectorize in there).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">  /// there's nothing to vectorize in there).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">  std::vector<Chain> splitChainByContiguity(Chain &C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">  std::vector<Chain> splitChainByContiguity(Chain &C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  /// Splits the chain into subchains where it's safe to hoist loads up to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  /// Splits the chain into subchains where it's safe to hoist loads up to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  /// beginning of the sub-chain and it's safe to sink loads up to the end of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  /// beginning of the sub-chain and it's safe to sink loads up to the end of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  /// the sub-chain.  Discards any length-1 subchains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  /// the sub-chain.  Discards any length-1 subchains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  std::vector<Chain> splitChainByMayAliasInstrs(Chain &C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  std::vector<Chain> splitChainByMayAliasInstrs(Chain &C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  /// Splits the chain into subchains that make legal, aligned accesses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  /// Splits the chain into subchains that make legal, aligned accesses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  /// Discards any length-1 subchains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  /// Discards any length-1 subchains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  std::vector<Chain> splitChainByAlignment(Chain &C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  std::vector<Chain> splitChainByAlignment(Chain &C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  /// Converts the instrs in the chain into a single vectorized load or store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  /// Converts the instrs in the chain into a single vectorized load or store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  /// Adds the old scalar loads/stores to ToErase.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  /// Adds the old scalar loads/stores to ToErase.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  bool vectorizeChain(Chain &C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  bool vectorizeChain(Chain &C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">  /// Tries to compute the offset in bytes PtrB - PtrA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">  /// Tries to compute the offset in bytes PtrB - PtrA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  std::optional<APInt> getConstantOffset(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  std::optional<APInt> getConstantOffset(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">                                         Instruction *ContextInst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">                                         Instruction *ContextInst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">                                         unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">                                         unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  std::optional<APInt> getConstantOffsetComplexAddrs(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  std::optional<APInt> getConstantOffsetComplexAddrs(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">                                                     Instruction *ContextInst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">                                                     Instruction *ContextInst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">                                                     unsigned Depth);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">                                                     unsigned Depth);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">  std::optional<APInt> getConstantOffsetSelects(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">  std::optional<APInt> getConstantOffsetSelects(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">                                                Instruction *ContextInst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">                                                Instruction *ContextInst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">                                                unsigned Depth);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">                                                unsigned Depth);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">  /// Gets the element type of the vector that the chain will load or store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">  /// Gets the element type of the vector that the chain will load or store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  /// This is nontrivial because the chain may contain elements of different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  /// This is nontrivial because the chain may contain elements of different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">  /// types; e.g. it's legal to have a chain that contains both i32 and float.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">  /// types; e.g. it's legal to have a chain that contains both i32 and float.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">  Type *getChainElemTy(const Chain &C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">  Type *getChainElemTy(const Chain &C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">  /// Determines whether ChainElem can be moved up (if IsLoad) or down (if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">  /// Determines whether ChainElem can be moved up (if IsLoad) or down (if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">  /// !IsLoad) to ChainBegin -- i.e. there are no intervening may-alias</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">  /// !IsLoad) to ChainBegin -- i.e. there are no intervening may-alias</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">  /// instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">  /// instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">  /// The map ChainElemOffsets must contain all of the elements in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">  /// The map ChainElemOffsets must contain all of the elements in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">  /// [ChainBegin, ChainElem] and their offsets from some arbitrary base</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">  /// [ChainBegin, ChainElem] and their offsets from some arbitrary base</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">  /// address.  It's ok if it contains additional entries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">  /// address.  It's ok if it contains additional entries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">  template <bool IsLoadChain></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">  template <bool IsLoadChain></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">  bool isSafeToMove(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">  bool isSafeToMove(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">      Instruction *ChainElem, Instruction *ChainBegin,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">      Instruction *ChainElem, Instruction *ChainBegin,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">      const DenseMap<Instruction *, APInt /*OffsetFromLeader*/> &ChainOffsets);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">      const DenseMap<Instruction *, APInt /*OffsetFromLeader*/> &ChainOffsets);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">  /// Collects loads and stores grouped by "equivalence class", where:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">  /// Collects loads and stores grouped by "equivalence class", where:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">  ///   - all elements in an eq class are a load or all are a store,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">  ///   - all elements in an eq class are a load or all are a store,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">  ///   - they all load/store the same element size (it's OK to have e.g. i8 and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">  ///   - they all load/store the same element size (it's OK to have e.g. i8 and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">  ///     <4 x i8> in the same class, but not i32 and <4 x i8>), and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">  ///     <4 x i8> in the same class, but not i32 and <4 x i8>), and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">  ///   - they all have the same value for getUnderlyingObject().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">  ///   - they all have the same value for getUnderlyingObject().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  EquivalenceClassMap collectEquivalenceClasses(BasicBlock::iterator Begin,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  EquivalenceClassMap collectEquivalenceClasses(BasicBlock::iterator Begin,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">                                                BasicBlock::iterator End);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">                                                BasicBlock::iterator End);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">  /// Partitions Instrs into "chains" where every instruction has a known</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">  /// Partitions Instrs into "chains" where every instruction has a known</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">  /// constant offset from the first instr in the chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">  /// constant offset from the first instr in the chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">  /// Postcondition: For all i, ret[i][0].second == 0, because the first instr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">  /// Postcondition: For all i, ret[i][0].second == 0, because the first instr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  /// in the chain is the leader, and an instr touches distance 0 from itself.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  /// in the chain is the leader, and an instr touches distance 0 from itself.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">  std::vector<Chain> gatherChains(ArrayRef<Instruction *> Instrs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">  std::vector<Chain> gatherChains(ArrayRef<Instruction *> Instrs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">class LoadStoreVectorizerLegacyPass : public FunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">class LoadStoreVectorizerLegacyPass : public FunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  LoadStoreVectorizerLegacyPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  LoadStoreVectorizerLegacyPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">    initializeLoadStoreVectorizerLegacyPassPass(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">    initializeLoadStoreVectorizerLegacyPassPass(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">        *PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">        *PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">  StringRef getPassName() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">  StringRef getPassName() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">    return "GPU Load and Store Vectorizer";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">    return "GPU Load and Store Vectorizer";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">    AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">    AU.addRequired<ScalarEvolutionWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">    AU.setPreservesCFG();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">    AU.setPreservesCFG();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">char LoadStoreVectorizerLegacyPass::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">char LoadStoreVectorizerLegacyPass::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(LoadStoreVectorizerLegacyPass, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">370</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(LoadStoreVectorizerLegacyPass, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">                      "Vectorize load and Store instructions", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">                      "Vectorize load and Store instructions", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(SCEVAAWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">372</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(SCEVAAWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">373</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">374</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">375</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(GlobalsAAWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">376</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(GlobalsAAWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">377</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(LoadStoreVectorizerLegacyPass, DEBUG_TYPE,</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">378</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(LoadStoreVectorizerLegacyPass, DEBUG_TYPE,</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">                    "Vectorize load and store instructions", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">                    "Vectorize load and store instructions", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">Pass *llvm::createLoadStoreVectorizerPass() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">Pass *llvm::createLoadStoreVectorizerPass() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">  return new LoadStoreVectorizerLegacyPass();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">  return new LoadStoreVectorizerLegacyPass();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">bool LoadStoreVectorizerLegacyPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">bool LoadStoreVectorizerLegacyPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">  // Don't vectorize when the attribute NoImplicitFloat is used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">  // Don't vectorize when the attribute NoImplicitFloat is used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">  if (skipFunction(F) || F.hasFnAttribute(Attribute::NoImplicitFloat))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">  if (skipFunction(F) || F.hasFnAttribute(Attribute::NoImplicitFloat))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  AliasAnalysis &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  AliasAnalysis &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">  DominatorTree &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">  DominatorTree &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">  ScalarEvolution &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">  ScalarEvolution &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  TargetTransformInfo &TTI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  TargetTransformInfo &TTI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">      getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">      getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  AssumptionCache &AC =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  AssumptionCache &AC =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">      getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">      getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">  return Vectorizer(F, AA, AC, DT, SE, TTI).run();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">  return Vectorizer(F, AA, AC, DT, SE, TTI).run();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">PreservedAnalyses LoadStoreVectorizerPass::run(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">PreservedAnalyses LoadStoreVectorizerPass::run(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">                                               FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">                                               FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  // Don't vectorize when the attribute NoImplicitFloat is used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  // Don't vectorize when the attribute NoImplicitFloat is used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  if (F.hasFnAttribute(Attribute::NoImplicitFloat))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  if (F.hasFnAttribute(Attribute::NoImplicitFloat))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">  AliasAnalysis &AA = AM.getResult<AAManager>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">  AliasAnalysis &AA = AM.getResult<AAManager>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">  ScalarEvolution &SE = AM.getResult<ScalarEvolutionAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">  ScalarEvolution &SE = AM.getResult<ScalarEvolutionAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  TargetTransformInfo &TTI = AM.getResult<TargetIRAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  TargetTransformInfo &TTI = AM.getResult<TargetIRAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  AssumptionCache &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  AssumptionCache &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">  bool Changed = Vectorizer(F, AA, AC, DT, SE, TTI).run();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">  bool Changed = Vectorizer(F, AA, AC, DT, SE, TTI).run();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  PreservedAnalyses PA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  PreservedAnalyses PA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">  PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">  PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">  return Changed ? PA : PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">  return Changed ? PA : PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">bool Vectorizer::run() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">bool Vectorizer::run() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  // Break up the BB if there are any instrs which aren't guaranteed to transfer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  // Break up the BB if there are any instrs which aren't guaranteed to transfer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  // execution to their successor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  // execution to their successor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  // Consider, for example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  // Consider, for example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  //   def assert_arr_len(int n) { if (n < 2) exit(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  //   def assert_arr_len(int n) { if (n < 2) exit(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  //   load arr[0]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  //   load arr[0]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  //   call assert_array_len(arr.length)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  //   call assert_array_len(arr.length)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  //   load arr[1]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  //   load arr[1]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">  // Even though assert_arr_len does not read or write any memory, we can't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">  // Even though assert_arr_len does not read or write any memory, we can't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">  // speculate the second load before the call.  More info at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">  // speculate the second load before the call.  More info at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  // https://github.com/llvm/llvm-project/issues/52950.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  // https://github.com/llvm/llvm-project/issues/52950.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  for (BasicBlock *BB : post_order(&F)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  for (BasicBlock *BB : post_order(&F)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">    // BB must at least have a terminator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">    // BB must at least have a terminator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">    assert(!BB->empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">    assert(!BB->empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">    SmallVector<BasicBlock::iterator, 8> Barriers;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">    SmallVector<BasicBlock::iterator, 8> Barriers;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">    Barriers.push_back(BB->begin());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">    Barriers.push_back(BB->begin());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">    for (Instruction &I : *BB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">    for (Instruction &I : *BB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">      if (!isGuaranteedToTransferExecutionToSuccessor(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">      if (!isGuaranteedToTransferExecutionToSuccessor(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">        Barriers.push_back(I.getIterator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">        Barriers.push_back(I.getIterator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">    Barriers.push_back(BB->end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">    Barriers.push_back(BB->end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">    for (auto It = Barriers.begin(), End = std::prev(Barriers.end()); It != End;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">    for (auto It = Barriers.begin(), End = std::prev(Barriers.end()); It != End;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">         ++It)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">         ++It)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">      Changed |= runOnPseudoBB(*It, *std::next(It));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">      Changed |= runOnPseudoBB(*It, *std::next(It));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">    for (Instruction *I : ToErase) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">    for (Instruction *I : ToErase) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">      auto *PtrOperand = getLoadStorePointerOperand(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">      auto *PtrOperand = getLoadStorePointerOperand(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">      if (I->use_empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">      if (I->use_empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">        I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">        I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">      RecursivelyDeleteTriviallyDeadInstructions(PtrOperand);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">      RecursivelyDeleteTriviallyDeadInstructions(PtrOperand);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">    ToErase.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">    ToErase.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">bool Vectorizer::runOnPseudoBB(BasicBlock::iterator Begin,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">bool Vectorizer::runOnPseudoBB(BasicBlock::iterator Begin,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">                               BasicBlock::iterator End) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">                               BasicBlock::iterator End) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">    dbgs() << "LSV: Running on pseudo-BB [" << *Begin << " ... ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">    dbgs() << "LSV: Running on pseudo-BB [" << *Begin << " ... ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">    if (End != Begin->getParent()->end())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">    if (End != Begin->getParent()->end())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">      dbgs() << *End;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">      dbgs() << *End;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">      dbgs() << "<BB end>";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">      dbgs() << "<BB end>";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">    dbgs() << ")\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">    dbgs() << ")\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  for (const auto &[EqClassKey, EqClass] :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  for (const auto &[EqClassKey, EqClass] :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">       collectEquivalenceClasses(Begin, End))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">       collectEquivalenceClasses(Begin, End))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">    Changed |= runOnEquivalenceClass(EqClassKey, EqClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">    Changed |= runOnEquivalenceClass(EqClassKey, EqClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">bool Vectorizer::runOnEquivalenceClass(const EqClassKey &EqClassKey,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">bool Vectorizer::runOnEquivalenceClass(const EqClassKey &EqClassKey,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">                                       ArrayRef<Instruction *> EqClass) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">                                       ArrayRef<Instruction *> EqClass) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">    dbgs() << "LSV: Running on equivalence class of size " << EqClass.size()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">    dbgs() << "LSV: Running on equivalence class of size " << EqClass.size()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">           << " keyed on " << EqClassKey << ":\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">           << " keyed on " << EqClassKey << ":\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">    for (Instruction *I : EqClass)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">    for (Instruction *I : EqClass)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">      dbgs() << "  " << *I << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">      dbgs() << "  " << *I << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  std::vector<Chain> Chains = gatherChains(EqClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  std::vector<Chain> Chains = gatherChains(EqClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: Got " << Chains.size()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: Got " << Chains.size()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">                    << " nontrivial chains.\n";);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">                    << " nontrivial chains.\n";);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  for (Chain &C : Chains)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  for (Chain &C : Chains)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">    Changed |= runOnChain(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">    Changed |= runOnChain(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">bool Vectorizer::runOnChain(Chain &C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">bool Vectorizer::runOnChain(Chain &C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">    dbgs() << "LSV: Running on chain with " << C.size() << " instructions:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">    dbgs() << "LSV: Running on chain with " << C.size() << " instructions:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">    dumpChain(C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">    dumpChain(C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">  // Split up the chain into increasingly smaller chains, until we can finally</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">  // Split up the chain into increasingly smaller chains, until we can finally</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  // vectorize the chains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  // vectorize the chains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  // (Don't be scared by the depth of the loop nest here.  These operations are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  // (Don't be scared by the depth of the loop nest here.  These operations are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  // all at worst O(n lg n) in the number of instructions, and splitting chains</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  // all at worst O(n lg n) in the number of instructions, and splitting chains</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  // doesn't change the number of instrs.  So the whole loop nest is O(n lg n).)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  // doesn't change the number of instrs.  So the whole loop nest is O(n lg n).)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  for (auto &C : splitChainByMayAliasInstrs(C))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  for (auto &C : splitChainByMayAliasInstrs(C))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">    for (auto &C : splitChainByContiguity(C))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">    for (auto &C : splitChainByContiguity(C))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">      for (auto &C : splitChainByAlignment(C))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">      for (auto &C : splitChainByAlignment(C))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">        Changed |= vectorizeChain(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">        Changed |= vectorizeChain(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">std::vector<Chain> Vectorizer::splitChainByMayAliasInstrs(Chain &C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">std::vector<Chain> Vectorizer::splitChainByMayAliasInstrs(Chain &C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  if (C.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  if (C.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  sortChainInBBOrder(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  sortChainInBBOrder(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">    dbgs() << "LSV: splitChainByMayAliasInstrs considering chain:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">    dbgs() << "LSV: splitChainByMayAliasInstrs considering chain:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">    dumpChain(C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">    dumpChain(C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">  // We know that elements in the chain with nonverlapping offsets can't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">  // We know that elements in the chain with nonverlapping offsets can't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">  // alias, but AA may not be smart enough to figure this out.  Use a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">  // alias, but AA may not be smart enough to figure this out.  Use a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">  // hashtable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">  // hashtable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">  DenseMap<Instruction *, APInt /*OffsetFromLeader*/> ChainOffsets;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">  DenseMap<Instruction *, APInt /*OffsetFromLeader*/> ChainOffsets;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  for (const auto &E : C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  for (const auto &E : C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">    ChainOffsets.insert({&*E.Inst, E.OffsetFromLeader});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">    ChainOffsets.insert({&*E.Inst, E.OffsetFromLeader});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  // Loads get hoisted up to the first load in the chain.  Stores get sunk</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  // Loads get hoisted up to the first load in the chain.  Stores get sunk</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">  // down to the last store in the chain.  Our algorithm for loads is:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">  // down to the last store in the chain.  Our algorithm for loads is:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">  //  - Take the first element of the chain.  This is the start of a new chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">  //  - Take the first element of the chain.  This is the start of a new chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">  //  - Take the next element of `Chain` and check for may-alias instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">  //  - Take the next element of `Chain` and check for may-alias instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">  //    up to the start of NewChain.  If no may-alias instrs, add it to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">  //    up to the start of NewChain.  If no may-alias instrs, add it to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">  //    NewChain.  Otherwise, start a new NewChain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">  //    NewChain.  Otherwise, start a new NewChain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  // For stores it's the same except in the reverse direction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  // For stores it's the same except in the reverse direction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">  // We expect IsLoad to be an std::bool_constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">  // We expect IsLoad to be an std::bool_constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  auto Impl = [&](auto IsLoad) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  auto Impl = [&](auto IsLoad) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">    // MSVC is unhappy if IsLoad is a capture, so pass it as an arg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">    // MSVC is unhappy if IsLoad is a capture, so pass it as an arg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">    auto [ChainBegin, ChainEnd] = [&](auto IsLoad) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">    auto [ChainBegin, ChainEnd] = [&](auto IsLoad) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">      if constexpr (IsLoad())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">      if constexpr (IsLoad())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">        return std::make_pair(C.begin(), C.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">        return std::make_pair(C.begin(), C.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">        return std::make_pair(C.rbegin(), C.rend());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">        return std::make_pair(C.rbegin(), C.rend());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">    }(IsLoad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">    }(IsLoad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">    assert(ChainBegin != ChainEnd);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">    assert(ChainBegin != ChainEnd);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">    std::vector<Chain> Chains;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">    std::vector<Chain> Chains;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">    SmallVector<ChainElem, 1> NewChain;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">    SmallVector<ChainElem, 1> NewChain;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">    NewChain.push_back(*ChainBegin);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">    NewChain.push_back(*ChainBegin);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">    for (auto ChainIt = std::next(ChainBegin); ChainIt != ChainEnd; ++ChainIt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">    for (auto ChainIt = std::next(ChainBegin); ChainIt != ChainEnd; ++ChainIt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">      if (isSafeToMove<IsLoad>(ChainIt->Inst, NewChain.front().Inst,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">      if (isSafeToMove<IsLoad>(ChainIt->Inst, NewChain.front().Inst,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">                               ChainOffsets)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">                               ChainOffsets)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "LSV: No intervening may-alias instrs; can merge "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "LSV: No intervening may-alias instrs; can merge "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">                          << *ChainIt->Inst << " into " << *ChainBegin->Inst</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">                          << *ChainIt->Inst << " into " << *ChainBegin->Inst</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">                          << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">                          << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">        NewChain.push_back(*ChainIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">        NewChain.push_back(*ChainIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">            dbgs() << "LSV: Found intervening may-alias instrs; cannot merge "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">            dbgs() << "LSV: Found intervening may-alias instrs; cannot merge "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">                   << *ChainIt->Inst << " into " << *ChainBegin->Inst << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">                   << *ChainIt->Inst << " into " << *ChainBegin->Inst << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">        if (NewChain.size() > 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">        if (NewChain.size() > 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">          LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">          LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">            dbgs() << "LSV: got nontrivial chain without aliasing instrs:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">            dbgs() << "LSV: got nontrivial chain without aliasing instrs:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">            dumpChain(NewChain);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">            dumpChain(NewChain);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">          });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">          });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">          Chains.push_back(std::move(NewChain));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">          Chains.push_back(std::move(NewChain));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">        // Start a new chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">        // Start a new chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">        NewChain = SmallVector<ChainElem, 1>({*ChainIt});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">        NewChain = SmallVector<ChainElem, 1>({*ChainIt});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">    if (NewChain.size() > 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">    if (NewChain.size() > 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">        dbgs() << "LSV: got nontrivial chain without aliasing instrs:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">        dbgs() << "LSV: got nontrivial chain without aliasing instrs:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">        dumpChain(NewChain);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">        dumpChain(NewChain);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">      Chains.push_back(std::move(NewChain));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">      Chains.push_back(std::move(NewChain));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    return Chains;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    return Chains;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  if (isa<LoadInst>(C[0].Inst))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  if (isa<LoadInst>(C[0].Inst))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">    return Impl(/*IsLoad=*/std::bool_constant<true>());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">    return Impl(/*IsLoad=*/std::bool_constant<true>());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  assert(isa<StoreInst>(C[0].Inst));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  assert(isa<StoreInst>(C[0].Inst));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  return Impl(/*IsLoad=*/std::bool_constant<false>());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  return Impl(/*IsLoad=*/std::bool_constant<false>());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">std::vector<Chain> Vectorizer::splitChainByContiguity(Chain &C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">std::vector<Chain> Vectorizer::splitChainByContiguity(Chain &C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  if (C.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  if (C.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">  sortChainInOffsetOrder(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">  sortChainInOffsetOrder(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">    dbgs() << "LSV: splitChainByContiguity considering chain:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">    dbgs() << "LSV: splitChainByContiguity considering chain:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">    dumpChain(C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">    dumpChain(C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">  std::vector<Chain> Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">  std::vector<Chain> Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  Ret.push_back({C.front()});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  Ret.push_back({C.front()});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  for (auto It = std::next(C.begin()), End = C.end(); It != End; ++It) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  for (auto It = std::next(C.begin()), End = C.end(); It != End; ++It) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">    // `prev` accesses offsets [PrevDistFromBase, PrevReadEnd).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">    // `prev` accesses offsets [PrevDistFromBase, PrevReadEnd).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">    auto &CurChain = Ret.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">    auto &CurChain = Ret.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">    const ChainElem &Prev = CurChain.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">    const ChainElem &Prev = CurChain.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">    unsigned SzBits = DL.getTypeSizeInBits(getLoadStoreType(&*Prev.Inst));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">    unsigned SzBits = DL.getTypeSizeInBits(getLoadStoreType(&*Prev.Inst));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">    assert(SzBits % 8 == 0 && "Non-byte sizes should have been filtered out by "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">    assert(SzBits % 8 == 0 && "Non-byte sizes should have been filtered out by "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">                              "collectEquivalenceClass");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">                              "collectEquivalenceClass");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">    APInt PrevReadEnd = Prev.OffsetFromLeader + SzBits / 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">    APInt PrevReadEnd = Prev.OffsetFromLeader + SzBits / 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">    // Add this instruction to the end of the current chain, or start a new one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">    // Add this instruction to the end of the current chain, or start a new one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">    bool AreContiguous = It->OffsetFromLeader == PrevReadEnd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">    bool AreContiguous = It->OffsetFromLeader == PrevReadEnd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "LSV: Instructions are "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "LSV: Instructions are "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">                      << (AreContiguous ? "" : "not ") << "contiguous: "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">                      << (AreContiguous ? "" : "not ") << "contiguous: "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">                      << *Prev.Inst << " (ends at offset " << PrevReadEnd</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">                      << *Prev.Inst << " (ends at offset " << PrevReadEnd</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">                      << ") -> " << *It->Inst << " (starts at offset "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">                      << ") -> " << *It->Inst << " (starts at offset "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">                      << It->OffsetFromLeader << ")\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">                      << It->OffsetFromLeader << ")\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">    if (AreContiguous)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">    if (AreContiguous)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">      CurChain.push_back(*It);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">      CurChain.push_back(*It);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">      Ret.push_back({*It});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">      Ret.push_back({*It});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">  // Filter out length-1 chains, these are uninteresting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">  // Filter out length-1 chains, these are uninteresting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">  llvm::erase_if(Ret, [](const auto &Chain) { return Chain.size() <= 1; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">  llvm::erase_if(Ret, [](const auto &Chain) { return Chain.size() <= 1; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">Type *Vectorizer::getChainElemTy(const Chain &C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">Type *Vectorizer::getChainElemTy(const Chain &C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  assert(!C.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  assert(!C.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">  // The rules are:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">  // The rules are:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  //  - If there are any pointer types in the chain, use an integer type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  //  - If there are any pointer types in the chain, use an integer type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">  //  - Prefer an integer type if it appears in the chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">  //  - Prefer an integer type if it appears in the chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  //  - Otherwise, use the first type in the chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  //  - Otherwise, use the first type in the chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  // The rule about pointer types is a simplification when we merge e.g.  a load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  // The rule about pointer types is a simplification when we merge e.g.  a load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">  // of a ptr and a double.  There's no direct conversion from a ptr to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">  // of a ptr and a double.  There's no direct conversion from a ptr to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">  // double; it requires a ptrtoint followed by a bitcast.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">  // double; it requires a ptrtoint followed by a bitcast.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  // It's unclear to me if the other rules have any practical effect, but we do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  // It's unclear to me if the other rules have any practical effect, but we do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  // it to match this pass's previous behavior.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  // it to match this pass's previous behavior.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">  if (any_of(C, [](const ChainElem &E) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">  if (any_of(C, [](const ChainElem &E) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">        return getLoadStoreType(E.Inst)->getScalarType()->isPointerTy();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">        return getLoadStoreType(E.Inst)->getScalarType()->isPointerTy();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">      })) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">      })) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">    return Type::getIntNTy(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">    return Type::getIntNTy(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">        F.getContext(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">        F.getContext(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">        DL.getTypeSizeInBits(getLoadStoreType(C[0].Inst)->getScalarType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">        DL.getTypeSizeInBits(getLoadStoreType(C[0].Inst)->getScalarType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">    if (Type *T = getLoadStoreType(E.Inst)->getScalarType(); T->isIntegerTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">    if (Type *T = getLoadStoreType(E.Inst)->getScalarType(); T->isIntegerTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">      return T;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">      return T;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  return getLoadStoreType(C[0].Inst)->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  return getLoadStoreType(C[0].Inst)->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">std::vector<Chain> Vectorizer::splitChainByAlignment(Chain &C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">std::vector<Chain> Vectorizer::splitChainByAlignment(Chain &C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">  // We use a simple greedy algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">  // We use a simple greedy algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  //  - Given a chain of length N, find all prefixes that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  //  - Given a chain of length N, find all prefixes that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  //    (a) are not longer than the max register length, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  //    (a) are not longer than the max register length, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">  //    (b) are a power of 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">  //    (b) are a power of 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">  //  - Starting from the longest prefix, try to create a vector of that length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">  //  - Starting from the longest prefix, try to create a vector of that length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">  //  - If one of them works, great.  Repeat the algorithm on any remaining</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">  //  - If one of them works, great.  Repeat the algorithm on any remaining</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">  //    elements in the chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">  //    elements in the chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  //  - If none of them work, discard the first element and repeat on a chain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  //  - If none of them work, discard the first element and repeat on a chain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  //    of length N-1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  //    of length N-1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  if (C.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  if (C.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  sortChainInOffsetOrder(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  sortChainInOffsetOrder(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">    dbgs() << "LSV: splitChainByAlignment considering chain:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">    dbgs() << "LSV: splitChainByAlignment considering chain:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">    dumpChain(C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">    dumpChain(C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">  bool IsLoadChain = isa<LoadInst>(C[0].Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">  bool IsLoadChain = isa<LoadInst>(C[0].Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  auto getVectorFactor = [&](unsigned VF, unsigned LoadStoreSize,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  auto getVectorFactor = [&](unsigned VF, unsigned LoadStoreSize,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">                             unsigned ChainSizeBytes, VectorType *VecTy) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">                             unsigned ChainSizeBytes, VectorType *VecTy) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">    return IsLoadChain ? TTI.getLoadVectorFactor(VF, LoadStoreSize,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">    return IsLoadChain ? TTI.getLoadVectorFactor(VF, LoadStoreSize,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">                                                 ChainSizeBytes, VecTy)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">                                                 ChainSizeBytes, VecTy)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">                       : TTI.getStoreVectorFactor(VF, LoadStoreSize,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">                       : TTI.getStoreVectorFactor(VF, LoadStoreSize,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">                                                  ChainSizeBytes, VecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">                                                  ChainSizeBytes, VecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">  for (const auto &E : C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">  for (const auto &E : C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">    Type *Ty = getLoadStoreType(E.Inst)->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">    Type *Ty = getLoadStoreType(E.Inst)->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">    assert(isPowerOf2_32(DL.getTypeSizeInBits(Ty)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">    assert(isPowerOf2_32(DL.getTypeSizeInBits(Ty)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">           "Should have filtered out non-power-of-two elements in "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">           "Should have filtered out non-power-of-two elements in "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">           "collectEquivalenceClasses.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">           "collectEquivalenceClasses.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  unsigned AS = getLoadStoreAddressSpace(C[0].Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  unsigned AS = getLoadStoreAddressSpace(C[0].Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">  unsigned VecRegBytes = TTI.getLoadStoreVecRegBitWidth(AS) / 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">  unsigned VecRegBytes = TTI.getLoadStoreVecRegBitWidth(AS) / 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">  std::vector<Chain> Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">  std::vector<Chain> Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">  for (unsigned CBegin = 0; CBegin < C.size(); ++CBegin) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">  for (unsigned CBegin = 0; CBegin < C.size(); ++CBegin) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">    // Find candidate chains of size not greater than the largest vector reg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">    // Find candidate chains of size not greater than the largest vector reg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">    // These chains are over the closed interval [CBegin, CEnd].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">    // These chains are over the closed interval [CBegin, CEnd].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">    SmallVector<std::pair<unsigned /*CEnd*/, unsigned /*SizeBytes*/>, 8></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">    SmallVector<std::pair<unsigned /*CEnd*/, unsigned /*SizeBytes*/>, 8></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">        CandidateChains;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">        CandidateChains;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">    for (unsigned CEnd = CBegin + 1, Size = C.size(); CEnd < Size; ++CEnd) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">    for (unsigned CEnd = CBegin + 1, Size = C.size(); CEnd < Size; ++CEnd) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">      APInt Sz = C[CEnd].OffsetFromLeader +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">      APInt Sz = C[CEnd].OffsetFromLeader +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">                 DL.getTypeStoreSize(getLoadStoreType(C[CEnd].Inst)) -</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">                 DL.getTypeStoreSize(getLoadStoreType(C[CEnd].Inst)) -</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">                 C[CBegin].OffsetFromLeader;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">                 C[CBegin].OffsetFromLeader;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">      if (Sz.sgt(VecRegBytes))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">      if (Sz.sgt(VecRegBytes))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">      CandidateChains.push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">      CandidateChains.push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">          {CEnd, static_cast<unsigned>(Sz.getLimitedValue())});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">          {CEnd, static_cast<unsigned>(Sz.getLimitedValue())});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">    // Consider the longest chain first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">    // Consider the longest chain first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">    for (auto It = CandidateChains.rbegin(), End = CandidateChains.rend();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">    for (auto It = CandidateChains.rbegin(), End = CandidateChains.rend();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">         It != End; ++It) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">         It != End; ++It) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">      auto [CEnd, SizeBytes] = *It;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">      auto [CEnd, SizeBytes] = *It;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">      LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">      LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">          dbgs() << "LSV: splitChainByAlignment considering candidate chain ["</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">          dbgs() << "LSV: splitChainByAlignment considering candidate chain ["</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">                 << *C[CBegin].Inst << " ... " << *C[CEnd].Inst << "]\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">                 << *C[CBegin].Inst << " ... " << *C[CEnd].Inst << "]\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">      Type *VecElemTy = getChainElemTy(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">      Type *VecElemTy = getChainElemTy(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">      // Note, VecElemTy is a power of 2, but might be less than one byte.  For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">      // Note, VecElemTy is a power of 2, but might be less than one byte.  For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">      // example, we can vectorize 2 x <2 x i4> to <4 x i4>, and in this case</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">      // example, we can vectorize 2 x <2 x i4> to <4 x i4>, and in this case</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">      // VecElemTy would be i4.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">      // VecElemTy would be i4.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">      unsigned VecElemBits = DL.getTypeSizeInBits(VecElemTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">      unsigned VecElemBits = DL.getTypeSizeInBits(VecElemTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">      // SizeBytes and VecElemBits are powers of 2, so they divide evenly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">      // SizeBytes and VecElemBits are powers of 2, so they divide evenly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">      assert((8 * SizeBytes) % VecElemBits == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">      assert((8 * SizeBytes) % VecElemBits == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">      unsigned NumVecElems = 8 * SizeBytes / VecElemBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">      unsigned NumVecElems = 8 * SizeBytes / VecElemBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">      FixedVectorType *VecTy = FixedVectorType::get(VecElemTy, NumVecElems);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">      FixedVectorType *VecTy = FixedVectorType::get(VecElemTy, NumVecElems);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">      unsigned VF = 8 * VecRegBytes / VecElemBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">      unsigned VF = 8 * VecRegBytes / VecElemBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">      // Check that TTI is happy with this vectorization factor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">      // Check that TTI is happy with this vectorization factor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">      unsigned TargetVF = getVectorFactor(VF, VecElemBits,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">      unsigned TargetVF = getVectorFactor(VF, VecElemBits,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">                                          VecElemBits * NumVecElems / 8, VecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">                                          VecElemBits * NumVecElems / 8, VecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">      if (TargetVF != VF && TargetVF < NumVecElems) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">      if (TargetVF != VF && TargetVF < NumVecElems) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">                      "because TargetVF="</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">                      "because TargetVF="</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">                   << TargetVF << " != VF=" << VF</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">                   << TargetVF << " != VF=" << VF</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">                   << " and TargetVF < NumVecElems=" << NumVecElems << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">                   << " and TargetVF < NumVecElems=" << NumVecElems << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">      // Is a load/store with this alignment allowed by TTI and at least as fast</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">      // Is a load/store with this alignment allowed by TTI and at least as fast</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">      // as an unvectorized load/store?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">      // as an unvectorized load/store?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">      // TTI and F are passed as explicit captures to WAR an MSVC misparse (??).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">      // TTI and F are passed as explicit captures to WAR an MSVC misparse (??).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">      auto IsAllowedAndFast = [&, SizeBytes = SizeBytes, &TTI = TTI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">      auto IsAllowedAndFast = [&, SizeBytes = SizeBytes, &TTI = TTI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">                               &F = F](Align Alignment) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">                               &F = F](Align Alignment) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">        if (Alignment.value() % SizeBytes == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">        if (Alignment.value() % SizeBytes == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">        unsigned VectorizedSpeed = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">        unsigned VectorizedSpeed = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">        bool AllowsMisaligned = TTI.allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">        bool AllowsMisaligned = TTI.allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">            F.getContext(), SizeBytes * 8, AS, Alignment, &VectorizedSpeed);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">            F.getContext(), SizeBytes * 8, AS, Alignment, &VectorizedSpeed);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">        if (!AllowsMisaligned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">        if (!AllowsMisaligned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">                     << "LSV: Access of " << SizeBytes << "B in addrspace "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">                     << "LSV: Access of " << SizeBytes << "B in addrspace "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">                     << AS << " with alignment " << Alignment.value()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">                     << AS << " with alignment " << Alignment.value()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">                     << " is misaligned, and therefore can't be vectorized.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">                     << " is misaligned, and therefore can't be vectorized.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">        unsigned ElementwiseSpeed = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">        unsigned ElementwiseSpeed = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">        (TTI).allowsMisalignedMemoryAccesses((F).getContext(), VecElemBits, AS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">        (TTI).allowsMisalignedMemoryAccesses((F).getContext(), VecElemBits, AS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">                                             Alignment, &ElementwiseSpeed);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">                                             Alignment, &ElementwiseSpeed);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">        if (VectorizedSpeed < ElementwiseSpeed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">        if (VectorizedSpeed < ElementwiseSpeed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">                     << "LSV: Access of " << SizeBytes << "B in addrspace "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">                     << "LSV: Access of " << SizeBytes << "B in addrspace "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">                     << AS << " with alignment " << Alignment.value()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">                     << AS << " with alignment " << Alignment.value()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">                     << " has relative speed " << VectorizedSpeed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">                     << " has relative speed " << VectorizedSpeed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">                     << ", which is lower than the elementwise speed of "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">                     << ", which is lower than the elementwise speed of "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">                     << ElementwiseSpeed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">                     << ElementwiseSpeed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">                     << ".  Therefore this access won't be vectorized.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">                     << ".  Therefore this access won't be vectorized.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">      };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">      };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">      // If we're loading/storing from an alloca, align it if possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">      // If we're loading/storing from an alloca, align it if possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">      // FIXME: We eagerly upgrade the alignment, regardless of whether TTI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">      // FIXME: We eagerly upgrade the alignment, regardless of whether TTI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">      // tells us this is beneficial.  This feels a bit odd, but it matches</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">      // tells us this is beneficial.  This feels a bit odd, but it matches</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">      // existing tests.  This isn't *so* bad, because at most we align to 4</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">      // existing tests.  This isn't *so* bad, because at most we align to 4</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">      // bytes (current value of StackAdjustedAlignment).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">      // bytes (current value of StackAdjustedAlignment).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">      // FIXME: We will upgrade the alignment of the alloca even if it turns out</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">      // FIXME: We will upgrade the alignment of the alloca even if it turns out</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">      // we can't vectorize for some other reason.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">      // we can't vectorize for some other reason.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">      Value *PtrOperand = getLoadStorePointerOperand(C[CBegin].Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">      Value *PtrOperand = getLoadStorePointerOperand(C[CBegin].Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">      bool IsAllocaAccess = AS == DL.getAllocaAddrSpace() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">      bool IsAllocaAccess = AS == DL.getAllocaAddrSpace() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">                            isa<AllocaInst>(PtrOperand->stripPointerCasts());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">                            isa<AllocaInst>(PtrOperand->stripPointerCasts());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">      Align Alignment = getLoadStoreAlignment(C[CBegin].Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">      Align Alignment = getLoadStoreAlignment(C[CBegin].Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">      Align PrefAlign = Align(StackAdjustedAlignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">      Align PrefAlign = Align(StackAdjustedAlignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">      if (IsAllocaAccess && Alignment.value() % SizeBytes != 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">      if (IsAllocaAccess && Alignment.value() % SizeBytes != 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">          IsAllowedAndFast(PrefAlign)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">          IsAllowedAndFast(PrefAlign)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">        Align NewAlign = getOrEnforceKnownAlignment(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">        Align NewAlign = getOrEnforceKnownAlignment(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">            PtrOperand, PrefAlign, DL, C[CBegin].Inst, nullptr, &DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">            PtrOperand, PrefAlign, DL, C[CBegin].Inst, nullptr, &DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">        if (NewAlign >= Alignment) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">        if (NewAlign >= Alignment) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">                     << "LSV: splitByChain upgrading alloca alignment from "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">                     << "LSV: splitByChain upgrading alloca alignment from "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">                     << Alignment.value() << " to " << NewAlign.value()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">                     << Alignment.value() << " to " << NewAlign.value()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">                     << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">                     << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">          Alignment = NewAlign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">          Alignment = NewAlign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">      if (!IsAllowedAndFast(Alignment)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">      if (!IsAllowedAndFast(Alignment)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">                      "because its alignment is not AllowedAndFast: "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">                      "because its alignment is not AllowedAndFast: "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">                   << Alignment.value() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">                   << Alignment.value() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">      if ((IsLoadChain &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">      if ((IsLoadChain &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">           !TTI.isLegalToVectorizeLoadChain(SizeBytes, Alignment, AS)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">           !TTI.isLegalToVectorizeLoadChain(SizeBytes, Alignment, AS)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">          (!IsLoadChain &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">          (!IsLoadChain &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">           !TTI.isLegalToVectorizeStoreChain(SizeBytes, Alignment, AS))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">           !TTI.isLegalToVectorizeStoreChain(SizeBytes, Alignment, AS))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">            dbgs() << "LSV: splitChainByAlignment discarding candidate chain "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">                      "because !isLegalToVectorizeLoad/StoreChain.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">                      "because !isLegalToVectorizeLoad/StoreChain.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">      // Hooray, we can vectorize this chain!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">      // Hooray, we can vectorize this chain!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">      Chain &NewChain = Ret.emplace_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">      Chain &NewChain = Ret.emplace_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">      for (unsigned I = CBegin; I <= CEnd; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">      for (unsigned I = CBegin; I <= CEnd; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">        NewChain.push_back(C[I]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">        NewChain.push_back(C[I]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">      CBegin = CEnd; // Skip over the instructions we've added to the chain.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">      CBegin = CEnd; // Skip over the instructions we've added to the chain.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">bool Vectorizer::vectorizeChain(Chain &C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">bool Vectorizer::vectorizeChain(Chain &C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">  if (C.size() < 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">  if (C.size() < 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">  sortChainInOffsetOrder(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">  sortChainInOffsetOrder(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">    dbgs() << "LSV: Vectorizing chain of " << C.size() << " instructions:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">    dbgs() << "LSV: Vectorizing chain of " << C.size() << " instructions:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">    dumpChain(C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">    dumpChain(C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">  Type *VecElemTy = getChainElemTy(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">  Type *VecElemTy = getChainElemTy(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  bool IsLoadChain = isa<LoadInst>(C[0].Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  bool IsLoadChain = isa<LoadInst>(C[0].Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">  unsigned AS = getLoadStoreAddressSpace(C[0].Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">  unsigned AS = getLoadStoreAddressSpace(C[0].Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">  unsigned ChainBytes = std::accumulate(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">  unsigned ChainBytes = std::accumulate(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">      C.begin(), C.end(), 0u, [&](unsigned Bytes, const ChainElem &E) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">      C.begin(), C.end(), 0u, [&](unsigned Bytes, const ChainElem &E) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">        return Bytes + DL.getTypeStoreSize(getLoadStoreType(E.Inst));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">        return Bytes + DL.getTypeStoreSize(getLoadStoreType(E.Inst));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">  assert(ChainBytes % DL.getTypeStoreSize(VecElemTy) == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">  assert(ChainBytes % DL.getTypeStoreSize(VecElemTy) == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  // VecTy is a power of 2 and 1 byte at smallest, but VecElemTy may be smaller</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  // VecTy is a power of 2 and 1 byte at smallest, but VecElemTy may be smaller</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">  // than 1 byte (e.g. VecTy == <32 x i1>).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">  // than 1 byte (e.g. VecTy == <32 x i1>).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">  Type *VecTy = FixedVectorType::get(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">  Type *VecTy = FixedVectorType::get(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">      VecElemTy, 8 * ChainBytes / DL.getTypeSizeInBits(VecElemTy));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">      VecElemTy, 8 * ChainBytes / DL.getTypeSizeInBits(VecElemTy));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  Align Alignment = getLoadStoreAlignment(C[0].Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  Align Alignment = getLoadStoreAlignment(C[0].Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  // If this is a load/store of an alloca, we might have upgraded the alloca's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  // If this is a load/store of an alloca, we might have upgraded the alloca's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">  // alignment earlier.  Get the new alignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">  // alignment earlier.  Get the new alignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">  if (AS == DL.getAllocaAddrSpace()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">  if (AS == DL.getAllocaAddrSpace()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">    Alignment = std::max(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">    Alignment = std::max(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">        Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">        Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">        getOrEnforceKnownAlignment(getLoadStorePointerOperand(C[0].Inst),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">        getOrEnforceKnownAlignment(getLoadStorePointerOperand(C[0].Inst),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">                                   MaybeAlign(), DL, C[0].Inst, nullptr, &DT));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">                                   MaybeAlign(), DL, C[0].Inst, nullptr, &DT));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">  // All elements of the chain must have the same scalar-type size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">  // All elements of the chain must have the same scalar-type size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">    assert(DL.getTypeStoreSize(getLoadStoreType(E.Inst)->getScalarType()) ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">    assert(DL.getTypeStoreSize(getLoadStoreType(E.Inst)->getScalarType()) ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">           DL.getTypeStoreSize(VecElemTy));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">           DL.getTypeStoreSize(VecElemTy));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">  Instruction *VecInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">  Instruction *VecInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">  if (IsLoadChain) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">  if (IsLoadChain) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">    // Loads get hoisted to the location of the first load in the chain.  We may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">    // Loads get hoisted to the location of the first load in the chain.  We may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">    // also need to hoist the (transitive) operands of the loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">    // also need to hoist the (transitive) operands of the loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">    Builder.SetInsertPoint(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">    Builder.SetInsertPoint(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">        std::min_element(C.begin(), C.end(), [](const auto &A, const auto &B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">        std::min_element(C.begin(), C.end(), [](const auto &A, const auto &B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">          return A.Inst->comesBefore(B.Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">          return A.Inst->comesBefore(B.Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">        })->Inst);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">        })->Inst);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">    // Chain is in offset order, so C[0] is the instr with the lowest offset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">    // Chain is in offset order, so C[0] is the instr with the lowest offset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">    // i.e. the root of the vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">    // i.e. the root of the vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">    Value *Bitcast = Builder.CreateBitCast(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">    Value *Bitcast = Builder.CreateBitCast(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">        getLoadStorePointerOperand(C[0].Inst), VecTy->getPointerTo(AS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">        getLoadStorePointerOperand(C[0].Inst), VecTy->getPointerTo(AS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">    VecInst = Builder.CreateAlignedLoad(VecTy, Bitcast, Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">    VecInst = Builder.CreateAlignedLoad(VecTy, Bitcast, Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">    unsigned VecIdx = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">    unsigned VecIdx = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">    for (const ChainElem &E : C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">    for (const ChainElem &E : C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">      Instruction *I = E.Inst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">      Instruction *I = E.Inst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">      Value *V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">      Value *V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">      Type *T = getLoadStoreType(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">      Type *T = getLoadStoreType(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">      if (auto *VT = dyn_cast<FixedVectorType>(T)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">      if (auto *VT = dyn_cast<FixedVectorType>(T)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">        auto Mask = llvm::to_vector<8>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">        auto Mask = llvm::to_vector<8>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">            llvm::seq<int>(VecIdx, VecIdx + VT->getNumElements()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">            llvm::seq<int>(VecIdx, VecIdx + VT->getNumElements()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">        V = Builder.CreateShuffleVector(VecInst, Mask, I->getName());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">        V = Builder.CreateShuffleVector(VecInst, Mask, I->getName());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">        VecIdx += VT->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">        VecIdx += VT->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">        V = Builder.CreateExtractElement(VecInst, Builder.getInt32(VecIdx),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">        V = Builder.CreateExtractElement(VecInst, Builder.getInt32(VecIdx),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">                                         I->getName());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">                                         I->getName());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">        ++VecIdx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">        ++VecIdx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">      if (V->getType() != I->getType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">      if (V->getType() != I->getType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">        V = Builder.CreateBitOrPointerCast(V, I->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">        V = Builder.CreateBitOrPointerCast(V, I->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">      I->replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">      I->replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">    // Finally, we need to reorder the instrs in the BB so that the (transitive)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">    // Finally, we need to reorder the instrs in the BB so that the (transitive)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">    // operands of VecInst appear before it.  To see why, suppose we have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">    // operands of VecInst appear before it.  To see why, suppose we have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">    // vectorized the following code:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">    // vectorized the following code:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">    //   ptr1  = gep a, 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">    //   ptr1  = gep a, 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">    //   load1 = load i32 ptr1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">    //   load1 = load i32 ptr1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">    //   ptr0  = gep a, 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">    //   ptr0  = gep a, 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">    //   load0 = load i32 ptr0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">    //   load0 = load i32 ptr0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">    // We will put the vectorized load at the location of the earliest load in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">    // We will put the vectorized load at the location of the earliest load in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">    // the BB, i.e. load1.  We get:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">    // the BB, i.e. load1.  We get:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">    //   ptr1  = gep a, 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">    //   ptr1  = gep a, 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">    //   loadv = load <2 x i32> ptr0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">    //   loadv = load <2 x i32> ptr0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">    //   load0 = extractelement loadv, 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">    //   load0 = extractelement loadv, 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">    //   load1 = extractelement loadv, 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">    //   load1 = extractelement loadv, 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">    //   ptr0 = gep a, 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">    //   ptr0 = gep a, 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">    // Notice that loadv uses ptr0, which is defined *after* it!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">    // Notice that loadv uses ptr0, which is defined *after* it!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">    reorder(VecInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">    reorder(VecInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">    // Stores get sunk to the location of the last store in the chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">    // Stores get sunk to the location of the last store in the chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">    Builder.SetInsertPoint(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">    Builder.SetInsertPoint(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">        std::max_element(C.begin(), C.end(), [](auto &A, auto &B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">        std::max_element(C.begin(), C.end(), [](auto &A, auto &B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">          return A.Inst->comesBefore(B.Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">          return A.Inst->comesBefore(B.Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">        })->Inst);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">        })->Inst);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">    // Build the vector to store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">    // Build the vector to store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">    Value *Vec = PoisonValue::get(VecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">    Value *Vec = PoisonValue::get(VecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">    unsigned VecIdx = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">    unsigned VecIdx = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">    auto InsertElem = [&](Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">    auto InsertElem = [&](Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">      if (V->getType() != VecElemTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">      if (V->getType() != VecElemTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">        V = Builder.CreateBitOrPointerCast(V, VecElemTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">        V = Builder.CreateBitOrPointerCast(V, VecElemTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">      Vec = Builder.CreateInsertElement(Vec, V, Builder.getInt32(VecIdx++));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">      Vec = Builder.CreateInsertElement(Vec, V, Builder.getInt32(VecIdx++));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">    for (const ChainElem &E : C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">    for (const ChainElem &E : C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">      auto I = cast<StoreInst>(E.Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">      auto I = cast<StoreInst>(E.Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">      if (FixedVectorType *VT =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">      if (FixedVectorType *VT =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">              dyn_cast<FixedVectorType>(getLoadStoreType(I))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">              dyn_cast<FixedVectorType>(getLoadStoreType(I))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">        for (int J = 0, JE = VT->getNumElements(); J < JE; ++J) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">        for (int J = 0, JE = VT->getNumElements(); J < JE; ++J) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">          InsertElem(Builder.CreateExtractElement(I->getValueOperand(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">          InsertElem(Builder.CreateExtractElement(I->getValueOperand(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">                                                  Builder.getInt32(J)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">                                                  Builder.getInt32(J)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">        InsertElem(I->getValueOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">        InsertElem(I->getValueOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">    // Chain is in offset order, so C[0] is the instr with the lowest offset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">    // Chain is in offset order, so C[0] is the instr with the lowest offset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">    // i.e. the root of the vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">    // i.e. the root of the vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">    VecInst = Builder.CreateAlignedStore(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">    VecInst = Builder.CreateAlignedStore(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">        Vec,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">        Vec,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">        Builder.CreateBitCast(getLoadStorePointerOperand(C[0].Inst),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">        Builder.CreateBitCast(getLoadStorePointerOperand(C[0].Inst),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">                              VecTy->getPointerTo(AS)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">                              VecTy->getPointerTo(AS)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">        Alignment);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">        Alignment);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">  propagateMetadata(VecInst, C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">  propagateMetadata(VecInst, C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">  for (const ChainElem &E : C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">    ToErase.push_back(E.Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">    ToErase.push_back(E.Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  ++NumVectorInstructions;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  ++NumVectorInstructions;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">  NumScalarsVectorized += C.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">  NumScalarsVectorized += C.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">template <bool IsLoadChain></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">template <bool IsLoadChain></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">bool Vectorizer::isSafeToMove(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">bool Vectorizer::isSafeToMove(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">    Instruction *ChainElem, Instruction *ChainBegin,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">    Instruction *ChainElem, Instruction *ChainBegin,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">    const DenseMap<Instruction *, APInt /*OffsetFromLeader*/> &ChainOffsets) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">    const DenseMap<Instruction *, APInt /*OffsetFromLeader*/> &ChainOffsets) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: isSafeToMove(" << *ChainElem << " -> "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: isSafeToMove(" << *ChainElem << " -> "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">                    << *ChainBegin << ")\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">                    << *ChainBegin << ")\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">  assert(isa<LoadInst>(ChainElem) == IsLoadChain);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">  assert(isa<LoadInst>(ChainElem) == IsLoadChain);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">  if (ChainElem == ChainBegin)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">  if (ChainElem == ChainBegin)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">  // Invariant loads can always be reordered; by definition they are not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">  // Invariant loads can always be reordered; by definition they are not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">  // clobbered by stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">  // clobbered by stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">  if (isInvariantLoad(ChainElem))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">  if (isInvariantLoad(ChainElem))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">  auto BBIt = std::next([&] {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">  auto BBIt = std::next([&] {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">    if constexpr (IsLoadChain)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">    if constexpr (IsLoadChain)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">      return BasicBlock::reverse_iterator(ChainElem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">      return BasicBlock::reverse_iterator(ChainElem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">      return BasicBlock::iterator(ChainElem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">      return BasicBlock::iterator(ChainElem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">  }());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">  }());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">  auto BBItEnd = std::next([&] {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">  auto BBItEnd = std::next([&] {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">    if constexpr (IsLoadChain)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">    if constexpr (IsLoadChain)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">      return BasicBlock::reverse_iterator(ChainBegin);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">      return BasicBlock::reverse_iterator(ChainBegin);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">      return BasicBlock::iterator(ChainBegin);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">      return BasicBlock::iterator(ChainBegin);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">  }());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">  }());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">  const APInt &ChainElemOffset = ChainOffsets.at(ChainElem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">  const APInt &ChainElemOffset = ChainOffsets.at(ChainElem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">  const unsigned ChainElemSize =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">  const unsigned ChainElemSize =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">      DL.getTypeStoreSize(getLoadStoreType(ChainElem));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">      DL.getTypeStoreSize(getLoadStoreType(ChainElem));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  for (; BBIt != BBItEnd; ++BBIt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  for (; BBIt != BBItEnd; ++BBIt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">    Instruction *I = &*BBIt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">    Instruction *I = &*BBIt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">    if (!I->mayReadOrWriteMemory())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">    if (!I->mayReadOrWriteMemory())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">    // Loads can be reordered with other loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">    // Loads can be reordered with other loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">    if (IsLoadChain && isa<LoadInst>(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">    if (IsLoadChain && isa<LoadInst>(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">    // Stores can be sunk below invariant loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">    // Stores can be sunk below invariant loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">    if (!IsLoadChain && isInvariantLoad(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">    if (!IsLoadChain && isInvariantLoad(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">    // If I is in the chain, we can tell whether it aliases ChainIt by checking</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">    // If I is in the chain, we can tell whether it aliases ChainIt by checking</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">    // what offset ChainIt accesses.  This may be better than AA is able to do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">    // what offset ChainIt accesses.  This may be better than AA is able to do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">    // We should really only have duplicate offsets for stores (the duplicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">    // We should really only have duplicate offsets for stores (the duplicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">    // loads should be CSE'ed), but in case we have a duplicate load, we'll</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">    // loads should be CSE'ed), but in case we have a duplicate load, we'll</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">    // split the chain so we don't have to handle this case specially.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">    // split the chain so we don't have to handle this case specially.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">    if (auto OffsetIt = ChainOffsets.find(I); OffsetIt != ChainOffsets.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">    if (auto OffsetIt = ChainOffsets.find(I); OffsetIt != ChainOffsets.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">      // I and ChainElem overlap if:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">      // I and ChainElem overlap if:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">      //   - I and ChainElem have the same offset, OR</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">      //   - I and ChainElem have the same offset, OR</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">      //   - I's offset is less than ChainElem's, but I touches past the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">      //   - I's offset is less than ChainElem's, but I touches past the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">      //     beginning of ChainElem, OR</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">      //     beginning of ChainElem, OR</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">      //   - ChainElem's offset is less than I's, but ChainElem touches past the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">      //   - ChainElem's offset is less than I's, but ChainElem touches past the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">      //     beginning of I.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">      //     beginning of I.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">      const APInt &IOffset = OffsetIt->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">      const APInt &IOffset = OffsetIt->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">      unsigned IElemSize = DL.getTypeStoreSize(getLoadStoreType(I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">      unsigned IElemSize = DL.getTypeStoreSize(getLoadStoreType(I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">      if (IOffset == ChainElemOffset ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">      if (IOffset == ChainElemOffset ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">          (IOffset.sle(ChainElemOffset) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">          (IOffset.sle(ChainElemOffset) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">           (IOffset + IElemSize).sgt(ChainElemOffset)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">           (IOffset + IElemSize).sgt(ChainElemOffset)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">          (ChainElemOffset.sle(IOffset) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">          (ChainElemOffset.sle(IOffset) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">           (ChainElemOffset + ChainElemSize).sgt(OffsetIt->second))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">           (ChainElemOffset + ChainElemSize).sgt(OffsetIt->second))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">        LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">        LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">          // Double check that AA also sees this alias.  If not, we probably</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">          // Double check that AA also sees this alias.  If not, we probably</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">          // have a bug.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">          // have a bug.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">          ModRefInfo MR = AA.getModRefInfo(I, MemoryLocation::get(ChainElem));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">          ModRefInfo MR = AA.getModRefInfo(I, MemoryLocation::get(ChainElem));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">          assert(IsLoadChain ? isModSet(MR) : isModOrRefSet(MR));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">          assert(IsLoadChain ? isModSet(MR) : isModOrRefSet(MR));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">          dbgs() << "LSV: Found alias in chain: " << *I << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">          dbgs() << "LSV: Found alias in chain: " << *I << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">        return false; // We found an aliasing instruction; bail.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">        return false; // We found an aliasing instruction; bail.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">      continue; // We're confident there's no alias.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">      continue; // We're confident there's no alias.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "LSV: Querying AA for " << *I << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "LSV: Querying AA for " << *I << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">    ModRefInfo MR = AA.getModRefInfo(I, MemoryLocation::get(ChainElem));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">    ModRefInfo MR = AA.getModRefInfo(I, MemoryLocation::get(ChainElem));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">    if (IsLoadChain ? isModSet(MR) : isModOrRefSet(MR)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">    if (IsLoadChain ? isModSet(MR) : isModOrRefSet(MR)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "LSV: Found alias in chain:\n"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "LSV: Found alias in chain:\n"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">                        << "  Aliasing instruction:\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">                        << "  Aliasing instruction:\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">                        << "    " << *I << '\n'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">                        << "    " << *I << '\n'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">                        << "  Aliased instruction and pointer:\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">                        << "  Aliased instruction and pointer:\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">                        << "    " << *ChainElem << '\n'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">                        << "    " << *ChainElem << '\n'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">                        << "    " << *getLoadStorePointerOperand(ChainElem)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">                        << "    " << *getLoadStorePointerOperand(ChainElem)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">                        << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">                        << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">static bool checkNoWrapFlags(Instruction *I, bool Signed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">static bool checkNoWrapFlags(Instruction *I, bool Signed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">  BinaryOperator *BinOpI = cast<BinaryOperator>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">  BinaryOperator *BinOpI = cast<BinaryOperator>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">  return (Signed && BinOpI->hasNoSignedWrap()) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">  return (Signed && BinOpI->hasNoSignedWrap()) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">         (!Signed && BinOpI->hasNoUnsignedWrap());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">         (!Signed && BinOpI->hasNoUnsignedWrap());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">static bool checkIfSafeAddSequence(const APInt &IdxDiff, Instruction *AddOpA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">static bool checkIfSafeAddSequence(const APInt &IdxDiff, Instruction *AddOpA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">                                   unsigned MatchingOpIdxA, Instruction *AddOpB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">                                   unsigned MatchingOpIdxA, Instruction *AddOpB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">                                   unsigned MatchingOpIdxB, bool Signed) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">                                   unsigned MatchingOpIdxB, bool Signed) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: checkIfSafeAddSequence IdxDiff=" << IdxDiff</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: checkIfSafeAddSequence IdxDiff=" << IdxDiff</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">                    << ", AddOpA=" << *AddOpA << ", MatchingOpIdxA="</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">                    << ", AddOpA=" << *AddOpA << ", MatchingOpIdxA="</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">                    << MatchingOpIdxA << ", AddOpB=" << *AddOpB</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">                    << MatchingOpIdxA << ", AddOpB=" << *AddOpB</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">                    << ", MatchingOpIdxB=" << MatchingOpIdxB</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">                    << ", MatchingOpIdxB=" << MatchingOpIdxB</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">                    << ", Signed=" << Signed << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">                    << ", Signed=" << Signed << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  // If both OpA and OpB are adds with NSW/NUW and with one of the operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  // If both OpA and OpB are adds with NSW/NUW and with one of the operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">  // being the same, we can guarantee that the transformation is safe if we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">  // being the same, we can guarantee that the transformation is safe if we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">  // prove that OpA won't overflow when Ret added to the other operand of OpA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">  // prove that OpA won't overflow when Ret added to the other operand of OpA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">  // For example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">  // For example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">  //  %tmp7 = add nsw i32 %tmp2, %v0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">  //  %tmp7 = add nsw i32 %tmp2, %v0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">  //  %tmp8 = sext i32 %tmp7 to i64</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">  //  %tmp8 = sext i32 %tmp7 to i64</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">  //  ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">  //  ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">  //  %tmp11 = add nsw i32 %v0, 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">  //  %tmp11 = add nsw i32 %v0, 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">  //  %tmp12 = add nsw i32 %tmp2, %tmp11</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">  //  %tmp12 = add nsw i32 %tmp2, %tmp11</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  //  %tmp13 = sext i32 %tmp12 to i64</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  //  %tmp13 = sext i32 %tmp12 to i64</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">  //  Both %tmp7 and %tmp12 have the nsw flag and the first operand is %tmp2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">  //  Both %tmp7 and %tmp12 have the nsw flag and the first operand is %tmp2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">  //  It's guaranteed that adding 1 to %tmp7 won't overflow because %tmp11 adds</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">  //  It's guaranteed that adding 1 to %tmp7 won't overflow because %tmp11 adds</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">  //  1 to %v0 and both %tmp11 and %tmp12 have the nsw flag.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">  //  1 to %v0 and both %tmp11 and %tmp12 have the nsw flag.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">  assert(AddOpA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">  assert(AddOpA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">         AddOpB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">         AddOpB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">         checkNoWrapFlags(AddOpA, Signed) && checkNoWrapFlags(AddOpB, Signed));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">         checkNoWrapFlags(AddOpA, Signed) && checkNoWrapFlags(AddOpB, Signed));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">  if (AddOpA->getOperand(MatchingOpIdxA) ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">  if (AddOpA->getOperand(MatchingOpIdxA) ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">      AddOpB->getOperand(MatchingOpIdxB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">      AddOpB->getOperand(MatchingOpIdxB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">    Value *OtherOperandA = AddOpA->getOperand(MatchingOpIdxA == 1 ? 0 : 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">    Value *OtherOperandA = AddOpA->getOperand(MatchingOpIdxA == 1 ? 0 : 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">    Value *OtherOperandB = AddOpB->getOperand(MatchingOpIdxB == 1 ? 0 : 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">    Value *OtherOperandB = AddOpB->getOperand(MatchingOpIdxB == 1 ? 0 : 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">    Instruction *OtherInstrA = dyn_cast<Instruction>(OtherOperandA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">    Instruction *OtherInstrA = dyn_cast<Instruction>(OtherOperandA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">    Instruction *OtherInstrB = dyn_cast<Instruction>(OtherOperandB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">    Instruction *OtherInstrB = dyn_cast<Instruction>(OtherOperandB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">    // Match `x +nsw/nuw y` and `x +nsw/nuw (y +nsw/nuw IdxDiff)`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">    // Match `x +nsw/nuw y` and `x +nsw/nuw (y +nsw/nuw IdxDiff)`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">    if (OtherInstrB && OtherInstrB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">    if (OtherInstrB && OtherInstrB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">        checkNoWrapFlags(OtherInstrB, Signed) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">        checkNoWrapFlags(OtherInstrB, Signed) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">        isa<ConstantInt>(OtherInstrB->getOperand(1))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">        isa<ConstantInt>(OtherInstrB->getOperand(1))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">      int64_t CstVal =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">      int64_t CstVal =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">          cast<ConstantInt>(OtherInstrB->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">          cast<ConstantInt>(OtherInstrB->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">      if (OtherInstrB->getOperand(0) == OtherOperandA &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">      if (OtherInstrB->getOperand(0) == OtherOperandA &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">          IdxDiff.getSExtValue() == CstVal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">          IdxDiff.getSExtValue() == CstVal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">    // Match `x +nsw/nuw (y +nsw/nuw -Idx)` and `x +nsw/nuw (y +nsw/nuw x)`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">    // Match `x +nsw/nuw (y +nsw/nuw -Idx)` and `x +nsw/nuw (y +nsw/nuw x)`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">    if (OtherInstrA && OtherInstrA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">    if (OtherInstrA && OtherInstrA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">        checkNoWrapFlags(OtherInstrA, Signed) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">        checkNoWrapFlags(OtherInstrA, Signed) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">        isa<ConstantInt>(OtherInstrA->getOperand(1))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">        isa<ConstantInt>(OtherInstrA->getOperand(1))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">      int64_t CstVal =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">      int64_t CstVal =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">          cast<ConstantInt>(OtherInstrA->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">          cast<ConstantInt>(OtherInstrA->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">      if (OtherInstrA->getOperand(0) == OtherOperandB &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">      if (OtherInstrA->getOperand(0) == OtherOperandB &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">          IdxDiff.getSExtValue() == -CstVal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">          IdxDiff.getSExtValue() == -CstVal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">    // Match `x +nsw/nuw (y +nsw/nuw c)` and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">    // Match `x +nsw/nuw (y +nsw/nuw c)` and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">    // `x +nsw/nuw (y +nsw/nuw (c + IdxDiff))`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">    // `x +nsw/nuw (y +nsw/nuw (c + IdxDiff))`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">    if (OtherInstrA && OtherInstrB &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">    if (OtherInstrA && OtherInstrB &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">        OtherInstrA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">        OtherInstrA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">        OtherInstrB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">        OtherInstrB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">        checkNoWrapFlags(OtherInstrA, Signed) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">        checkNoWrapFlags(OtherInstrA, Signed) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">        checkNoWrapFlags(OtherInstrB, Signed) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">        checkNoWrapFlags(OtherInstrB, Signed) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">        isa<ConstantInt>(OtherInstrA->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">        isa<ConstantInt>(OtherInstrA->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">        isa<ConstantInt>(OtherInstrB->getOperand(1))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">        isa<ConstantInt>(OtherInstrB->getOperand(1))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">      int64_t CstValA =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">      int64_t CstValA =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">          cast<ConstantInt>(OtherInstrA->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">          cast<ConstantInt>(OtherInstrA->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">      int64_t CstValB =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">      int64_t CstValB =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">          cast<ConstantInt>(OtherInstrB->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">          cast<ConstantInt>(OtherInstrB->getOperand(1))->getSExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">      if (OtherInstrA->getOperand(0) == OtherInstrB->getOperand(0) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">      if (OtherInstrA->getOperand(0) == OtherInstrB->getOperand(0) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">          IdxDiff.getSExtValue() == (CstValB - CstValA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">          IdxDiff.getSExtValue() == (CstValB - CstValA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">std::optional<APInt> Vectorizer::getConstantOffsetComplexAddrs(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">std::optional<APInt> Vectorizer::getConstantOffsetComplexAddrs(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">    Value *PtrA, Value *PtrB, Instruction *ContextInst, unsigned Depth) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">    Value *PtrA, Value *PtrB, Instruction *ContextInst, unsigned Depth) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetComplexAddrs PtrA=" << *PtrA</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetComplexAddrs PtrA=" << *PtrA</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">                    << " PtrB=" << *PtrB << " ContextInst=" << *ContextInst</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">                    << " PtrB=" << *PtrB << " ContextInst=" << *ContextInst</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">                    << " Depth=" << Depth << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">                    << " Depth=" << Depth << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">  auto *GEPA = dyn_cast<GetElementPtrInst>(PtrA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">  auto *GEPA = dyn_cast<GetElementPtrInst>(PtrA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">  auto *GEPB = dyn_cast<GetElementPtrInst>(PtrB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">  auto *GEPB = dyn_cast<GetElementPtrInst>(PtrB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">  if (!GEPA || !GEPB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">  if (!GEPA || !GEPB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">    return getConstantOffsetSelects(PtrA, PtrB, ContextInst, Depth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">    return getConstantOffsetSelects(PtrA, PtrB, ContextInst, Depth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">  // Look through GEPs after checking they're the same except for the last</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">  // Look through GEPs after checking they're the same except for the last</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">  // index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">  // index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">  if (GEPA->getNumOperands() != GEPB->getNumOperands() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">  if (GEPA->getNumOperands() != GEPB->getNumOperands() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">      GEPA->getPointerOperand() != GEPB->getPointerOperand())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">      GEPA->getPointerOperand() != GEPB->getPointerOperand())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">  gep_type_iterator GTIA = gep_type_begin(GEPA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">  gep_type_iterator GTIA = gep_type_begin(GEPA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">  gep_type_iterator GTIB = gep_type_begin(GEPB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">  gep_type_iterator GTIB = gep_type_begin(GEPB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">  for (unsigned I = 0, E = GEPA->getNumIndices() - 1; I < E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">  for (unsigned I = 0, E = GEPA->getNumIndices() - 1; I < E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">    if (GTIA.getOperand() != GTIB.getOperand())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">    if (GTIA.getOperand() != GTIB.getOperand())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">      return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">      return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">    ++GTIA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">    ++GTIA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">    ++GTIB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">    ++GTIB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">  Instruction *OpA = dyn_cast<Instruction>(GTIA.getOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">  Instruction *OpA = dyn_cast<Instruction>(GTIA.getOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">  Instruction *OpB = dyn_cast<Instruction>(GTIB.getOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">  Instruction *OpB = dyn_cast<Instruction>(GTIB.getOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">  if (!OpA || !OpB || OpA->getOpcode() != OpB->getOpcode() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">  if (!OpA || !OpB || OpA->getOpcode() != OpB->getOpcode() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">      OpA->getType() != OpB->getType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">      OpA->getType() != OpB->getType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">  uint64_t Stride = DL.getTypeAllocSize(GTIA.getIndexedType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">  uint64_t Stride = DL.getTypeAllocSize(GTIA.getIndexedType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">  // Only look through a ZExt/SExt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">  // Only look through a ZExt/SExt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">  if (!isa<SExtInst>(OpA) && !isa<ZExtInst>(OpA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">  if (!isa<SExtInst>(OpA) && !isa<ZExtInst>(OpA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  bool Signed = isa<SExtInst>(OpA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  bool Signed = isa<SExtInst>(OpA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">  // At this point A could be a function parameter, i.e. not an instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">  // At this point A could be a function parameter, i.e. not an instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">  Value *ValA = OpA->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">  Value *ValA = OpA->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">  OpB = dyn_cast<Instruction>(OpB->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">  OpB = dyn_cast<Instruction>(OpB->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">  if (!OpB || ValA->getType() != OpB->getType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">  if (!OpB || ValA->getType() != OpB->getType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">  const SCEV *OffsetSCEVA = SE.getSCEV(ValA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">  const SCEV *OffsetSCEVA = SE.getSCEV(ValA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  const SCEV *OffsetSCEVB = SE.getSCEV(OpB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  const SCEV *OffsetSCEVB = SE.getSCEV(OpB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">  const SCEV *IdxDiffSCEV = SE.getMinusSCEV(OffsetSCEVB, OffsetSCEVA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">  const SCEV *IdxDiffSCEV = SE.getMinusSCEV(OffsetSCEVB, OffsetSCEVA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">  if (IdxDiffSCEV == SE.getCouldNotCompute())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">  if (IdxDiffSCEV == SE.getCouldNotCompute())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">  ConstantRange IdxDiffRange = SE.getSignedRange(IdxDiffSCEV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">  ConstantRange IdxDiffRange = SE.getSignedRange(IdxDiffSCEV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">  if (!IdxDiffRange.isSingleElement())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">  if (!IdxDiffRange.isSingleElement())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  APInt IdxDiff = *IdxDiffRange.getSingleElement();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  APInt IdxDiff = *IdxDiffRange.getSingleElement();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetComplexAddrs IdxDiff=" << IdxDiff</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetComplexAddrs IdxDiff=" << IdxDiff</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  // Now we need to prove that adding IdxDiff to ValA won't overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  // Now we need to prove that adding IdxDiff to ValA won't overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">  bool Safe = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">  bool Safe = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  // First attempt: if OpB is an add with NSW/NUW, and OpB is IdxDiff added to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  // First attempt: if OpB is an add with NSW/NUW, and OpB is IdxDiff added to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">  // ValA, we're okay.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">  // ValA, we're okay.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  if (OpB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  if (OpB->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">      isa<ConstantInt>(OpB->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">      isa<ConstantInt>(OpB->getOperand(1)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">      IdxDiff.sle(cast<ConstantInt>(OpB->getOperand(1))->getSExtValue()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">      IdxDiff.sle(cast<ConstantInt>(OpB->getOperand(1))->getSExtValue()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">      checkNoWrapFlags(OpB, Signed))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">      checkNoWrapFlags(OpB, Signed))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">    Safe = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">    Safe = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">  // Second attempt: check if we have eligible add NSW/NUW instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">  // Second attempt: check if we have eligible add NSW/NUW instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">  // sequences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">  // sequences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">  OpA = dyn_cast<Instruction>(ValA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">  OpA = dyn_cast<Instruction>(ValA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  if (!Safe && OpA && OpA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  if (!Safe && OpA && OpA->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">      OpB->getOpcode() == Instruction::Add && checkNoWrapFlags(OpA, Signed) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">      OpB->getOpcode() == Instruction::Add && checkNoWrapFlags(OpA, Signed) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">      checkNoWrapFlags(OpB, Signed)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">      checkNoWrapFlags(OpB, Signed)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">    // In the checks below a matching operand in OpA and OpB is an operand which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">    // In the checks below a matching operand in OpA and OpB is an operand which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">    // is the same in those two instructions.  Below we account for possible</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">    // is the same in those two instructions.  Below we account for possible</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">    // orders of the operands of these add instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">    // orders of the operands of these add instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">    for (unsigned MatchingOpIdxA : {0, 1})</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">    for (unsigned MatchingOpIdxA : {0, 1})</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">      for (unsigned MatchingOpIdxB : {0, 1})</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">      for (unsigned MatchingOpIdxB : {0, 1})</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">        if (!Safe)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">        if (!Safe)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">          Safe = checkIfSafeAddSequence(IdxDiff, OpA, MatchingOpIdxA, OpB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">          Safe = checkIfSafeAddSequence(IdxDiff, OpA, MatchingOpIdxA, OpB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">                                        MatchingOpIdxB, Signed);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">                                        MatchingOpIdxB, Signed);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">  unsigned BitWidth = ValA->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">  unsigned BitWidth = ValA->getType()->getScalarSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  // Third attempt:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  // Third attempt:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  // Assuming IdxDiff is positive: If all set bits of IdxDiff or any higher</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  // Assuming IdxDiff is positive: If all set bits of IdxDiff or any higher</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">  // order bit other than the sign bit are known to be zero in ValA, we can add</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">  // order bit other than the sign bit are known to be zero in ValA, we can add</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  // Diff to it while guaranteeing no overflow of any sort.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  // Diff to it while guaranteeing no overflow of any sort.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">  // If IdxDiff is negative, do the same, but swap ValA and ValB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">  // If IdxDiff is negative, do the same, but swap ValA and ValB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">  if (!Safe) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">  if (!Safe) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">    // When computing known bits, use the GEPs as context instructions, since</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">    // When computing known bits, use the GEPs as context instructions, since</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">    // they likely are in the same BB as the load/store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">    // they likely are in the same BB as the load/store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">    KnownBits Known(BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">    KnownBits Known(BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">    computeKnownBits((IdxDiff.sge(0) ? ValA : OpB), Known, DL, 0, &AC,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">    computeKnownBits((IdxDiff.sge(0) ? ValA : OpB), Known, DL, 0, &AC,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">                     ContextInst, &DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">                     ContextInst, &DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">    APInt BitsAllowedToBeSet = Known.Zero.zext(IdxDiff.getBitWidth());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">    APInt BitsAllowedToBeSet = Known.Zero.zext(IdxDiff.getBitWidth());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">    if (Signed)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">    if (Signed)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">      BitsAllowedToBeSet.clearBit(BitWidth - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">      BitsAllowedToBeSet.clearBit(BitWidth - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">    if (BitsAllowedToBeSet.ult(IdxDiff.abs()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">    if (BitsAllowedToBeSet.ult(IdxDiff.abs()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">      return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">      return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">    Safe = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">    Safe = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">  if (Safe)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">  if (Safe)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">    return IdxDiff * Stride;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">    return IdxDiff * Stride;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">std::optional<APInt> Vectorizer::getConstantOffsetSelects(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">std::optional<APInt> Vectorizer::getConstantOffsetSelects(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">    Value *PtrA, Value *PtrB, Instruction *ContextInst, unsigned Depth) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">    Value *PtrA, Value *PtrB, Instruction *ContextInst, unsigned Depth) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">  if (Depth++ == MaxDepth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">  if (Depth++ == MaxDepth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  if (auto *SelectA = dyn_cast<SelectInst>(PtrA)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  if (auto *SelectA = dyn_cast<SelectInst>(PtrA)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">    if (auto *SelectB = dyn_cast<SelectInst>(PtrB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">    if (auto *SelectB = dyn_cast<SelectInst>(PtrB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">      if (SelectA->getCondition() != SelectB->getCondition())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">      if (SelectA->getCondition() != SelectB->getCondition())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">        return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">        return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetSelects, PtrA=" << *PtrA</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "LSV: getConstantOffsetSelects, PtrA=" << *PtrA</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">                        << ", PtrB=" << *PtrB << ", ContextInst="</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">                        << ", PtrB=" << *PtrB << ", ContextInst="</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">                        << *ContextInst << ", Depth=" << Depth << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">                        << *ContextInst << ", Depth=" << Depth << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">      std::optional<APInt> TrueDiff = getConstantOffset(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">      std::optional<APInt> TrueDiff = getConstantOffset(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">          SelectA->getTrueValue(), SelectB->getTrueValue(), ContextInst, Depth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">          SelectA->getTrueValue(), SelectB->getTrueValue(), ContextInst, Depth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">      if (!TrueDiff.has_value())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">      if (!TrueDiff.has_value())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">        return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">        return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">      std::optional<APInt> FalseDiff =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">      std::optional<APInt> FalseDiff =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">          getConstantOffset(SelectA->getFalseValue(), SelectB->getFalseValue(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">          getConstantOffset(SelectA->getFalseValue(), SelectB->getFalseValue(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">                            ContextInst, Depth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">                            ContextInst, Depth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">      if (TrueDiff == FalseDiff)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">      if (TrueDiff == FalseDiff)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">        return TrueDiff;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">        return TrueDiff;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">EquivalenceClassMap</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">EquivalenceClassMap</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">Vectorizer::collectEquivalenceClasses(BasicBlock::iterator Begin,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">Vectorizer::collectEquivalenceClasses(BasicBlock::iterator Begin,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">                                      BasicBlock::iterator End) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">                                      BasicBlock::iterator End) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">  EquivalenceClassMap Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">  EquivalenceClassMap Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  auto getUnderlyingObject = [](const Value *Ptr) -> const Value * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  auto getUnderlyingObject = [](const Value *Ptr) -> const Value * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">    const Value *ObjPtr = llvm::getUnderlyingObject(Ptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">    const Value *ObjPtr = llvm::getUnderlyingObject(Ptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">    if (const auto *Sel = dyn_cast<SelectInst>(ObjPtr)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">    if (const auto *Sel = dyn_cast<SelectInst>(ObjPtr)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">      // The select's themselves are distinct instructions even if they share</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">      // The select's themselves are distinct instructions even if they share</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">      // the same condition and evaluate to consecutive pointers for true and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">      // the same condition and evaluate to consecutive pointers for true and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">      // false values of the condition. Therefore using the select's themselves</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">      // false values of the condition. Therefore using the select's themselves</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">      // for grouping instructions would put consecutive accesses into different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">      // for grouping instructions would put consecutive accesses into different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">      // lists and they won't be even checked for being consecutive, and won't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">      // lists and they won't be even checked for being consecutive, and won't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">      // be vectorized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">      // be vectorized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">      return Sel->getCondition();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">      return Sel->getCondition();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">    return ObjPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">    return ObjPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">  for (Instruction &I : make_range(Begin, End)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">  for (Instruction &I : make_range(Begin, End)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">    auto *LI = dyn_cast<LoadInst>(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">    auto *LI = dyn_cast<LoadInst>(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">    auto *SI = dyn_cast<StoreInst>(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">    auto *SI = dyn_cast<StoreInst>(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">    if (!LI && !SI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">    if (!LI && !SI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">    if ((LI && !LI->isSimple()) || (SI && !SI->isSimple()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">    if ((LI && !LI->isSimple()) || (SI && !SI->isSimple()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">    if ((LI && !TTI.isLegalToVectorizeLoad(LI)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">    if ((LI && !TTI.isLegalToVectorizeLoad(LI)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">        (SI && !TTI.isLegalToVectorizeStore(SI)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">        (SI && !TTI.isLegalToVectorizeStore(SI)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">    Type *Ty = getLoadStoreType(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">    Type *Ty = getLoadStoreType(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">    if (!VectorType::isValidElementType(Ty->getScalarType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">    if (!VectorType::isValidElementType(Ty->getScalarType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">    // Skip weird non-byte sizes. They probably aren't worth the effort of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">    // Skip weird non-byte sizes. They probably aren't worth the effort of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">    // handling correctly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">    // handling correctly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">    unsigned TySize = DL.getTypeSizeInBits(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">    unsigned TySize = DL.getTypeSizeInBits(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">    if ((TySize % 8) != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">    if ((TySize % 8) != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">    // Skip vectors of pointers. The vectorizeLoadChain/vectorizeStoreChain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">    // Skip vectors of pointers. The vectorizeLoadChain/vectorizeStoreChain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">    // functions are currently using an integer type for the vectorized</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">    // functions are currently using an integer type for the vectorized</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">    // load/store, and does not support casting between the integer type and a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">    // load/store, and does not support casting between the integer type and a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">    // vector of pointers (e.g. i64 to <2 x i16*>)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">    // vector of pointers (e.g. i64 to <2 x i16*>)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">    if (Ty->isVectorTy() && Ty->isPtrOrPtrVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">    if (Ty->isVectorTy() && Ty->isPtrOrPtrVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">    Value *Ptr = getLoadStorePointerOperand(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">    Value *Ptr = getLoadStorePointerOperand(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">    unsigned AS = Ptr->getType()->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">    unsigned AS = Ptr->getType()->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">    unsigned VecRegSize = TTI.getLoadStoreVecRegBitWidth(AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">    unsigned VecRegSize = TTI.getLoadStoreVecRegBitWidth(AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">    unsigned VF = VecRegSize / TySize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">    unsigned VF = VecRegSize / TySize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">    VectorType *VecTy = dyn_cast<VectorType>(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">    VectorType *VecTy = dyn_cast<VectorType>(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">    // Only handle power-of-two sized elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">    // Only handle power-of-two sized elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">    if ((!VecTy && !isPowerOf2_32(DL.getTypeSizeInBits(Ty))) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">    if ((!VecTy && !isPowerOf2_32(DL.getTypeSizeInBits(Ty))) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">        (VecTy && !isPowerOf2_32(DL.getTypeSizeInBits(VecTy->getScalarType()))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">        (VecTy && !isPowerOf2_32(DL.getTypeSizeInBits(VecTy->getScalarType()))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">    // No point in looking at these if they're too big to vectorize.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">    // No point in looking at these if they're too big to vectorize.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">    if (TySize > VecRegSize / 2 ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">    if (TySize > VecRegSize / 2 ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">        (VecTy && TTI.getLoadVectorFactor(VF, TySize, TySize / 8, VecTy) == 0))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">        (VecTy && TTI.getLoadVectorFactor(VF, TySize, TySize / 8, VecTy) == 0))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">    Ret[{getUnderlyingObject(Ptr), AS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">    Ret[{getUnderlyingObject(Ptr), AS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">         DL.getTypeSizeInBits(getLoadStoreType(&I)->getScalarType()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">         DL.getTypeSizeInBits(getLoadStoreType(&I)->getScalarType()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">         /*IsLoad=*/LI != nullptr}]</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">         /*IsLoad=*/LI != nullptr}]</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">        .push_back(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">        .push_back(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">std::vector<Chain> Vectorizer::gatherChains(ArrayRef<Instruction *> Instrs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">std::vector<Chain> Vectorizer::gatherChains(ArrayRef<Instruction *> Instrs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">  if (Instrs.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">  if (Instrs.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">    return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">  unsigned AS = getLoadStoreAddressSpace(Instrs[0]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">  unsigned AS = getLoadStoreAddressSpace(Instrs[0]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">  unsigned ASPtrBits = DL.getIndexSizeInBits(AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">  unsigned ASPtrBits = DL.getIndexSizeInBits(AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">  // Check that Instrs is in BB order and all have the same addr space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">  // Check that Instrs is in BB order and all have the same addr space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">  for (size_t I = 1; I < Instrs.size(); ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">  for (size_t I = 1; I < Instrs.size(); ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">    assert(Instrs[I - 1]->comesBefore(Instrs[I]));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">    assert(Instrs[I - 1]->comesBefore(Instrs[I]));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">    assert(getLoadStoreAddressSpace(Instrs[I]) == AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">    assert(getLoadStoreAddressSpace(Instrs[I]) == AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">  // Machinery to build an MRU-hashtable of Chains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">  // Machinery to build an MRU-hashtable of Chains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">  // (Ideally this could be done with MapVector, but as currently implemented,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">  // (Ideally this could be done with MapVector, but as currently implemented,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">  // moving an element to the front of a MapVector is O(n).)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">  // moving an element to the front of a MapVector is O(n).)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">  struct InstrListElem : ilist_node<InstrListElem>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">  struct InstrListElem : ilist_node<InstrListElem>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">                         std::pair<Instruction *, Chain> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">                         std::pair<Instruction *, Chain> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">    explicit InstrListElem(Instruction *I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">    explicit InstrListElem(Instruction *I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">        : std::pair<Instruction *, Chain>(I, {}) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">        : std::pair<Instruction *, Chain>(I, {}) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">  struct InstrListElemDenseMapInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">  struct InstrListElemDenseMapInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">    using PtrInfo = DenseMapInfo<InstrListElem *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">    using PtrInfo = DenseMapInfo<InstrListElem *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">    using IInfo = DenseMapInfo<Instruction *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">    using IInfo = DenseMapInfo<Instruction *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">    static InstrListElem *getEmptyKey() { return PtrInfo::getEmptyKey(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">    static InstrListElem *getEmptyKey() { return PtrInfo::getEmptyKey(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">    static InstrListElem *getTombstoneKey() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">    static InstrListElem *getTombstoneKey() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">      return PtrInfo::getTombstoneKey();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">      return PtrInfo::getTombstoneKey();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">    static unsigned getHashValue(const InstrListElem *E) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">    static unsigned getHashValue(const InstrListElem *E) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">      return IInfo::getHashValue(E->first);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">      return IInfo::getHashValue(E->first);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">    static bool isEqual(const InstrListElem *A, const InstrListElem *B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">    static bool isEqual(const InstrListElem *A, const InstrListElem *B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">      if (A == getEmptyKey() || B == getEmptyKey())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">      if (A == getEmptyKey() || B == getEmptyKey())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">        return A == getEmptyKey() && B == getEmptyKey();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">        return A == getEmptyKey() && B == getEmptyKey();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">      if (A == getTombstoneKey() || B == getTombstoneKey())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">      if (A == getTombstoneKey() || B == getTombstoneKey())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">        return A == getTombstoneKey() && B == getTombstoneKey();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">        return A == getTombstoneKey() && B == getTombstoneKey();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">      return IInfo::isEqual(A->first, B->first);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">      return IInfo::isEqual(A->first, B->first);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">  SpecificBumpPtrAllocator<InstrListElem> Allocator;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">  SpecificBumpPtrAllocator<InstrListElem> Allocator;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">  simple_ilist<InstrListElem> MRU;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">  simple_ilist<InstrListElem> MRU;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">  DenseSet<InstrListElem *, InstrListElemDenseMapInfo> Chains;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">  DenseSet<InstrListElem *, InstrListElemDenseMapInfo> Chains;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">  // Compare each instruction in `instrs` to leader of the N most recently-used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">  // Compare each instruction in `instrs` to leader of the N most recently-used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">  // chains.  This limits the O(n^2) behavior of this pass while also allowing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">  // chains.  This limits the O(n^2) behavior of this pass while also allowing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">  // us to build arbitrarily long chains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">  // us to build arbitrarily long chains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">  for (Instruction *I : Instrs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">  for (Instruction *I : Instrs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">    constexpr int MaxChainsToTry = 64;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">    constexpr int MaxChainsToTry = 64;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">    bool MatchFound = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">    bool MatchFound = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">    auto ChainIter = MRU.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">    auto ChainIter = MRU.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">    for (size_t J = 0; J < MaxChainsToTry && ChainIter != MRU.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">    for (size_t J = 0; J < MaxChainsToTry && ChainIter != MRU.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">         ++J, ++ChainIter) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">         ++J, ++ChainIter) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">      std::optional<APInt> Offset = getConstantOffset(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">      std::optional<APInt> Offset = getConstantOffset(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">          getLoadStorePointerOperand(ChainIter->first),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">          getLoadStorePointerOperand(ChainIter->first),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">          getLoadStorePointerOperand(I),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">          getLoadStorePointerOperand(I),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">          /*ContextInst=*/</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">          /*ContextInst=*/</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">          (ChainIter->first->comesBefore(I) ? I : ChainIter->first));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">          (ChainIter->first->comesBefore(I) ? I : ChainIter->first));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">      if (Offset.has_value()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">      if (Offset.has_value()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">        // `Offset` might not have the expected number of bits, if e.g. AS has a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">        // `Offset` might not have the expected number of bits, if e.g. AS has a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">        // different number of bits than opaque pointers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">        // different number of bits than opaque pointers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">        ChainIter->second.push_back(ChainElem{I, Offset.value()});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">        ChainIter->second.push_back(ChainElem{I, Offset.value()});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">        // Move ChainIter to the front of the MRU list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">        // Move ChainIter to the front of the MRU list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">        MRU.remove(*ChainIter);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">        MRU.remove(*ChainIter);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">        MRU.push_front(*ChainIter);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">        MRU.push_front(*ChainIter);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">        MatchFound = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">        MatchFound = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">    if (!MatchFound) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">    if (!MatchFound) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">      APInt ZeroOffset(ASPtrBits, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">      APInt ZeroOffset(ASPtrBits, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">      InstrListElem *E = new (Allocator.Allocate()) InstrListElem(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">      InstrListElem *E = new (Allocator.Allocate()) InstrListElem(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">      E->second.push_back(ChainElem{I, ZeroOffset});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">      E->second.push_back(ChainElem{I, ZeroOffset});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">      MRU.push_front(*E);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">      MRU.push_front(*E);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">      Chains.insert(E);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">      Chains.insert(E);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">  std::vector<Chain> Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">  std::vector<Chain> Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">  Ret.reserve(Chains.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">  Ret.reserve(Chains.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">  // Iterate over MRU rather than Chains so the order is deterministic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">  // Iterate over MRU rather than Chains so the order is deterministic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">  for (auto &E : MRU)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">  for (auto &E : MRU)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">    if (E.second.size() > 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">    if (E.second.size() > 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">      Ret.push_back(std::move(E.second));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">      Ret.push_back(std::move(E.second));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">  return Ret;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">std::optional<APInt> Vectorizer::getConstantOffset(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">std::optional<APInt> Vectorizer::getConstantOffset(Value *PtrA, Value *PtrB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">                                                   Instruction *ContextInst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">                                                   Instruction *ContextInst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">                                                   unsigned Depth) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">                                                   unsigned Depth) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffset, PtrA=" << *PtrA</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LSV: getConstantOffset, PtrA=" << *PtrA</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">                    << ", PtrB=" << *PtrB << ", ContextInst= " << *ContextInst</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">                    << ", PtrB=" << *PtrB << ", ContextInst= " << *ContextInst</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">                    << ", Depth=" << Depth << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">                    << ", Depth=" << Depth << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">  // We'll ultimately return a value of this bit width, even if computations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">  // We'll ultimately return a value of this bit width, even if computations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">  // happen in a different width.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">  // happen in a different width.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">  unsigned OrigBitWidth = DL.getIndexTypeSizeInBits(PtrA->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">  unsigned OrigBitWidth = DL.getIndexTypeSizeInBits(PtrA->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">  APInt OffsetA(OrigBitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">  APInt OffsetA(OrigBitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">  APInt OffsetB(OrigBitWidth, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">  APInt OffsetB(OrigBitWidth, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">  PtrA = PtrA->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">  PtrA = PtrA->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">  PtrB = PtrB->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">  PtrB = PtrB->stripAndAccumulateInBoundsConstantOffsets(DL, OffsetB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">  unsigned NewPtrBitWidth = DL.getTypeStoreSizeInBits(PtrA->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">  unsigned NewPtrBitWidth = DL.getTypeStoreSizeInBits(PtrA->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">  if (NewPtrBitWidth != DL.getTypeStoreSizeInBits(PtrB->getType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">  if (NewPtrBitWidth != DL.getTypeStoreSizeInBits(PtrB->getType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">  // If we have to shrink the pointer, stripAndAccumulateInBoundsConstantOffsets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">  // If we have to shrink the pointer, stripAndAccumulateInBoundsConstantOffsets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">  // should properly handle a possible overflow and the value should fit into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">  // should properly handle a possible overflow and the value should fit into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  // the smallest data type used in the cast/gep chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  // the smallest data type used in the cast/gep chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">  assert(OffsetA.getSignificantBits() <= NewPtrBitWidth &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">  assert(OffsetA.getSignificantBits() <= NewPtrBitWidth &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">         OffsetB.getSignificantBits() <= NewPtrBitWidth);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">         OffsetB.getSignificantBits() <= NewPtrBitWidth);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  OffsetA = OffsetA.sextOrTrunc(NewPtrBitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  OffsetA = OffsetA.sextOrTrunc(NewPtrBitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">  OffsetB = OffsetB.sextOrTrunc(NewPtrBitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">  OffsetB = OffsetB.sextOrTrunc(NewPtrBitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">  if (PtrA == PtrB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">  if (PtrA == PtrB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">    return (OffsetB - OffsetA).sextOrTrunc(OrigBitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">    return (OffsetB - OffsetA).sextOrTrunc(OrigBitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">  // Try to compute B - A.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">  // Try to compute B - A.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">  const SCEV *DistScev = SE.getMinusSCEV(SE.getSCEV(PtrB), SE.getSCEV(PtrA));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">  const SCEV *DistScev = SE.getMinusSCEV(SE.getSCEV(PtrB), SE.getSCEV(PtrA));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">  if (DistScev != SE.getCouldNotCompute()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">  if (DistScev != SE.getCouldNotCompute()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "LSV: SCEV PtrB - PtrA =" << *DistScev << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "LSV: SCEV PtrB - PtrA =" << *DistScev << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">    ConstantRange DistRange = SE.getSignedRange(DistScev);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">    ConstantRange DistRange = SE.getSignedRange(DistScev);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">    if (DistRange.isSingleElement()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">    if (DistRange.isSingleElement()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">      // Handle index width (the width of Dist) != pointer width (the width of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">      // Handle index width (the width of Dist) != pointer width (the width of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">      // the Offset*s at this point).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">      // the Offset*s at this point).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">      APInt Dist = DistRange.getSingleElement()->sextOrTrunc(NewPtrBitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">      APInt Dist = DistRange.getSingleElement()->sextOrTrunc(NewPtrBitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">      return (OffsetB - OffsetA + Dist).sextOrTrunc(OrigBitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">      return (OffsetB - OffsetA + Dist).sextOrTrunc(OrigBitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">  std::optional<APInt> Diff =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">  std::optional<APInt> Diff =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">      getConstantOffsetComplexAddrs(PtrA, PtrB, ContextInst, Depth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">      getConstantOffsetComplexAddrs(PtrA, PtrB, ContextInst, Depth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">  if (Diff.has_value())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">  if (Diff.has_value())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">    return (OffsetB - OffsetA + Diff->sext(OffsetB.getBitWidth()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">    return (OffsetB - OffsetA + Diff->sext(OffsetB.getBitWidth()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">        .sextOrTrunc(OrigBitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">        .sextOrTrunc(OrigBitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>