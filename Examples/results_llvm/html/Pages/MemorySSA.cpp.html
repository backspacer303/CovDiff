<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>MemorySSA.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- MemorySSA.cpp - Memory SSA Builder ---------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This file implements the MemorySSA class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">#include "llvm/Analysis/MemorySSA.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/ADT/DenseSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/ADT/DepthFirstIterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/ADT/Hashing.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/ADT/STLExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/ADT/StringExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/ADT/iterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/ADT/iterator_range.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/Analysis/CFGPrinter.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/Analysis/IteratedDominanceFrontier.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/Config/llvm-config.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/IR/AssemblyAnnotationWriter.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/IR/BasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/IR/Dominators.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/IR/IntrinsicInst.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/IR/LLVMContext.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/IR/Operator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/IR/PassManager.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/IR/Use.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/Support/AtomicOrdering.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include "llvm/Support/Casting.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#include "llvm/Support/Compiler.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include "llvm/Support/FormattedStream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include "llvm/Support/GraphWriter.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">#include <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">#include <memory></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">#define DEBUG_TYPE "memoryssa"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">static cl::opt<std::string></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">    DotCFGMSSA("dot-cfg-mssa",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">               cl::value_desc("file name for generated dot file"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">               cl::desc("file name for generated dot file"), cl::init(""));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(MemorySSAWrapperPass, "memoryssa", "Memory SSA", false,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">                      true)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="coveredLine">INITIALIZE_PASS_END(MemorySSAWrapperPass, "memoryssa", "Memory SSA", false,</td>
    <td>38</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">                    true)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">static cl::opt<unsigned> MaxCheckLimit(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">    "memssa-check-limit", cl::Hidden, cl::init(100),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">    cl::desc("The maximum number of stores/phis MemorySSA"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">             "will consider trying to walk past (default = 100)"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">// Always verify MemorySSA if expensive checking is enabled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">#ifdef EXPENSIVE_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">bool llvm::VerifyMemorySSA = true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">#else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">bool llvm::VerifyMemorySSA = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">static cl::opt<bool, true></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">    VerifyMemorySSAX("verify-memoryssa", cl::location(VerifyMemorySSA),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">                     cl::Hidden, cl::desc("Enable verification of MemorySSA."));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">const static char LiveOnEntryStr[] = "liveOnEntry";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">/// An assembly annotator class to print Memory SSA information in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">/// comments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">class MemorySSAAnnotatedWriter : public AssemblyAnnotationWriter {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">  const MemorySSA *MSSA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="uncoveredLine">  MemorySSAAnnotatedWriter(const MemorySSA *M) : MSSA(M) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="uncoveredLine">  void emitBasicBlockStartAnnot(const BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">                                formatted_raw_ostream &OS) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="uncoveredLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(BB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="uncoveredLine">      OS << "; " << *MA << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="uncoveredLine">  void emitInstructionAnnot(const Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">                            formatted_raw_ostream &OS) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="uncoveredLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="uncoveredLine">      OS << "; " << *MA << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">/// An assembly annotator class to print Memory SSA information in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">/// comments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">class MemorySSAWalkerAnnotatedWriter : public AssemblyAnnotationWriter {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">  MemorySSA *MSSA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">  MemorySSAWalker *Walker;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">  BatchAAResults BAA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="uncoveredLine">  MemorySSAWalkerAnnotatedWriter(MemorySSA *M)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="uncoveredLine">      : MSSA(M), Walker(M->getWalker()), BAA(M->getAA()) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="uncoveredLine">  void emitBasicBlockStartAnnot(const BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">                                formatted_raw_ostream &OS) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="uncoveredLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(BB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="uncoveredLine">      OS << "; " << *MA << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="uncoveredLine">  void emitInstructionAnnot(const Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">                            formatted_raw_ostream &OS) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="uncoveredLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="uncoveredLine">      MemoryAccess *Clobber = Walker->getClobberingMemoryAccess(MA, BAA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="uncoveredLine">      OS << "; " << *MA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="uncoveredLine">      if (Clobber) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="uncoveredLine">        OS << " - clobbered by ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="uncoveredLine">        if (MSSA->isLiveOnEntryDef(Clobber))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="uncoveredLine">          OS << LiveOnEntryStr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">        else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="uncoveredLine">          OS << *Clobber;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="uncoveredLine">      OS << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">} // namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">/// Our current alias analysis API differentiates heavily between calls and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">/// non-calls, and functions called on one usually assert on the other.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">/// This class encapsulates the distinction to simplify other code that wants</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">/// "Memory affecting instructions and related data" to use as a key.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">/// For example, this class is used as a densemap key in the use optimizer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">class MemoryLocOrCall {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">  bool IsCall = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="uncoveredLine">  MemoryLocOrCall(MemoryUseOrDef *MUD)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="uncoveredLine">      : MemoryLocOrCall(MUD->getMemoryInst()) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="uncoveredLine">  MemoryLocOrCall(const MemoryUseOrDef *MUD)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">      : MemoryLocOrCall(MUD->getMemoryInst()) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="uncoveredLine">  MemoryLocOrCall(Instruction *Inst) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="uncoveredLine">    if (auto *C = dyn_cast<CallBase>(Inst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">      IsCall = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">      Call = C;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="uncoveredLine">      IsCall = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">      // There is no such thing as a memorylocation for a fence inst, and it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">      // unique in that regard.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="uncoveredLine">      if (!isa<FenceInst>(Inst))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="uncoveredLine">        Loc = MemoryLocation::get(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="uncoveredLine">  explicit MemoryLocOrCall(const MemoryLocation &Loc) : Loc(Loc) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="uncoveredLine">  const CallBase *getCall() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="uncoveredLine">    assert(IsCall);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="uncoveredLine">    return Call;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="uncoveredLine">  MemoryLocation getLoc() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="uncoveredLine">    assert(!IsCall);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="uncoveredLine">    return Loc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="uncoveredLine">  bool operator==(const MemoryLocOrCall &Other) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">    if (IsCall != Other.IsCall)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="uncoveredLine">    if (!IsCall)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">      return Loc == Other.Loc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">    if (Call->getCalledOperand() != Other.Call->getCalledOperand())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="uncoveredLine">    return Call->arg_size() == Other.Call->arg_size() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">           std::equal(Call->arg_begin(), Call->arg_end(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="uncoveredLine">                      Other.Call->arg_begin());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">  union {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">    const CallBase *Call;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">    MemoryLocation Loc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">template <> struct DenseMapInfo<MemoryLocOrCall> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="uncoveredLine">  static inline MemoryLocOrCall getEmptyKey() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="uncoveredLine">    return MemoryLocOrCall(DenseMapInfo<MemoryLocation>::getEmptyKey());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="uncoveredLine">  static inline MemoryLocOrCall getTombstoneKey() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="uncoveredLine">    return MemoryLocOrCall(DenseMapInfo<MemoryLocation>::getTombstoneKey());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="uncoveredLine">  static unsigned getHashValue(const MemoryLocOrCall &MLOC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="uncoveredLine">    if (!MLOC.IsCall)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">      return hash_combine(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="uncoveredLine">          MLOC.IsCall,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">          DenseMapInfo<MemoryLocation>::getHashValue(MLOC.getLoc()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">    hash_code hash =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="uncoveredLine">        hash_combine(MLOC.IsCall, DenseMapInfo<const Value *>::getHashValue(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">                                      MLOC.getCall()->getCalledOperand()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="uncoveredLine">    for (const Value *Arg : MLOC.getCall()->args())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="uncoveredLine">      hash = hash_combine(hash, DenseMapInfo<const Value *>::getHashValue(Arg));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="uncoveredLine">    return hash;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">  static bool isEqual(const MemoryLocOrCall &LHS, const MemoryLocOrCall &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="uncoveredLine">    return LHS == RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">/// This does one-way checks to see if Use could theoretically be hoisted above</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">/// MayClobber. This will not check the other way around.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">/// This assumes that, for the purposes of MemorySSA, Use comes directly after</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">/// MayClobber, with no potentially clobbering operations in between them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">/// (Where potentially clobbering ops are memory barriers, aliased stores, etc.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">static bool areLoadsReorderable(const LoadInst *Use,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">                                const LoadInst *MayClobber) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="uncoveredLine">  bool VolatileUse = Use->isVolatile();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">  bool VolatileClobber = MayClobber->isVolatile();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">  // Volatile operations may never be reordered with other volatile operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">  if (VolatileUse && VolatileClobber)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">  // Otherwise, volatile doesn't matter here. From the language reference:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">  // 'optimizers may change the order of volatile operations relative to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  // non-volatile operations.'"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">  // If a load is seq_cst, it cannot be moved above other loads. If its ordering</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  // is weaker, it can be moved above other loads. We just need to be sure that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">  // MayClobber isn't an acquire load, because loads can't be moved above</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  // acquire loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  // Note that this explicitly *does* allow the free reordering of monotonic (or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">  // weaker) loads of the same address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="uncoveredLine">  bool SeqCstUse = Use->getOrdering() == AtomicOrdering::SequentiallyConsistent;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="uncoveredLine">  bool MayClobberIsAcquire = isAtLeastOrStrongerThan(MayClobber->getOrdering(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">                                                     AtomicOrdering::Acquire);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="uncoveredLine">  return !(SeqCstUse || MayClobberIsAcquire);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">template <typename AliasAnalysisType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">static bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="uncoveredLine">instructionClobbersQuery(const MemoryDef *MD, const MemoryLocation &UseLoc,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">                         const Instruction *UseInst, AliasAnalysisType &AA) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="uncoveredLine">  Instruction *DefInst = MD->getMemoryInst();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="uncoveredLine">  assert(DefInst && "Defining instruction not actually an instruction");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="uncoveredLine">  if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(DefInst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">    // These intrinsics will show up as affecting memory, but they are just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">    // markers, mostly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">    // FIXME: We probably don't actually want MemorySSA to model these at all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">    // (including creating MemoryAccesses for them): we just end up inventing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">    // clobbers where they don't really exist at all. Please see D43269 for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">    // context.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">    switch (II->getIntrinsicID()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">    case Intrinsic::invariant_start:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">    case Intrinsic::invariant_end:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">    case Intrinsic::assume:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">    case Intrinsic::experimental_noalias_scope_decl:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">    case Intrinsic::pseudoprobe:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="uncoveredLine">    case Intrinsic::dbg_declare:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">    case Intrinsic::dbg_label:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">    case Intrinsic::dbg_value:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">      llvm_unreachable("debuginfo shouldn't have associated defs!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">  if (auto *CB = dyn_cast_or_null<CallBase>(UseInst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="uncoveredLine">    ModRefInfo I = AA.getModRefInfo(DefInst, CB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">    return isModOrRefSet(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="uncoveredLine">  if (auto *DefLoad = dyn_cast<LoadInst>(DefInst))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">    if (auto *UseLoad = dyn_cast_or_null<LoadInst>(UseInst))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="uncoveredLine">      return !areLoadsReorderable(UseLoad, DefLoad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="uncoveredLine">  ModRefInfo I = AA.getModRefInfo(DefInst, UseLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="uncoveredLine">  return isModSet(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">template <typename AliasAnalysisType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="uncoveredLine">static bool instructionClobbersQuery(MemoryDef *MD, const MemoryUseOrDef *MU,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">                                     const MemoryLocOrCall &UseMLOC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">                                     AliasAnalysisType &AA) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">  // FIXME: This is a temporary hack to allow a single instructionClobbersQuery</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">  // to exist while MemoryLocOrCall is pushed through places.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="uncoveredLine">  if (UseMLOC.IsCall)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="uncoveredLine">    return instructionClobbersQuery(MD, MemoryLocation(), MU->getMemoryInst(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">                                    AA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="uncoveredLine">  return instructionClobbersQuery(MD, UseMLOC.getLoc(), MU->getMemoryInst(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">                                  AA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">// Return true when MD may alias MU, return false otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="uncoveredLine">bool MemorySSAUtil::defClobbersUseOrDef(MemoryDef *MD, const MemoryUseOrDef *MU,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">                                        AliasAnalysis &AA) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="uncoveredLine">  return instructionClobbersQuery(MD, MU, MemoryLocOrCall(MU), AA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">struct UpwardsMemoryQuery {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">  // True if our original query started off as a call</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">  bool IsCall = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">  // The pointer location we started the query with. This will be empty if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">  // IsCall is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">  MemoryLocation StartingLoc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">  // This is the instruction we were querying about.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">  const Instruction *Inst = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">  // The MemoryAccess we actually got called with, used to test local domination</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">  const MemoryAccess *OriginalAccess = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">  bool SkipSelfAccess = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">  UpwardsMemoryQuery() = default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">  UpwardsMemoryQuery(const Instruction *Inst, const MemoryAccess *Access)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">      : IsCall(isa<CallBase>(Inst)), Inst(Inst), OriginalAccess(Access) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">    if (!IsCall)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">      StartingLoc = MemoryLocation::get(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">template <typename AliasAnalysisType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="uncoveredLine">static bool isUseTriviallyOptimizableToLiveOnEntry(AliasAnalysisType &AA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">                                                   const Instruction *I) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">  // If the memory can't be changed, then loads of the memory can't be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">  // clobbered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="uncoveredLine">  if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">    return I->hasMetadata(LLVMContext::MD_invariant_load) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">           !isModSet(AA.getModRefInfoMask(MemoryLocation::get(LI)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">/// Verifies that `Start` is clobbered by `ClobberAt`, and that nothing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">/// inbetween `Start` and `ClobberAt` can clobbers `Start`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">/// This is meant to be as simple and self-contained as possible. Because it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">/// uses no cache, etc., it can be relatively expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">/// \param Start     The MemoryAccess that we want to walk from.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">/// \param ClobberAt A clobber for Start.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">/// \param StartLoc  The MemoryLocation for Start.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="">/// \param MSSA      The MemorySSA instance that Start and ClobberAt belong to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="">/// \param Query     The UpwardsMemoryQuery we used for our search.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">/// \param AA        The AliasAnalysis we used for our search.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">/// \param AllowImpreciseClobber Always false, unless we do relaxed verify.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">LLVM_ATTRIBUTE_UNUSED static void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="uncoveredLine">checkClobberSanity(const MemoryAccess *Start, MemoryAccess *ClobberAt,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">                   const MemoryLocation &StartLoc, const MemorySSA &MSSA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">                   const UpwardsMemoryQuery &Query, BatchAAResults &AA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">                   bool AllowImpreciseClobber = false) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">  assert(MSSA.dominates(ClobberAt, Start) && "Clobber doesn't dominate start?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">  if (MSSA.isLiveOnEntryDef(Start)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="uncoveredLine">    assert(MSSA.isLiveOnEntryDef(ClobberAt) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">           "liveOnEntry must clobber itself");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">  bool FoundClobber = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">  DenseSet<ConstMemoryAccessPair> VisitedPhis;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">  SmallVector<ConstMemoryAccessPair, 8> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="uncoveredLine">  Worklist.emplace_back(Start, StartLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">  // Walk all paths from Start to ClobberAt, while looking for clobbers. If one</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  // is found, complain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">    auto MAP = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">    // All we care about is that nothing from Start to ClobberAt clobbers Start.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">    // We learn nothing from revisiting nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">    if (!VisitedPhis.insert(MAP).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="uncoveredLine">    for (const auto *MA : def_chain(MAP.first)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="uncoveredLine">      if (MA == ClobberAt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="uncoveredLine">        if (const auto *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">          // instructionClobbersQuery isn't essentially free, so don't use `|=`,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">          // since it won't let us short-circuit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">          //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">          // Also, note that this can't be hoisted out of the `Worklist` loop,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">          // since MD may only act as a clobber for 1 of N MemoryLocations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">          FoundClobber = FoundClobber || MSSA.isLiveOnEntryDef(MD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">          if (!FoundClobber) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="uncoveredLine">            if (instructionClobbersQuery(MD, MAP.second, Query.Inst, AA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="uncoveredLine">              FoundClobber = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">      // We should never hit liveOnEntry, unless it's the clobber.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="uncoveredLine">      assert(!MSSA.isLiveOnEntryDef(MA) && "Hit liveOnEntry before clobber?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">      if (const auto *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">        // If Start is a Def, skip self.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">        if (MD == Start)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">        assert(!instructionClobbersQuery(MD, MAP.second, Query.Inst, AA) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">               "Found clobber before reaching ClobberAt!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">      if (const auto *MU = dyn_cast<MemoryUse>(MA)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">        (void)MU;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">        assert (MU == Start &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">                "Can only find use in def chain if Start is a use");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="uncoveredLine">      assert(isa<MemoryPhi>(MA));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">      // Add reachable phi predecessors</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="uncoveredLine">      for (auto ItB = upward_defs_begin(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">                    {const_cast<MemoryAccess *>(MA), MAP.second},</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">                    MSSA.getDomTree()),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">                ItE = upward_defs_end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">           ItB != ItE; ++ItB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">        if (MSSA.getDomTree().isReachableFromEntry(ItB.getPhiArgBlock()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="uncoveredLine">          Worklist.emplace_back(*ItB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">  // If the verify is done following an optimization, it's possible that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">  // ClobberAt was a conservative clobbering, that we can now infer is not a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">  // true clobbering access. Don't fail the verify if that's the case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  // We do have accesses that claim they're optimized, but could be optimized</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">  // further. Updating all these can be expensive, so allow it for now (FIXME).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">  if (AllowImpreciseClobber)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">  // If ClobberAt is a MemoryPhi, we can assume something above it acted as a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">  // clobber. Otherwise, `ClobberAt` should've acted as a clobber at some point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">  assert((isa<MemoryPhi>(ClobberAt) || FoundClobber) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">         "ClobberAt never acted as a clobber");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">/// Our algorithm for walking (and trying to optimize) clobbers, all wrapped up</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">/// in one class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">class ClobberWalker {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="">  /// Save a few bytes by using unsigned instead of size_t.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">  using ListIndex = unsigned;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  /// Represents a span of contiguous MemoryDefs, potentially ending in a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">  /// MemoryPhi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">  struct DefPath {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">    MemoryLocation Loc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">    // Note that, because we always walk in reverse, Last will always dominate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">    // First. Also note that First and Last are inclusive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">    MemoryAccess *First;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">    MemoryAccess *Last;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">    std::optional<ListIndex> Previous;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">    DefPath(const MemoryLocation &Loc, MemoryAccess *First, MemoryAccess *Last,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">            std::optional<ListIndex> Previous)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="uncoveredLine">        : Loc(Loc), First(First), Last(Last), Previous(Previous) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="uncoveredLine">    DefPath(const MemoryLocation &Loc, MemoryAccess *Init,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">            std::optional<ListIndex> Previous)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="uncoveredLine">        : DefPath(Loc, Init, Init, Previous) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">  const MemorySSA &MSSA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  DominatorTree &DT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">  BatchAAResults *AA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">  UpwardsMemoryQuery *Query;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">  unsigned *UpwardWalkLimit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">  // Phi optimization bookkeeping:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">  // List of DefPath to process during the current phi optimization walk.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">  SmallVector<DefPath, 32> Paths;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">  // List of visited <Access, Location> pairs; we can skip paths already</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">  // visited with the same memory location.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">  DenseSet<ConstMemoryAccessPair> VisitedPhis;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">  /// Find the nearest def or phi that `From` can legally be optimized to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="uncoveredLine">  const MemoryAccess *getWalkTarget(const MemoryPhi *From) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">    assert(From->getNumOperands() && "Phi with no operands?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">    BasicBlock *BB = From->getBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">    MemoryAccess *Result = MSSA.getLiveOnEntryDef();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">    DomTreeNode *Node = DT.getNode(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="uncoveredLine">    while ((Node = Node->getIDom())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">      auto *Defs = MSSA.getBlockDefs(Node->getBlock());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">      if (Defs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">        return &*Defs->rbegin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">    return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">  /// Result of calling walkToPhiOrClobber.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">  struct UpwardsWalkResult {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">    /// The "Result" of the walk. Either a clobber, the last thing we walked, or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">    /// both. Include alias info when clobber found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">    MemoryAccess *Result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">    bool IsKnownClobber;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">  /// Walk to the next Phi or Clobber in the def chain starting at Desc.Last.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">  /// This will update Desc.Last as it walks. It will (optionally) also stop at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">  /// StopAt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">  /// This does not test for whether StopAt is a clobber</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">  UpwardsWalkResult</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="uncoveredLine">  walkToPhiOrClobber(DefPath &Desc, const MemoryAccess *StopAt = nullptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">                     const MemoryAccess *SkipStopAt = nullptr) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">    assert(!isa<MemoryUse>(Desc.Last) && "Uses don't exist in my world");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="uncoveredLine">    assert(UpwardWalkLimit && "Need a valid walk limit");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">    bool LimitAlreadyReached = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">    // (*UpwardWalkLimit) may be 0 here, due to the loop in tryOptimizePhi. Set</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">    // it to 1. This will not do any alias() calls. It either returns in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">    // first iteration in the loop below, or is set back to 0 if all def chains</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">    // are free of MemoryDefs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="uncoveredLine">    if (!*UpwardWalkLimit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="uncoveredLine">      *UpwardWalkLimit = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="uncoveredLine">      LimitAlreadyReached = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="uncoveredLine">    for (MemoryAccess *Current : def_chain(Desc.Last)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="uncoveredLine">      Desc.Last = Current;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="uncoveredLine">      if (Current == StopAt || Current == SkipStopAt)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="uncoveredLine">        return {Current, false};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="uncoveredLine">      if (auto *MD = dyn_cast<MemoryDef>(Current)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="uncoveredLine">        if (MSSA.isLiveOnEntryDef(MD))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="uncoveredLine">          return {MD, true};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="uncoveredLine">        if (!--*UpwardWalkLimit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">          return {Current, true};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">        if (instructionClobbersQuery(MD, Desc.Loc, Query->Inst, *AA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">          return {MD, true};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="uncoveredLine">    if (LimitAlreadyReached)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="uncoveredLine">      *UpwardWalkLimit = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="uncoveredLine">    assert(isa<MemoryPhi>(Desc.Last) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">           "Ended at a non-clobber that's not a phi?");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">    return {Desc.Last, false};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">  void addSearches(MemoryPhi *Phi, SmallVectorImpl<ListIndex> &PausedSearches,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">                   ListIndex PriorNode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">    auto UpwardDefsBegin = upward_defs_begin({Phi, Paths[PriorNode].Loc}, DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">    auto UpwardDefs = make_range(UpwardDefsBegin, upward_defs_end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="uncoveredLine">    for (const MemoryAccessPair &P : UpwardDefs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="uncoveredLine">      PausedSearches.push_back(Paths.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">      Paths.emplace_back(P.second, P.first, PriorNode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">  /// Represents a search that terminated after finding a clobber. This clobber</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">  /// may or may not be present in the path of defs from LastNode..SearchStart,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">  /// since it may have been retrieved from cache.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">  struct TerminatedPath {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">    MemoryAccess *Clobber;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">    ListIndex LastNode;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">  /// Get an access that keeps us from optimizing to the given phi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">  /// PausedSearches is an array of indices into the Paths array. Its incoming</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">  /// value is the indices of searches that stopped at the last phi optimization</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">  /// target. It's left in an unspecified state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">  /// If this returns std::nullopt, NewPaused is a vector of searches that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">  /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">  /// state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">  std::optional<TerminatedPath></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">  getBlockingAccess(const MemoryAccess *StopWhere,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">                    SmallVectorImpl<ListIndex> &PausedSearches,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">                    SmallVectorImpl<ListIndex> &NewPaused,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">                    SmallVectorImpl<TerminatedPath> &Terminated) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">    assert(!PausedSearches.empty() && "No searches to continue?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">    // BFS vs DFS really doesn't make a difference here, so just do a DFS with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">    // PausedSearches as our stack.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="uncoveredLine">    while (!PausedSearches.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">      ListIndex PathIndex = PausedSearches.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="uncoveredLine">      DefPath &Node = Paths[PathIndex];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">      // If we've already visited this path with this MemoryLocation, we don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">      // need to do so again.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">      // NOTE: That we just drop these paths on the ground makes caching</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">      // behavior sporadic. e.g. given a diamond:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">      //  A</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">      // B C</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">      //  D</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">      // ...If we walk D, B, A, C, we'll only cache the result of phi</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">      // optimization for A, B, and D; C will be skipped because it dies here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="">      // This arguably isn't the worst thing ever, since:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">      //   - We generally query things in a top-down order, so if we got below D</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">      //     without needing cache entries for {C, MemLoc}, then chances are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">      //     that those cache entries would end up ultimately unused.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">      //   - We still cache things for A, so C only needs to walk up a bit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">      // If this behavior becomes problematic, we can fix without a ton of extra</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">      // work.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="uncoveredLine">      if (!VisitedPhis.insert({Node.Last, Node.Loc}).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="uncoveredLine">      const MemoryAccess *SkipStopWhere = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="uncoveredLine">      if (Query->SkipSelfAccess && Node.Loc == Query->StartingLoc) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">        assert(isa<MemoryDef>(Query->OriginalAccess));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="uncoveredLine">        SkipStopWhere = Query->OriginalAccess;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="uncoveredLine">      UpwardsWalkResult Res = walkToPhiOrClobber(Node,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">                                                 /*StopAt=*/StopWhere,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">                                                 /*SkipStopAt=*/SkipStopWhere);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">      if (Res.IsKnownClobber) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">        assert(Res.Result != StopWhere && Res.Result != SkipStopWhere);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">        // If this wasn't a cache hit, we hit a clobber when walking. That's a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">        // failure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="uncoveredLine">        TerminatedPath Term{Res.Result, PathIndex};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="uncoveredLine">        if (!MSSA.dominates(Res.Result, StopWhere))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">          return Term;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">        // Otherwise, it's a valid thing to potentially optimize to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">        Terminated.push_back(Term);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">      if (Res.Result == StopWhere || Res.Result == SkipStopWhere) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">        // We've hit our target. Save this path off for if we want to continue</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">        // walking. If we are in the mode of skipping the OriginalAccess, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">        // we've reached back to the OriginalAccess, do not save path, we've</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">        // just looped back to self.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="uncoveredLine">        if (Res.Result != SkipStopWhere)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="uncoveredLine">          NewPaused.push_back(PathIndex);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="uncoveredLine">      assert(!MSSA.isLiveOnEntryDef(Res.Result) && "liveOnEntry is a clobber");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">      addSearches(cast<MemoryPhi>(Res.Result), PausedSearches, PathIndex);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">  template <typename T, typename Walker></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">  struct generic_def_path_iterator</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">      : public iterator_facade_base<generic_def_path_iterator<T, Walker>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">                                    std::forward_iterator_tag, T *> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="uncoveredLine">    generic_def_path_iterator() = default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="uncoveredLine">    generic_def_path_iterator(Walker *W, ListIndex N) : W(W), N(N) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="uncoveredLine">    T &operator*() const { return curNode(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">    generic_def_path_iterator &operator++() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">      N = curNode().Previous;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">      return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="uncoveredLine">    bool operator==(const generic_def_path_iterator &O) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">      if (N.has_value() != O.N.has_value())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">      return !N || *N == *O.N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="">  private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">    T &curNode() const { return W->Paths[*N]; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">    Walker *W = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">    std::optional<ListIndex> N;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="">  using def_path_iterator = generic_def_path_iterator<DefPath, ClobberWalker>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">  using const_def_path_iterator =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">      generic_def_path_iterator<const DefPath, const ClobberWalker>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">  iterator_range<def_path_iterator> def_path(ListIndex From) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">    return make_range(def_path_iterator(this, From), def_path_iterator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">  iterator_range<const_def_path_iterator> const_def_path(ListIndex From) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">    return make_range(const_def_path_iterator(this, From),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">                      const_def_path_iterator());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">  struct OptznResult {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">    /// The path that contains our result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">    TerminatedPath PrimaryClobber;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">    /// The paths that we can legally cache back from, but that aren't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">    /// necessarily the result of the Phi optimization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">    SmallVector<TerminatedPath, 4> OtherClobbers;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">  ListIndex defPathIndex(const DefPath &N) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">    // The assert looks nicer if we don't need to do &N</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">    const DefPath *NP = &N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">    assert(!Paths.empty() && NP >= &Paths.front() && NP <= &Paths.back() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">           "Out of bounds DefPath!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="uncoveredLine">    return NP - &Paths.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">  /// Try to optimize a phi as best as we can. Returns a SmallVector of Paths</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">  /// that act as legal clobbers. Note that this won't return *all* clobbers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">  /// Phi optimization algorithm tl;dr:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">  ///   - Find the earliest def/phi, A, we can optimize to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">  ///   - Find if all paths from the starting memory access ultimately reach A</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">  ///     - If not, optimization isn't possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">  ///     - Otherwise, walk from A to another clobber or phi, A'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">  ///       - If A' is a def, we're done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">  ///       - If A' is a phi, try to optimize it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">  /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">  /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">  OptznResult tryOptimizePhi(MemoryPhi *Phi, MemoryAccess *Start,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">                             const MemoryLocation &Loc) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="uncoveredLine">    assert(Paths.empty() && VisitedPhis.empty() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">           "Reset the optimization state.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">    Paths.emplace_back(Loc, Start, Phi, std::nullopt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">    // Stores how many "valid" optimization nodes we had prior to calling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">    // addSearches/getBlockingAccess. Necessary for caching if we had a blocker.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">    auto PriorPathsSize = Paths.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="uncoveredLine">    SmallVector<ListIndex, 16> PausedSearches;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="uncoveredLine">    SmallVector<ListIndex, 8> NewPaused;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="uncoveredLine">    SmallVector<TerminatedPath, 4> TerminatedPaths;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">    addSearches(Phi, PausedSearches, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">    // Moves the TerminatedPath with the "most dominated" Clobber to the end of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="">    // Paths.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">    auto MoveDominatedPathToEnd = [&](SmallVectorImpl<TerminatedPath> &Paths) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">      assert(!Paths.empty() && "Need a path to move");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="uncoveredLine">      auto Dom = Paths.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">      for (auto I = std::next(Dom), E = Paths.end(); I != E; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">        if (!MSSA.dominates(I->Clobber, Dom->Clobber))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">          Dom = I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">      auto Last = Paths.end() - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="uncoveredLine">      if (Last != Dom)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">        std::iter_swap(Last, Dom);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">    };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="uncoveredLine">    MemoryPhi *Current = Phi;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">    while (true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">      assert(!MSSA.isLiveOnEntryDef(Current) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">             "liveOnEntry wasn't treated as a clobber?");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">      const auto *Target = getWalkTarget(Current);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">      // If a TerminatedPath doesn't dominate Target, then it wasn't a legal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">      // optimization for the prior phi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="uncoveredLine">      assert(all_of(TerminatedPaths, [&](const TerminatedPath &P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">        return MSSA.dominates(P.Clobber, Target);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">      }));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">      // FIXME: This is broken, because the Blocker may be reported to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">      // liveOnEntry, and we'll happily wait for that to disappear (read: never)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">      // For the moment, this is fine, since we do nothing with blocker info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="uncoveredLine">      if (std::optional<TerminatedPath> Blocker = getBlockingAccess(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">              Target, PausedSearches, NewPaused, TerminatedPaths)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">        // Find the node we started at. We can't search based on N->Last, since</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="">        // we may have gone around a loop with a different MemoryLocation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="uncoveredLine">        auto Iter = find_if(def_path(Blocker->LastNode), [&](const DefPath &N) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="uncoveredLine">          return defPathIndex(N) < PriorPathsSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">        });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="uncoveredLine">        assert(Iter != def_path_iterator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">        DefPath &CurNode = *Iter;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="uncoveredLine">        assert(CurNode.Last == Current);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">        // Two things:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">        // A. We can't reliably cache all of NewPaused back. Consider a case</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">        //    where we have two paths in NewPaused; one of which can't optimize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">        //    above this phi, whereas the other can. If we cache the second path</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">        //    back, we'll end up with suboptimal cache entries. We can handle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">        //    cases like this a bit better when we either try to find all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">        //    clobbers that block phi optimization, or when our cache starts</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">        //    supporting unfinished searches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">        // B. We can't reliably cache TerminatedPaths back here without doing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">        //    extra checks; consider a case like:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">        //       T</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="">        //      / \</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="">        //     D   C</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">        //      \ /</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">        //       S</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="">        //    Where T is our target, C is a node with a clobber on it, D is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="">        //    diamond (with a clobber *only* on the left or right node, N), and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="">        //    S is our start. Say we walk to D, through the node opposite N</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">        //    (read: ignoring the clobber), and see a cache entry in the top</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">        //    node of D. That cache entry gets put into TerminatedPaths. We then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">        //    walk up to C (N is later in our worklist), find the clobber, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">        //    quit. If we append TerminatedPaths to OtherClobbers, we'll cache</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">        //    the bottom part of D to the cached clobber, ignoring the clobber</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">        //    in N. Again, this problem goes away if we start tracking all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">        //    blockers for a given phi optimization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="uncoveredLine">        TerminatedPath Result{CurNode.Last, defPathIndex(CurNode)};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="uncoveredLine">        return {Result, {}};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">      // If there's nothing left to search, then all paths led to valid clobbers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">      // that we got from our cache; pick the nearest to the start, and allow</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="">      // the rest to be cached back.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">      if (NewPaused.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">        MoveDominatedPathToEnd(TerminatedPaths);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">        TerminatedPath Result = TerminatedPaths.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">        return {Result, std::move(TerminatedPaths)};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">      MemoryAccess *DefChainEnd = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">      SmallVector<TerminatedPath, 4> Clobbers;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="uncoveredLine">      for (ListIndex Paused : NewPaused) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="uncoveredLine">        UpwardsWalkResult WR = walkToPhiOrClobber(Paths[Paused]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="uncoveredLine">        if (WR.IsKnownClobber)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">          Clobbers.push_back({WR.Result, Paused});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">        else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">          // Micro-opt: If we hit the end of the chain, save it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">          DefChainEnd = WR.Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">      if (!TerminatedPaths.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">        // If we couldn't find the dominating phi/liveOnEntry in the above loop,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">        // do it now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">        if (!DefChainEnd)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="uncoveredLine">          for (auto *MA : def_chain(const_cast<MemoryAccess *>(Target)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">            DefChainEnd = MA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">        assert(DefChainEnd && "Failed to find dominating phi/liveOnEntry");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">        // If any of the terminated paths don't dominate the phi we'll try to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">        // optimize, we need to figure out what they are and quit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">        const BasicBlock *ChainBB = DefChainEnd->getBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">        for (const TerminatedPath &TP : TerminatedPaths) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">          // Because we know that DefChainEnd is as "high" as we can go, we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="">          // don't need local dominance checks; BB dominance is sufficient.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">          if (DT.dominates(ChainBB, TP.Clobber->getBlock()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">            Clobbers.push_back(TP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">      // If we have clobbers in the def chain, find the one closest to Current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">      // and quit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="uncoveredLine">      if (!Clobbers.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="uncoveredLine">        MoveDominatedPathToEnd(Clobbers);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="uncoveredLine">        TerminatedPath Result = Clobbers.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="uncoveredLine">        return {Result, std::move(Clobbers)};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="uncoveredLine">      assert(all_of(NewPaused,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">                    [&](ListIndex I) { return Paths[I].Last == DefChainEnd; }));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">      // Because liveOnEntry is a clobber, this must be a phi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="uncoveredLine">      auto *DefChainPhi = cast<MemoryPhi>(DefChainEnd);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="uncoveredLine">      PriorPathsSize = Paths.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">      PausedSearches.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="uncoveredLine">      for (ListIndex I : NewPaused)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">        addSearches(DefChainPhi, PausedSearches, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="uncoveredLine">      NewPaused.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="uncoveredLine">      Current = DefChainPhi;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="uncoveredLine">  void verifyOptResult(const OptznResult &R) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">    assert(all_of(R.OtherClobbers, [&](const TerminatedPath &P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">      return MSSA.dominates(P.Clobber, R.PrimaryClobber.Clobber);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">    }));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="uncoveredLine">  void resetPhiOptznState() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">    Paths.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">    VisitedPhis.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="uncoveredLine">  ClobberWalker(const MemorySSA &MSSA, DominatorTree &DT)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">      : MSSA(MSSA), DT(DT) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="">  /// Finds the nearest clobber for the given query, optimizing phis if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">  /// possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="uncoveredLine">  MemoryAccess *findClobber(BatchAAResults &BAA, MemoryAccess *Start,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="">                            UpwardsMemoryQuery &Q, unsigned &UpWalkLimit) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="uncoveredLine">    AA = &BAA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="uncoveredLine">    Query = &Q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="uncoveredLine">    UpwardWalkLimit = &UpWalkLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">    // Starting limit must be > 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="uncoveredLine">    if (!UpWalkLimit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="uncoveredLine">      UpWalkLimit++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="uncoveredLine">    MemoryAccess *Current = Start;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">    // This walker pretends uses don't exist. If we're handed one, silently grab</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">    // its def. (This has the nice side-effect of ensuring we never cache uses)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="uncoveredLine">    if (auto *MU = dyn_cast<MemoryUse>(Start))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="uncoveredLine">      Current = MU->getDefiningAccess();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="uncoveredLine">    DefPath FirstDesc(Q.StartingLoc, Current, Current, std::nullopt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">    // Fast path for the overly-common case (no crazy phi optimization</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">    // necessary)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="uncoveredLine">    UpwardsWalkResult WalkResult = walkToPhiOrClobber(FirstDesc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="">    MemoryAccess *Result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">    if (WalkResult.IsKnownClobber) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="uncoveredLine">      Result = WalkResult.Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="">      OptznResult OptRes = tryOptimizePhi(cast<MemoryPhi>(FirstDesc.Last),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="uncoveredLine">                                          Current, Q.StartingLoc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="uncoveredLine">      verifyOptResult(OptRes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="uncoveredLine">      resetPhiOptznState();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="uncoveredLine">      Result = OptRes.PrimaryClobber.Clobber;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">#ifdef EXPENSIVE_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">    if (!Q.SkipSelfAccess && *UpwardWalkLimit > 0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">      checkClobberSanity(Current, Result, Q.StartingLoc, MSSA, Q, BAA);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">    return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">struct RenamePassData {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">  DomTreeNode *DTN;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">  DomTreeNode::const_iterator ChildIt;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">  MemoryAccess *IncomingVal;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="uncoveredLine">  RenamePassData(DomTreeNode *D, DomTreeNode::const_iterator It,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="">                 MemoryAccess *M)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="uncoveredLine">      : DTN(D), ChildIt(It), IncomingVal(M) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="">  void swap(RenamePassData &RHS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">    std::swap(DTN, RHS.DTN);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="">    std::swap(ChildIt, RHS.ChildIt);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="">    std::swap(IncomingVal, RHS.IncomingVal);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">class MemorySSA::ClobberWalkerBase {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">  ClobberWalker Walker;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="">  MemorySSA *MSSA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">  ClobberWalkerBase(MemorySSA *M, DominatorTree *D) : Walker(*M, *D), MSSA(M) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">  MemoryAccess *getClobberingMemoryAccessBase(MemoryAccess *,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">                                              const MemoryLocation &,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">                                              BatchAAResults &, unsigned &);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">  // Third argument (bool), defines whether the clobber search should skip the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">  // original queried access. If true, there will be a follow-up query searching</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">  // for a clobber access past "self". Note that the Optimized access is not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">  // updated if a new clobber is found by this SkipSelf search. If this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">  // additional query becomes heavily used we may decide to cache the result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">  // Walker instantiations will decide how to set the SkipSelf bool.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">  MemoryAccess *getClobberingMemoryAccessBase(MemoryAccess *, BatchAAResults &,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">                                              unsigned &, bool,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">                                              bool UseInvariantGroup = true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">/// A MemorySSAWalker that does AA walks to disambiguate accesses. It no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">/// longer does caching on its own, but the name has been retained for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">/// moment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="">class MemorySSA::CachingWalker final : public MemorySSAWalker {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="">  ClobberWalkerBase *Walker;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="uncoveredLine">  CachingWalker(MemorySSA *M, ClobberWalkerBase *W)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="uncoveredLine">      : MemorySSAWalker(M), Walker(W) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">  ~CachingWalker() override = default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">  using MemorySSAWalker::getClobberingMemoryAccess;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, BatchAAResults &BAA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">                                          unsigned &UWL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">                                          const MemoryLocation &Loc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">                                          BatchAAResults &BAA, unsigned &UWL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="uncoveredLine">    return Walker->getClobberingMemoryAccessBase(MA, Loc, BAA, UWL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">  // This method is not accessible outside of this file.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="uncoveredLine">  MemoryAccess *getClobberingMemoryAccessWithoutInvariantGroup(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="">      MemoryAccess *MA, BatchAAResults &BAA, unsigned &UWL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, false, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="uncoveredLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">                                          BatchAAResults &BAA) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="uncoveredLine">    return getClobberingMemoryAccess(MA, BAA, UpwardWalkLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">                                          const MemoryLocation &Loc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">                                          BatchAAResults &BAA) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="uncoveredLine">    return getClobberingMemoryAccess(MA, Loc, BAA, UpwardWalkLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="uncoveredLine">  void invalidateInfo(MemoryAccess *MA) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="uncoveredLine">      MUD->resetOptimized();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">class MemorySSA::SkipSelfWalker final : public MemorySSAWalker {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">  ClobberWalkerBase *Walker;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">  SkipSelfWalker(MemorySSA *M, ClobberWalkerBase *W)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="uncoveredLine">      : MemorySSAWalker(M), Walker(W) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="uncoveredLine">  ~SkipSelfWalker() override = default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  using MemorySSAWalker::getClobberingMemoryAccess;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, BatchAAResults &BAA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="">                                          unsigned &UWL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="uncoveredLine">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="uncoveredLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">                                          const MemoryLocation &Loc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">                                          BatchAAResults &BAA, unsigned &UWL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="uncoveredLine">    return Walker->getClobberingMemoryAccessBase(MA, Loc, BAA, UWL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="uncoveredLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">                                          BatchAAResults &BAA) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="uncoveredLine">    return getClobberingMemoryAccess(MA, BAA, UpwardWalkLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">                                          const MemoryLocation &Loc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">                                          BatchAAResults &BAA) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="uncoveredLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="uncoveredLine">    return getClobberingMemoryAccess(MA, Loc, BAA, UpwardWalkLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">  void invalidateInfo(MemoryAccess *MA) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="uncoveredLine">      MUD->resetOptimized();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">void MemorySSA::renameSuccessorPhis(BasicBlock *BB, MemoryAccess *IncomingVal,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="">                                    bool RenameAllUses) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="">  // Pass through values to our successors</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="uncoveredLine">  for (const BasicBlock *S : successors(BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="uncoveredLine">    auto It = PerBlockAccesses.find(S);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">    // Rename the phi nodes in our successor block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">    if (It == PerBlockAccesses.end() || !isa<MemoryPhi>(It->second->front()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">    AccessList *Accesses = It->second.get();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">    auto *Phi = cast<MemoryPhi>(&Accesses->front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="uncoveredLine">    if (RenameAllUses) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="uncoveredLine">      bool ReplacementDone = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="uncoveredLine">      for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="uncoveredLine">        if (Phi->getIncomingBlock(I) == BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">          Phi->setIncomingValue(I, IncomingVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">          ReplacementDone = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="">      (void) ReplacementDone;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="uncoveredLine">      assert(ReplacementDone && "Incomplete phi during partial rename");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="">    } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="uncoveredLine">      Phi->addIncoming(IncomingVal, BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">/// Rename a single basic block into MemorySSA form.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">/// Uses the standard SSA renaming algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">/// \returns The new incoming value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="uncoveredLine">MemoryAccess *MemorySSA::renameBlock(BasicBlock *BB, MemoryAccess *IncomingVal,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">                                     bool RenameAllUses) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="uncoveredLine">  auto It = PerBlockAccesses.find(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">  // Skip most processing if the list is empty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">  if (It != PerBlockAccesses.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="uncoveredLine">    AccessList *Accesses = It->second.get();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="uncoveredLine">    for (MemoryAccess &L : *Accesses) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="uncoveredLine">      if (MemoryUseOrDef *MUD = dyn_cast<MemoryUseOrDef>(&L)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="uncoveredLine">        if (MUD->getDefiningAccess() == nullptr || RenameAllUses)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">          MUD->setDefiningAccess(IncomingVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">        if (isa<MemoryDef>(&L))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="uncoveredLine">          IncomingVal = &L;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="uncoveredLine">        IncomingVal = &L;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="uncoveredLine">  return IncomingVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">/// This is the standard SSA renaming algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">/// We walk the dominator tree in preorder, renaming accesses, and then filling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">/// in phi nodes in our successors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="uncoveredLine">void MemorySSA::renamePass(DomTreeNode *Root, MemoryAccess *IncomingVal,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">                           SmallPtrSetImpl<BasicBlock *> &Visited,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">                           bool SkipVisited, bool RenameAllUses) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="uncoveredLine">  assert(Root && "Trying to rename accesses in an unreachable block");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="uncoveredLine">  SmallVector<RenamePassData, 32> WorkStack;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="">  // Skip everything if we already renamed this block and we are skipping.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="">  // Note: You can't sink this into the if, because we need it to occur</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="">  // regardless of whether we skip blocks or not.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">  bool AlreadyVisited = !Visited.insert(Root->getBlock()).second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="uncoveredLine">  if (SkipVisited && AlreadyVisited)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">  IncomingVal = renameBlock(Root->getBlock(), IncomingVal, RenameAllUses);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">  renameSuccessorPhis(Root->getBlock(), IncomingVal, RenameAllUses);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">  WorkStack.push_back({Root, Root->begin(), IncomingVal});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="uncoveredLine">  while (!WorkStack.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="uncoveredLine">    DomTreeNode *Node = WorkStack.back().DTN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="uncoveredLine">    DomTreeNode::const_iterator ChildIt = WorkStack.back().ChildIt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="uncoveredLine">    IncomingVal = WorkStack.back().IncomingVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="uncoveredLine">    if (ChildIt == Node->end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">      WorkStack.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">      DomTreeNode *Child = *ChildIt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">      ++WorkStack.back().ChildIt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="uncoveredLine">      BasicBlock *BB = Child->getBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">      // Note: You can't sink this into the if, because we need it to occur</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="">      // regardless of whether we skip blocks or not.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">      AlreadyVisited = !Visited.insert(BB).second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">      if (SkipVisited && AlreadyVisited) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">        // We already visited this during our renaming, which can happen when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="">        // being asked to rename multiple blocks. Figure out the incoming val,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">        // which is the last def.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">        // Incoming value can only change if there is a block def, and in that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">        // case, it's the last block def in the list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">        if (auto *BlockDefs = getWritableBlockDefs(BB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="uncoveredLine">          IncomingVal = &*BlockDefs->rbegin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="uncoveredLine">      } else</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">        IncomingVal = renameBlock(BB, IncomingVal, RenameAllUses);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="uncoveredLine">      renameSuccessorPhis(BB, IncomingVal, RenameAllUses);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="uncoveredLine">      WorkStack.push_back({Child, Child->begin(), IncomingVal});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">/// This handles unreachable block accesses by deleting phi nodes in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">/// unreachable blocks, and marking all other unreachable MemoryAccess's as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">/// being uses of the live on entry definition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">void MemorySSA::markUnreachableAsLiveOnEntry(BasicBlock *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="uncoveredLine">  assert(!DT->isReachableFromEntry(BB) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="">         "Reachable block found while handling unreachable blocks");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">  // Make sure phi nodes in our reachable successors end up with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">  // LiveOnEntryDef for our incoming edge, even though our block is forward</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">  // unreachable.  We could just disconnect these blocks from the CFG fully,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">  // but we do not right now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="uncoveredLine">  for (const BasicBlock *S : successors(BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="uncoveredLine">    if (!DT->isReachableFromEntry(S))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="uncoveredLine">    auto It = PerBlockAccesses.find(S);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="">    // Rename the phi nodes in our successor block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">    if (It == PerBlockAccesses.end() || !isa<MemoryPhi>(It->second->front()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="uncoveredLine">    AccessList *Accesses = It->second.get();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">    auto *Phi = cast<MemoryPhi>(&Accesses->front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="uncoveredLine">    Phi->addIncoming(LiveOnEntryDef.get(), BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="uncoveredLine">  auto It = PerBlockAccesses.find(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="uncoveredLine">  if (It == PerBlockAccesses.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">  auto &Accesses = It->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="uncoveredLine">  for (auto AI = Accesses->begin(), AE = Accesses->end(); AI != AE;) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="uncoveredLine">    auto Next = std::next(AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">    // If we have a phi, just remove it. We are going to replace all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">    // users with live on entry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="uncoveredLine">    if (auto *UseOrDef = dyn_cast<MemoryUseOrDef>(AI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="uncoveredLine">      UseOrDef->setDefiningAccess(LiveOnEntryDef.get());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="uncoveredLine">      Accesses->erase(AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="uncoveredLine">    AI = Next;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="uncoveredLine">MemorySSA::MemorySSA(Function &Func, AliasAnalysis *AA, DominatorTree *DT)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="uncoveredLine">    : DT(DT), F(Func), LiveOnEntryDef(nullptr), Walker(nullptr),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">      SkipWalker(nullptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">  // Build MemorySSA using a batch alias analysis. This reuses the internal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">  // state that AA collects during an alias()/getModRefInfo() call. This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">  // safe because there are no CFG changes while building MemorySSA and can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">  // significantly reduce the time spent by the compiler in AA, because we will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">  // make queries about all the instructions in the Function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">  assert(AA && "No alias analysis?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="uncoveredLine">  BatchAAResults BatchAA(*AA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="uncoveredLine">  buildMemorySSA(BatchAA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">  // Intentionally leave AA to nullptr while building so we don't accidently</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">  // use non-batch AliasAnalysis.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="uncoveredLine">  this->AA = AA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">  // Also create the walker here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="uncoveredLine">  getWalker();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="uncoveredLine">MemorySSA::~MemorySSA() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">  // Drop all our references</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="uncoveredLine">  for (const auto &Pair : PerBlockAccesses)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="uncoveredLine">    for (MemoryAccess &MA : *Pair.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="uncoveredLine">      MA.dropAllReferences();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="uncoveredLine">MemorySSA::AccessList *MemorySSA::getOrCreateAccessList(const BasicBlock *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="uncoveredLine">  auto Res = PerBlockAccesses.insert(std::make_pair(BB, nullptr));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="uncoveredLine">  if (Res.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="uncoveredLine">    Res.first->second = std::make_unique<AccessList>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="uncoveredLine">  return Res.first->second.get();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="uncoveredLine">MemorySSA::DefsList *MemorySSA::getOrCreateDefsList(const BasicBlock *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="uncoveredLine">  auto Res = PerBlockDefs.insert(std::make_pair(BB, nullptr));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="uncoveredLine">  if (Res.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">    Res.first->second = std::make_unique<DefsList>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">  return Res.first->second.get();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">/// This class is a batch walker of all MemoryUse's in the program, and points</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">/// their defining access at the thing that actually clobbers them.  Because it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">/// is a batch walker that touches everything, it does not operate like the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="">/// other walkers.  This walker is basically performing a top-down SSA renaming</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">/// pass, where the version stack is used as the cache.  This enables it to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">/// significantly more time and memory efficient than using the regular walker,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">/// which is walking bottom-up.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">class MemorySSA::OptimizeUses {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="uncoveredLine">  OptimizeUses(MemorySSA *MSSA, CachingWalker *Walker, BatchAAResults *BAA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">               DominatorTree *DT)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="uncoveredLine">      : MSSA(MSSA), Walker(Walker), AA(BAA), DT(DT) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">  void optimizeUses();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">  /// This represents where a given memorylocation is in the stack.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">  struct MemlocStackInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">    // This essentially is keeping track of versions of the stack. Whenever</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">    // the stack changes due to pushes or pops, these versions increase.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">    unsigned long StackEpoch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">    unsigned long PopEpoch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="">    // This is the lower bound of places on the stack to check. It is equal to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">    // the place the last stack walk ended.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">    // Note: Correctness depends on this being initialized to 0, which densemap</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">    // does</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">    unsigned long LowerBound;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="">    const BasicBlock *LowerBoundBlock;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">    // This is where the last walk for this memory location ended.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="">    unsigned long LastKill;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">    bool LastKillValid;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">  void optimizeUsesInBlock(const BasicBlock *, unsigned long &, unsigned long &,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">                           SmallVectorImpl<MemoryAccess *> &,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">                           DenseMap<MemoryLocOrCall, MemlocStackInfo> &);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">  MemorySSA *MSSA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="">  CachingWalker *Walker;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">  BatchAAResults *AA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">  DominatorTree *DT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">/// Optimize the uses in a given block This is basically the SSA renaming</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">/// algorithm, with one caveat: We are able to use a single stack for all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">/// MemoryUses.  This is because the set of *possible* reaching MemoryDefs is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">/// the same for every MemoryUse.  The *actual* clobbering MemoryDef is just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">/// going to be some position in that stack of possible ones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">/// We track the stack positions that each MemoryLocation needs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">/// to check, and last ended at.  This is because we only want to check the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">/// things that changed since last time.  The same MemoryLocation should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">/// get clobbered by the same store (getModRefInfo does not use invariantness or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">/// things like this, and if they start, we can modify MemoryLocOrCall to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="">/// include relevant data)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="uncoveredLine">void MemorySSA::OptimizeUses::optimizeUsesInBlock(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="">    const BasicBlock *BB, unsigned long &StackEpoch, unsigned long &PopEpoch,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">    SmallVectorImpl<MemoryAccess *> &VersionStack,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">    DenseMap<MemoryLocOrCall, MemlocStackInfo> &LocStackInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">  /// If no accesses, nothing to do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="uncoveredLine">  MemorySSA::AccessList *Accesses = MSSA->getWritableBlockAccesses(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="uncoveredLine">  if (Accesses == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="">  // Pop everything that doesn't dominate the current block off the stack,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="">  // increment the PopEpoch to account for this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">  while (true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="uncoveredLine">    assert(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">        !VersionStack.empty() &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">        "Version stack should have liveOnEntry sentinel dominating everything");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">    BasicBlock *BackBlock = VersionStack.back()->getBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="uncoveredLine">    if (DT->dominates(BackBlock, BB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="uncoveredLine">    while (VersionStack.back()->getBlock() == BackBlock)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">      VersionStack.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">    ++PopEpoch;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="uncoveredLine">  for (MemoryAccess &MA : *Accesses) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="uncoveredLine">    auto *MU = dyn_cast<MemoryUse>(&MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="uncoveredLine">    if (!MU) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="uncoveredLine">      VersionStack.push_back(&MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">      ++StackEpoch;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="uncoveredLine">    if (MU->isOptimized())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="uncoveredLine">    MemoryLocOrCall UseMLOC(MU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="uncoveredLine">    auto &LocInfo = LocStackInfo[UseMLOC];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="">    // If the pop epoch changed, it means we've removed stuff from top of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="">    // stack due to changing blocks. We may have to reset the lower bound or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="">    // last kill info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">    if (LocInfo.PopEpoch != PopEpoch) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">      LocInfo.PopEpoch = PopEpoch;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">      LocInfo.StackEpoch = StackEpoch;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="">      // If the lower bound was in something that no longer dominates us, we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="">      // have to reset it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="">      // We can't simply track stack size, because the stack may have had</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="">      // pushes/pops in the meantime.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">      // XXX: This is non-optimal, but only is slower cases with heavily</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">      // branching dominator trees.  To get the optimal number of queries would</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">      // be to make lowerbound and lastkill a per-loc stack, and pop it until</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">      // the top of that stack dominates us.  This does not seem worth it ATM.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">      // A much cheaper optimization would be to always explore the deepest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="">      // branch of the dominator tree first. This will guarantee this resets on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="">      // the smallest set of blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">      if (LocInfo.LowerBoundBlock && LocInfo.LowerBoundBlock != BB &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="uncoveredLine">          !DT->dominates(LocInfo.LowerBoundBlock, BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">        // Reset the lower bound of things to check.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">        // TODO: Some day we should be able to reset to last kill, rather than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="">        // 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="uncoveredLine">        LocInfo.LowerBound = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="uncoveredLine">        LocInfo.LowerBoundBlock = VersionStack[0]->getBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="uncoveredLine">        LocInfo.LastKillValid = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="uncoveredLine">    } else if (LocInfo.StackEpoch != StackEpoch) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">      // If all that has changed is the StackEpoch, we only have to check the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">      // new things on the stack, because we've checked everything before.  In</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="">      // this case, the lower bound of things to check remains the same.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="uncoveredLine">      LocInfo.PopEpoch = PopEpoch;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="uncoveredLine">      LocInfo.StackEpoch = StackEpoch;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="uncoveredLine">    if (!LocInfo.LastKillValid) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="uncoveredLine">      LocInfo.LastKill = VersionStack.size() - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="uncoveredLine">      LocInfo.LastKillValid = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="">    // At this point, we should have corrected last kill and LowerBound to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="">    // in bounds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="uncoveredLine">    assert(LocInfo.LowerBound < VersionStack.size() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="">           "Lower bound out of range");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="uncoveredLine">    assert(LocInfo.LastKill < VersionStack.size() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">           "Last kill info out of range");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">    // In any case, the new upper bound is the top of the stack.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="uncoveredLine">    unsigned long UpperBound = VersionStack.size() - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">    if (UpperBound - LocInfo.LowerBound > MaxCheckLimit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "MemorySSA skipping optimization of " << *MU << " ("</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">                        << *(MU->getMemoryInst()) << ")"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">                        << " because there are "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">                        << UpperBound - LocInfo.LowerBound</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">                        << " stores to disambiguate\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="">      // Because we did not walk, LastKill is no longer valid, as this may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">      // have been a kill.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="uncoveredLine">      LocInfo.LastKillValid = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="uncoveredLine">    bool FoundClobberResult = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="uncoveredLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="uncoveredLine">    while (UpperBound > LocInfo.LowerBound) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="uncoveredLine">      if (isa<MemoryPhi>(VersionStack[UpperBound])) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">        // For phis, use the walker, see where we ended up, go there.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">        // The invariant.group handling in MemorySSA is ad-hoc and doesn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">        // support updates, so don't use it to optimize uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="">        MemoryAccess *Result =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="uncoveredLine">            Walker->getClobberingMemoryAccessWithoutInvariantGroup(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="uncoveredLine">                MU, *AA, UpwardWalkLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="">        // We are guaranteed to find it or something is wrong.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="uncoveredLine">        while (VersionStack[UpperBound] != Result) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="uncoveredLine">          assert(UpperBound != 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="uncoveredLine">          --UpperBound;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">        FoundClobberResult = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="uncoveredLine">      MemoryDef *MD = cast<MemoryDef>(VersionStack[UpperBound]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="uncoveredLine">      if (instructionClobbersQuery(MD, MU, UseMLOC, *AA)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="uncoveredLine">        FoundClobberResult = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="uncoveredLine">      --UpperBound;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">    // At the end of this loop, UpperBound is either a clobber, or lower bound</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="">    // PHI walking may cause it to be < LowerBound, and in fact, < LastKill.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="uncoveredLine">    if (FoundClobberResult || UpperBound < LocInfo.LastKill) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="uncoveredLine">      MU->setDefiningAccess(VersionStack[UpperBound], true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="uncoveredLine">      LocInfo.LastKill = UpperBound;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">      // Otherwise, we checked all the new ones, and now we know we can get to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="">      // LastKill.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">      MU->setDefiningAccess(VersionStack[LocInfo.LastKill], true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="uncoveredLine">    LocInfo.LowerBound = VersionStack.size() - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="uncoveredLine">    LocInfo.LowerBoundBlock = BB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">/// Optimize uses to point to their actual clobbering definitions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="uncoveredLine">void MemorySSA::OptimizeUses::optimizeUses() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="uncoveredLine">  SmallVector<MemoryAccess *, 16> VersionStack;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="uncoveredLine">  DenseMap<MemoryLocOrCall, MemlocStackInfo> LocStackInfo;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">  VersionStack.push_back(MSSA->getLiveOnEntryDef());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="uncoveredLine">  unsigned long StackEpoch = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="uncoveredLine">  unsigned long PopEpoch = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">  // We perform a non-recursive top-down dominator tree walk.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="uncoveredLine">  for (const auto *DomNode : depth_first(DT->getRootNode()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="uncoveredLine">    optimizeUsesInBlock(DomNode->getBlock(), StackEpoch, PopEpoch, VersionStack,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="uncoveredLine">                        LocStackInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="uncoveredLine">void MemorySSA::placePHINodes(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="">    const SmallPtrSetImpl<BasicBlock *> &DefiningBlocks) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="">  // Determine where our MemoryPhi's should go</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="uncoveredLine">  ForwardIDFCalculator IDFs(*DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="uncoveredLine">  IDFs.setDefiningBlocks(DefiningBlocks);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="uncoveredLine">  SmallVector<BasicBlock *, 32> IDFBlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="uncoveredLine">  IDFs.calculate(IDFBlocks);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">  // Now place MemoryPhi nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="uncoveredLine">  for (auto &BB : IDFBlocks)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="uncoveredLine">    createMemoryPhi(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">void MemorySSA::buildMemorySSA(BatchAAResults &BAA) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">  // We create an access to represent "live on entry", for things like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">  // arguments or users of globals, where the memory they use is defined before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="">  // the beginning of the function. We do not actually insert it into the IR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="">  // We do not define a live on exit for the immediate uses, and thus our</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="">  // semantics do *not* imply that something with no immediate uses can simply</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="">  // be removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="uncoveredLine">  BasicBlock &StartingPoint = F.getEntryBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="uncoveredLine">  LiveOnEntryDef.reset(new MemoryDef(F.getContext(), nullptr, nullptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">                                     &StartingPoint, NextID++));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="">  // We maintain lists of memory accesses per-block, trading memory for time. We</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">  // could just look up the memory access for every possible instruction in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">  // stream.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="uncoveredLine">  SmallPtrSet<BasicBlock *, 32> DefiningBlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">  // Go through each block, figure out where defs occur, and chain together all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="">  // the accesses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="uncoveredLine">  for (BasicBlock &B : F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">    bool InsertIntoDef = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="uncoveredLine">    AccessList *Accesses = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="uncoveredLine">    DefsList *Defs = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="uncoveredLine">    for (Instruction &I : B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">      MemoryUseOrDef *MUD = createNewAccess(&I, &BAA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="uncoveredLine">      if (!MUD)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="uncoveredLine">      if (!Accesses)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="uncoveredLine">        Accesses = getOrCreateAccessList(&B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="uncoveredLine">      Accesses->push_back(MUD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="uncoveredLine">      if (isa<MemoryDef>(MUD)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="uncoveredLine">        InsertIntoDef = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="uncoveredLine">        if (!Defs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="uncoveredLine">          Defs = getOrCreateDefsList(&B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="uncoveredLine">        Defs->push_back(*MUD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="uncoveredLine">    if (InsertIntoDef)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="uncoveredLine">      DefiningBlocks.insert(&B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="uncoveredLine">  placePHINodes(DefiningBlocks);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="">  // Now do regular SSA renaming on the MemoryDef/MemoryUse. Visited will get</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="">  // filled in with all blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="uncoveredLine">  SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="uncoveredLine">  renamePass(DT->getRootNode(), LiveOnEntryDef.get(), Visited);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="">  // Mark the uses in unreachable blocks as live on entry, so that they go</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="">  // somewhere.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="uncoveredLine">  for (auto &BB : F)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="uncoveredLine">    if (!Visited.count(&BB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">      markUnreachableAsLiveOnEntry(&BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="uncoveredLine">MemorySSAWalker *MemorySSA::getWalker() { return getWalkerImpl(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="uncoveredLine">MemorySSA::CachingWalker *MemorySSA::getWalkerImpl() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="uncoveredLine">  if (Walker)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="uncoveredLine">    return Walker.get();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="uncoveredLine">  if (!WalkerBase)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="uncoveredLine">    WalkerBase = std::make_unique<ClobberWalkerBase>(this, DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="uncoveredLine">  Walker = std::make_unique<CachingWalker>(this, WalkerBase.get());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="uncoveredLine">  return Walker.get();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="uncoveredLine">MemorySSAWalker *MemorySSA::getSkipSelfWalker() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="uncoveredLine">  if (SkipWalker)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="uncoveredLine">    return SkipWalker.get();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="uncoveredLine">  if (!WalkerBase)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="uncoveredLine">    WalkerBase = std::make_unique<ClobberWalkerBase>(this, DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="uncoveredLine">  SkipWalker = std::make_unique<SkipSelfWalker>(this, WalkerBase.get());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="uncoveredLine">  return SkipWalker.get();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class=""> }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">// This is a helper function used by the creation routines. It places NewAccess</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="">// into the access and defs lists for a given basic block, at the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="">// insertion point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="uncoveredLine">void MemorySSA::insertIntoListsForBlock(MemoryAccess *NewAccess,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">                                        const BasicBlock *BB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">                                        InsertionPlace Point) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="uncoveredLine">  auto *Accesses = getOrCreateAccessList(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="uncoveredLine">  if (Point == Beginning) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="">    // If it's a phi node, it goes first, otherwise, it goes after any phi</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">    // nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="uncoveredLine">    if (isa<MemoryPhi>(NewAccess)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="uncoveredLine">      Accesses->push_front(NewAccess);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="uncoveredLine">      auto *Defs = getOrCreateDefsList(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">      Defs->push_front(*NewAccess);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="uncoveredLine">      auto AI = find_if_not(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="uncoveredLine">          *Accesses, [](const MemoryAccess &MA) { return isa<MemoryPhi>(MA); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="uncoveredLine">      Accesses->insert(AI, NewAccess);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="uncoveredLine">      if (!isa<MemoryUse>(NewAccess)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="uncoveredLine">        auto *Defs = getOrCreateDefsList(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="uncoveredLine">        auto DI = find_if_not(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="uncoveredLine">            *Defs, [](const MemoryAccess &MA) { return isa<MemoryPhi>(MA); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="uncoveredLine">        Defs->insert(DI, *NewAccess);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">    Accesses->push_back(NewAccess);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="uncoveredLine">    if (!isa<MemoryUse>(NewAccess)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="uncoveredLine">      auto *Defs = getOrCreateDefsList(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="uncoveredLine">      Defs->push_back(*NewAccess);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="uncoveredLine">  BlockNumberingValid.erase(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="uncoveredLine">void MemorySSA::insertIntoListsBefore(MemoryAccess *What, const BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">                                      AccessList::iterator InsertPt) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="uncoveredLine">  auto *Accesses = getWritableBlockAccesses(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="uncoveredLine">  bool WasEnd = InsertPt == Accesses->end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="uncoveredLine">  Accesses->insert(AccessList::iterator(InsertPt), What);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="uncoveredLine">  if (!isa<MemoryUse>(What)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="uncoveredLine">    auto *Defs = getOrCreateDefsList(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="">    // If we got asked to insert at the end, we have an easy job, just shove it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="">    // at the end. If we got asked to insert before an existing def, we also get</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="">    // an iterator. If we got asked to insert before a use, we have to hunt for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="">    // the next def.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="uncoveredLine">    if (WasEnd) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="uncoveredLine">      Defs->push_back(*What);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="uncoveredLine">    } else if (isa<MemoryDef>(InsertPt)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="uncoveredLine">      Defs->insert(InsertPt->getDefsIterator(), *What);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="uncoveredLine">      while (InsertPt != Accesses->end() && !isa<MemoryDef>(InsertPt))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="uncoveredLine">        ++InsertPt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="">      // Either we found a def, or we are inserting at the end</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="uncoveredLine">      if (InsertPt == Accesses->end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="uncoveredLine">        Defs->push_back(*What);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">        Defs->insert(InsertPt->getDefsIterator(), *What);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="uncoveredLine">  BlockNumberingValid.erase(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="uncoveredLine">void MemorySSA::prepareForMoveTo(MemoryAccess *What, BasicBlock *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="">  // Keep it in the lookup tables, remove from the lists</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="uncoveredLine">  removeFromLists(What, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">  // Note that moving should implicitly invalidate the optimized state of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="">  // MemoryUse (and Phis can't be optimized). However, it doesn't do so for a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="">  // MemoryDef.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="uncoveredLine">  if (auto *MD = dyn_cast<MemoryDef>(What))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="uncoveredLine">    MD->resetOptimized();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="uncoveredLine">  What->setBlock(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">// Move What before Where in the IR.  The end result is that What will belong to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="">// the right lists and have the right Block set, but will not otherwise be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="">// correct. It will not have the right defining access, and if it is a def,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="">// things below it will not properly be updated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="uncoveredLine">void MemorySSA::moveTo(MemoryUseOrDef *What, BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="">                       AccessList::iterator Where) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="uncoveredLine">  prepareForMoveTo(What, BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">  insertIntoListsBefore(What, BB, Where);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="uncoveredLine">void MemorySSA::moveTo(MemoryAccess *What, BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="">                       InsertionPlace Point) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="uncoveredLine">  if (isa<MemoryPhi>(What)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="uncoveredLine">    assert(Point == Beginning &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="">           "Can only move a Phi at the beginning of the block");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="">    // Update lookup table entry</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="uncoveredLine">    ValueToMemoryAccess.erase(What->getBlock());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="uncoveredLine">    bool Inserted = ValueToMemoryAccess.insert({BB, What}).second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">    (void)Inserted;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="uncoveredLine">    assert(Inserted && "Cannot move a Phi to a block that already has one");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">  prepareForMoveTo(What, BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="uncoveredLine">  insertIntoListsForBlock(What, BB, Point);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="uncoveredLine">MemoryPhi *MemorySSA::createMemoryPhi(BasicBlock *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="uncoveredLine">  assert(!getMemoryAccess(BB) && "MemoryPhi already exists for this BB");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="uncoveredLine">  MemoryPhi *Phi = new MemoryPhi(BB->getContext(), BB, NextID++);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="">  // Phi's always are placed at the front of the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="uncoveredLine">  insertIntoListsForBlock(Phi, BB, Beginning);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="uncoveredLine">  ValueToMemoryAccess[BB] = Phi;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="uncoveredLine">  return Phi;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="uncoveredLine">MemoryUseOrDef *MemorySSA::createDefinedAccess(Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="">                                               MemoryAccess *Definition,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="">                                               const MemoryUseOrDef *Template,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="">                                               bool CreationMustSucceed) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="uncoveredLine">  assert(!isa<PHINode>(I) && "Cannot create a defined access for a PHI");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="uncoveredLine">  MemoryUseOrDef *NewAccess = createNewAccess(I, AA, Template);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="uncoveredLine">  if (CreationMustSucceed)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="uncoveredLine">    assert(NewAccess != nullptr && "Tried to create a memory access for a "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="">                                   "non-memory touching instruction");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="uncoveredLine">  if (NewAccess) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="uncoveredLine">    assert((!Definition || !isa<MemoryUse>(Definition)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="">           "A use cannot be a defining access");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">    NewAccess->setDefiningAccess(Definition);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="uncoveredLine">  return NewAccess;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="">// Return true if the instruction has ordering constraints.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="">// Note specifically that this only considers stores and loads</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="">// because others are still considered ModRef by getModRefInfo.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="uncoveredLine">static inline bool isOrdered(const Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="uncoveredLine">  if (auto *SI = dyn_cast<StoreInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="uncoveredLine">    if (!SI->isUnordered())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="uncoveredLine">  } else if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">    if (!LI->isUnordered())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="">/// Helper function to create new memory accesses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="">template <typename AliasAnalysisType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="uncoveredLine">MemoryUseOrDef *MemorySSA::createNewAccess(Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="">                                           AliasAnalysisType *AAP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="">                                           const MemoryUseOrDef *Template) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="">  // The assume intrinsic has a control dependency which we model by claiming</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">  // that it writes arbitrarily. Debuginfo intrinsics may be considered</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">  // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="">  // dependencies here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="">  // FIXME: Replace this special casing with a more accurate modelling of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="">  // assume's control dependency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="uncoveredLine">  if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="uncoveredLine">    switch (II->getIntrinsicID()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="uncoveredLine">    case Intrinsic::assume:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="">    case Intrinsic::experimental_noalias_scope_decl:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="">    case Intrinsic::pseudoprobe:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="">  // Using a nonstandard AA pipelines might leave us with unexpected modref</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">  // results for I, so add a check to not model instructions that may not read</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="">  // from or write to memory. This is necessary for correctness.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="uncoveredLine">  if (!I->mayReadFromMemory() && !I->mayWriteToMemory())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="">  bool Def, Use;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="uncoveredLine">  if (Template) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="uncoveredLine">    Def = isa<MemoryDef>(Template);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="uncoveredLine">    Use = isa<MemoryUse>(Template);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="">#if !defined(NDEBUG)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="uncoveredLine">    ModRefInfo ModRef = AAP->getModRefInfo(I, std::nullopt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="">    bool DefCheck, UseCheck;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="uncoveredLine">    DefCheck = isModSet(ModRef) || isOrdered(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="uncoveredLine">    UseCheck = isRefSet(ModRef);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="">    // Memory accesses should only be reduced and can not be increased since AA</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="">    // just might return better results as a result of some transformations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">    assert((Def == DefCheck || !DefCheck) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="">           "Memory accesses should only be reduced");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="uncoveredLine">    if (!Def && Use != UseCheck) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="">      // New Access should not have more power than template access</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="uncoveredLine">      assert(!UseCheck && "Invalid template");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="">    // Find out what affect this instruction has on memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="uncoveredLine">    ModRefInfo ModRef = AAP->getModRefInfo(I, std::nullopt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="">    // The isOrdered check is used to ensure that volatiles end up as defs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">    // (atomics end up as ModRef right now anyway).  Until we separate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">    // ordering chain from the memory chain, this enables people to see at least</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="">    // some relative ordering to volatiles.  Note that getClobberingMemoryAccess</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="">    // will still give an answer that bypasses other volatile loads.  TODO:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="">    // Separate memory aliasing and ordering into two different chains so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">    // we can precisely represent both "what memory will this read/write/is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="">    // clobbered by" and "what instructions can I move this past".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">    Def = isModSet(ModRef) || isOrdered(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="uncoveredLine">    Use = isRefSet(ModRef);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="">  // It's possible for an instruction to not modify memory at all. During</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">  // construction, we ignore them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">  if (!Def && !Use)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="">  MemoryUseOrDef *MUD;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="uncoveredLine">  if (Def) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="uncoveredLine">    MUD = new MemoryDef(I->getContext(), nullptr, I, I->getParent(), NextID++);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="uncoveredLine">    MUD = new MemoryUse(I->getContext(), nullptr, I, I->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="uncoveredLine">    if (isUseTriviallyOptimizableToLiveOnEntry(*AAP, I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="uncoveredLine">      MemoryAccess *LiveOnEntry = getLiveOnEntryDef();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="uncoveredLine">      MUD->setOptimized(LiveOnEntry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="uncoveredLine">  ValueToMemoryAccess[I] = MUD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="uncoveredLine">  return MUD;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="">/// Properly remove \p MA from all of MemorySSA's lookup tables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="uncoveredLine">void MemorySSA::removeFromLookups(MemoryAccess *MA) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="uncoveredLine">  assert(MA->use_empty() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="">         "Trying to remove memory access that still has uses");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="uncoveredLine">  BlockNumbering.erase(MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="uncoveredLine">  if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">    MUD->setDefiningAccess(nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="">  // Invalidate our walker's cache if necessary</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="uncoveredLine">  if (!isa<MemoryUse>(MA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="uncoveredLine">    getWalker()->invalidateInfo(MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="">  Value *MemoryInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="uncoveredLine">  if (const auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="uncoveredLine">    MemoryInst = MUD->getMemoryInst();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="uncoveredLine">    MemoryInst = MA->getBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="uncoveredLine">  auto VMA = ValueToMemoryAccess.find(MemoryInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="uncoveredLine">  if (VMA->second == MA)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="uncoveredLine">    ValueToMemoryAccess.erase(VMA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="">/// Properly remove \p MA from all of MemorySSA's lists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="">/// Because of the way the intrusive list and use lists work, it is important to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="">/// do removal in the right order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="">/// ShouldDelete defaults to true, and will cause the memory access to also be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="">/// deleted, not just removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="uncoveredLine">void MemorySSA::removeFromLists(MemoryAccess *MA, bool ShouldDelete) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="uncoveredLine">  BasicBlock *BB = MA->getBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="">  // The access list owns the reference, so we erase it from the non-owning list</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="">  // first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="uncoveredLine">  if (!isa<MemoryUse>(MA)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="uncoveredLine">    auto DefsIt = PerBlockDefs.find(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="uncoveredLine">    std::unique_ptr<DefsList> &Defs = DefsIt->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="uncoveredLine">    Defs->remove(*MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="uncoveredLine">    if (Defs->empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="uncoveredLine">      PerBlockDefs.erase(DefsIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">  // The erase call here will delete it. If we don't want it deleted, we call</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="">  // remove instead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="uncoveredLine">  auto AccessIt = PerBlockAccesses.find(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="uncoveredLine">  std::unique_ptr<AccessList> &Accesses = AccessIt->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="uncoveredLine">  if (ShouldDelete)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="uncoveredLine">    Accesses->erase(MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="uncoveredLine">    Accesses->remove(MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="uncoveredLine">  if (Accesses->empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="uncoveredLine">    PerBlockAccesses.erase(AccessIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="uncoveredLine">    BlockNumberingValid.erase(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="uncoveredLine">void MemorySSA::print(raw_ostream &OS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="uncoveredLine">  MemorySSAAnnotatedWriter Writer(this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="uncoveredLine">  F.print(OS, &Writer);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="uncoveredLine">LLVM_DUMP_METHOD void MemorySSA::dump() const { print(dbgs()); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="uncoveredLine">void MemorySSA::verifyMemorySSA(VerificationLevel VL) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="">#if !defined(NDEBUG) && defined(EXPENSIVE_CHECKS)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="">  VL = VerificationLevel::Full;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="uncoveredLine">  verifyOrderingDominationAndDefUses(F, VL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="uncoveredLine">  verifyDominationNumbers(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="uncoveredLine">  if (VL == VerificationLevel::Full)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="uncoveredLine">    verifyPrevDefInPhis(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="">  // Previously, the verification used to also verify that the clobberingAccess</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="">  // cached by MemorySSA is the same as the clobberingAccess found at a later</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="">  // query to AA. This does not hold true in general due to the current fragility</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="">  // of BasicAA which has arbitrary caps on the things it analyzes before giving</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="">  // up. As a result, transformations that are correct, will lead to BasicAA</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="">  // returning different Alias answers before and after that transformation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="">  // Invalidating MemorySSA is not an option, as the results in BasicAA can be so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="">  // random, in the worst case we'd need to rebuild MemorySSA from scratch after</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="">  // every transformation, which defeats the purpose of using it. For such an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">  // example, see test4 added in D51960.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="uncoveredLine">void MemorySSA::verifyPrevDefInPhis(Function &F) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="uncoveredLine">  for (const BasicBlock &BB : F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="uncoveredLine">    if (MemoryPhi *Phi = getMemoryAccess(&BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="uncoveredLine">      for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">        auto *Pred = Phi->getIncomingBlock(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="uncoveredLine">        auto *IncAcc = Phi->getIncomingValue(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="">        // If Pred has no unreachable predecessors, get last def looking at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="">        // IDoms. If, while walkings IDoms, any of these has an unreachable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="">        // predecessor, then the incoming def can be any access.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="uncoveredLine">        if (auto *DTNode = DT->getNode(Pred)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="uncoveredLine">          while (DTNode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="uncoveredLine">            if (auto *DefList = getBlockDefs(DTNode->getBlock())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="uncoveredLine">              auto *LastAcc = &*(--DefList->end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="uncoveredLine">              assert(LastAcc == IncAcc &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="">                     "Incorrect incoming access into phi.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">              (void)IncAcc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="">              (void)LastAcc;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="uncoveredLine">              break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="">            }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="uncoveredLine">            DTNode = DTNode->getIDom();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="">          // If Pred has unreachable predecessors, but has at least a Def, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="">          // incoming access can be the last Def in Pred, or it could have been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="">          // optimized to LoE. After an update, though, the LoE may have been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="">          // replaced by another access, so IncAcc may be any access.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="">          // If Pred has unreachable predecessors and no Defs, incoming access</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="">          // should be LoE; However, after an update, it may be any access.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="">/// Verify that all of the blocks we believe to have valid domination numbers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="">/// actually have valid domination numbers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="uncoveredLine">void MemorySSA::verifyDominationNumbers(const Function &F) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="uncoveredLine">  if (BlockNumberingValid.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="uncoveredLine">  SmallPtrSet<const BasicBlock *, 16> ValidBlocks = BlockNumberingValid;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="uncoveredLine">  for (const BasicBlock &BB : F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">    if (!ValidBlocks.count(&BB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">    ValidBlocks.erase(&BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="uncoveredLine">    const AccessList *Accesses = getBlockAccesses(&BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">    // It's correct to say an empty block has valid numbering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="uncoveredLine">    if (!Accesses)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="">    // Block numbering starts at 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="uncoveredLine">    unsigned long LastNumber = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="uncoveredLine">    for (const MemoryAccess &MA : *Accesses) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="uncoveredLine">      auto ThisNumberIter = BlockNumbering.find(&MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="uncoveredLine">      assert(ThisNumberIter != BlockNumbering.end() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="">             "MemoryAccess has no domination number in a valid block!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="uncoveredLine">      unsigned long ThisNumber = ThisNumberIter->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="uncoveredLine">      assert(ThisNumber > LastNumber &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="">             "Domination numbers should be strictly increasing!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">      (void)LastNumber;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="uncoveredLine">      LastNumber = ThisNumber;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="uncoveredLine">  assert(ValidBlocks.empty() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="">         "All valid BasicBlocks should exist in F -- dangling pointers?");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="">/// Verify ordering: the order and existence of MemoryAccesses matches the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="">/// order and existence of memory affecting instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="">/// Verify domination: each definition dominates all of its uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">/// Verify def-uses: the immediate use information - walk all the memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">/// accesses and verifying that, for each use, it appears in the appropriate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="">/// def's use list</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="uncoveredLine">void MemorySSA::verifyOrderingDominationAndDefUses(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="">                                                   VerificationLevel VL) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="">  // Walk all the blocks, comparing what the lookups think and what the access</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="">  // lists think, as well as the order in the blocks vs the order in the access</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="">  // lists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="uncoveredLine">  SmallVector<MemoryAccess *, 32> ActualAccesses;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="uncoveredLine">  SmallVector<MemoryAccess *, 32> ActualDefs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="uncoveredLine">  for (BasicBlock &B : F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="uncoveredLine">    const AccessList *AL = getBlockAccesses(&B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="uncoveredLine">    const auto *DL = getBlockDefs(&B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="uncoveredLine">    MemoryPhi *Phi = getMemoryAccess(&B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="uncoveredLine">    if (Phi) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="">      // Verify ordering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="uncoveredLine">      ActualAccesses.push_back(Phi);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="uncoveredLine">      ActualDefs.push_back(Phi);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="">      // Verify domination</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="uncoveredLine">      for (const Use &U : Phi->uses()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="uncoveredLine">        assert(dominates(Phi, U) && "Memory PHI does not dominate it's uses");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="">        (void)U;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="">      // Verify def-uses for full verify.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="uncoveredLine">      if (VL == VerificationLevel::Full) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="uncoveredLine">        assert(Phi->getNumOperands() == static_cast<unsigned>(std::distance(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="">                                            pred_begin(&B), pred_end(&B))) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">               "Incomplete MemoryPhi Node");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="uncoveredLine">        for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="uncoveredLine">          verifyUseInDefs(Phi->getIncomingValue(I), Phi);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="uncoveredLine">          assert(is_contained(predecessors(&B), Phi->getIncomingBlock(I)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">                 "Incoming phi block not a block predecessor");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="uncoveredLine">    for (Instruction &I : B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="uncoveredLine">      MemoryUseOrDef *MA = getMemoryAccess(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="uncoveredLine">      assert((!MA || (AL && (isa<MemoryUse>(MA) || DL))) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">             "We have memory affecting instructions "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="">             "in this block but they are not in the "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">             "access list or defs list");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="uncoveredLine">      if (MA) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="">        // Verify ordering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="uncoveredLine">        ActualAccesses.push_back(MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="uncoveredLine">        if (MemoryAccess *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="">          // Verify ordering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="uncoveredLine">          ActualDefs.push_back(MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="">          // Verify domination.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="uncoveredLine">          for (const Use &U : MD->uses()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="uncoveredLine">            assert(dominates(MD, U) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="">                   "Memory Def does not dominate it's uses");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">            (void)U;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="">        // Verify def-uses for full verify.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="uncoveredLine">        if (VL == VerificationLevel::Full)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="uncoveredLine">          verifyUseInDefs(MA->getDefiningAccess(), MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">    // Either we hit the assert, really have no accesses, or we have both</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="">    // accesses and an access list. Same with defs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="uncoveredLine">    if (!AL && !DL)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="">    // Verify ordering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="uncoveredLine">    assert(AL->size() == ActualAccesses.size() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="">           "We don't have the same number of accesses in the block as on the "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">           "access list");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="uncoveredLine">    assert((DL || ActualDefs.size() == 0) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="">           "Either we should have a defs list, or we should have no defs");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="uncoveredLine">    assert((!DL || DL->size() == ActualDefs.size()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">           "We don't have the same number of defs in the block as on the "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="">           "def list");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="uncoveredLine">    auto ALI = AL->begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="uncoveredLine">    auto AAI = ActualAccesses.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="uncoveredLine">    while (ALI != AL->end() && AAI != ActualAccesses.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="uncoveredLine">      assert(&*ALI == *AAI && "Not the same accesses in the same order");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="uncoveredLine">      ++ALI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">      ++AAI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="uncoveredLine">    ActualAccesses.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="uncoveredLine">    if (DL) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="uncoveredLine">      auto DLI = DL->begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="uncoveredLine">      auto ADI = ActualDefs.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="uncoveredLine">      while (DLI != DL->end() && ADI != ActualDefs.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="uncoveredLine">        assert(&*DLI == *ADI && "Not the same defs in the same order");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="uncoveredLine">        ++DLI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="uncoveredLine">        ++ADI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="uncoveredLine">    ActualDefs.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="">/// Verify the def-use lists in MemorySSA, by verifying that \p Use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="">/// appears in the use list of \p Def.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="uncoveredLine">void MemorySSA::verifyUseInDefs(MemoryAccess *Def, MemoryAccess *Use) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">  // The live on entry use may cause us to get a NULL def here</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="uncoveredLine">  if (!Def)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="uncoveredLine">    assert(isLiveOnEntryDef(Use) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">           "Null def but use not point to live on entry def");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="uncoveredLine">    assert(is_contained(Def->users(), Use) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="">           "Did not find use in def's use list");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="">/// Perform a local numbering on blocks so that instruction ordering can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="">/// determined in constant time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="">/// TODO: We currently just number in order.  If we numbered by N, we could</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="">/// allow at least N-1 sequences of insertBefore or insertAfter (and at least</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="">/// log2(N) sequences of mixed before and after) without needing to invalidate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="">/// the numbering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="uncoveredLine">void MemorySSA::renumberBlock(const BasicBlock *B) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="">  // The pre-increment ensures the numbers really start at 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="uncoveredLine">  unsigned long CurrentNumber = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="uncoveredLine">  const AccessList *AL = getBlockAccesses(B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="uncoveredLine">  assert(AL != nullptr && "Asking to renumber an empty block");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="uncoveredLine">  for (const auto &I : *AL)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="uncoveredLine">    BlockNumbering[&I] = ++CurrentNumber;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="uncoveredLine">  BlockNumberingValid.insert(B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="">/// Determine, for two memory accesses in the same block,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="">/// whether \p Dominator dominates \p Dominatee.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="">/// \returns True if \p Dominator dominates \p Dominatee.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="uncoveredLine">bool MemorySSA::locallyDominates(const MemoryAccess *Dominator,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="">                                 const MemoryAccess *Dominatee) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="uncoveredLine">  const BasicBlock *DominatorBlock = Dominator->getBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="uncoveredLine">  assert((DominatorBlock == Dominatee->getBlock()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="">         "Asking for local domination when accesses are in different blocks!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="">  // A node dominates itself.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="uncoveredLine">  if (Dominatee == Dominator)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="">  // When Dominatee is defined on function entry, it is not dominated by another</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="">  // memory access.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="uncoveredLine">  if (isLiveOnEntryDef(Dominatee))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="">  // When Dominator is defined on function entry, it dominates the other memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="">  // access.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="uncoveredLine">  if (isLiveOnEntryDef(Dominator))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="uncoveredLine">  if (!BlockNumberingValid.count(DominatorBlock))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="uncoveredLine">    renumberBlock(DominatorBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="uncoveredLine">  unsigned long DominatorNum = BlockNumbering.lookup(Dominator);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="">  // All numbers start with 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="uncoveredLine">  assert(DominatorNum != 0 && "Block was not numbered properly");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="uncoveredLine">  unsigned long DominateeNum = BlockNumbering.lookup(Dominatee);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">  assert(DominateeNum != 0 && "Block was not numbered properly");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="uncoveredLine">  return DominatorNum < DominateeNum;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="uncoveredLine">bool MemorySSA::dominates(const MemoryAccess *Dominator,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="">                          const MemoryAccess *Dominatee) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="uncoveredLine">  if (Dominator == Dominatee)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="uncoveredLine">  if (isLiveOnEntryDef(Dominatee))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="uncoveredLine">  if (Dominator->getBlock() != Dominatee->getBlock())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="uncoveredLine">    return DT->dominates(Dominator->getBlock(), Dominatee->getBlock());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="uncoveredLine">  return locallyDominates(Dominator, Dominatee);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="uncoveredLine">bool MemorySSA::dominates(const MemoryAccess *Dominator,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="">                          const Use &Dominatee) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="uncoveredLine">  if (MemoryPhi *MP = dyn_cast<MemoryPhi>(Dominatee.getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="uncoveredLine">    BasicBlock *UseBB = MP->getIncomingBlock(Dominatee);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="">    // The def must dominate the incoming block of the phi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="uncoveredLine">    if (UseBB != Dominator->getBlock())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="uncoveredLine">      return DT->dominates(Dominator->getBlock(), UseBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="">    // If the UseBB and the DefBB are the same, compare locally.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="uncoveredLine">    return locallyDominates(Dominator, cast<MemoryAccess>(Dominatee));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="">  // If it's not a PHI node use, the normal dominates can already handle it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="uncoveredLine">  return dominates(Dominator, cast<MemoryAccess>(Dominatee.getUser()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="uncoveredLine">void MemorySSA::ensureOptimizedUses() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="uncoveredLine">  if (IsOptimized)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="uncoveredLine">  BatchAAResults BatchAA(*AA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="uncoveredLine">  ClobberWalkerBase WalkerBase(this, DT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="uncoveredLine">  CachingWalker WalkerLocal(this, &WalkerBase);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="uncoveredLine">  OptimizeUses(this, &WalkerLocal, &BatchAA, DT).optimizeUses();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="uncoveredLine">  IsOptimized = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="uncoveredLine">void MemoryAccess::print(raw_ostream &OS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="uncoveredLine">  switch (getValueID()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="uncoveredLine">  case MemoryPhiVal: return static_cast<const MemoryPhi *>(this)->print(OS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="uncoveredLine">  case MemoryDefVal: return static_cast<const MemoryDef *>(this)->print(OS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="uncoveredLine">  case MemoryUseVal: return static_cast<const MemoryUse *>(this)->print(OS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="uncoveredLine">  llvm_unreachable("invalid value id");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="uncoveredLine">void MemoryDef::print(raw_ostream &OS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="uncoveredLine">  MemoryAccess *UO = getDefiningAccess();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="uncoveredLine">  auto printID = [&OS](MemoryAccess *A) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="uncoveredLine">    if (A && A->getID())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="uncoveredLine">      OS << A->getID();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="uncoveredLine">      OS << LiveOnEntryStr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="uncoveredLine">  OS << getID() << " = MemoryDef(";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="uncoveredLine">  printID(UO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="uncoveredLine">  OS << ")";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="uncoveredLine">  if (isOptimized()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="uncoveredLine">    OS << "->";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="uncoveredLine">    printID(getOptimized());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">void MemoryPhi::print(raw_ostream &OS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="uncoveredLine">  ListSeparator LS(",");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="uncoveredLine">  OS << getID() << " = MemoryPhi(";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="uncoveredLine">  for (const auto &Op : operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="uncoveredLine">    BasicBlock *BB = getIncomingBlock(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="uncoveredLine">    MemoryAccess *MA = cast<MemoryAccess>(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="uncoveredLine">    OS << LS << '{';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">    if (BB->hasName())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="uncoveredLine">      OS << BB->getName();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="uncoveredLine">      BB->printAsOperand(OS, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="uncoveredLine">    OS << ',';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="uncoveredLine">    if (unsigned ID = MA->getID())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="uncoveredLine">      OS << ID;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="uncoveredLine">      OS << LiveOnEntryStr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="uncoveredLine">    OS << '}';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="uncoveredLine">  OS << ')';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="uncoveredLine">void MemoryUse::print(raw_ostream &OS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="uncoveredLine">  MemoryAccess *UO = getDefiningAccess();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="uncoveredLine">  OS << "MemoryUse(";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">  if (UO && UO->getID())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="uncoveredLine">    OS << UO->getID();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="uncoveredLine">    OS << LiveOnEntryStr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="uncoveredLine">  OS << ')';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="uncoveredLine">void MemoryAccess::dump() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="">// Cannot completely remove virtual function even in release mode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="uncoveredLine">  print(dbgs());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="uncoveredLine">  dbgs() << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="">class DOTFuncMSSAInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="">  const Function &F;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="">  MemorySSAAnnotatedWriter MSSAWriter;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="uncoveredLine">  DOTFuncMSSAInfo(const Function &F, MemorySSA &MSSA)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="uncoveredLine">      : F(F), MSSAWriter(&MSSA) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="uncoveredLine">  const Function *getFunction() { return &F; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="uncoveredLine">  MemorySSAAnnotatedWriter &getWriter() { return MSSAWriter; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="">template <></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="">struct GraphTraits<DOTFuncMSSAInfo *> : public GraphTraits<const BasicBlock *> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="">  static NodeRef getEntryNode(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="">    return &(CFGInfo->getFunction()->getEntryBlock());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="">  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="">  using nodes_iterator = pointer_iterator<Function::const_iterator>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="uncoveredLine">  static nodes_iterator nodes_begin(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="uncoveredLine">    return nodes_iterator(CFGInfo->getFunction()->begin());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="uncoveredLine">  static nodes_iterator nodes_end(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="uncoveredLine">    return nodes_iterator(CFGInfo->getFunction()->end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">  static size_t size(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="">    return CFGInfo->getFunction()->size();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="">template <></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="">struct DOTGraphTraits<DOTFuncMSSAInfo *> : public DefaultDOTGraphTraits {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="uncoveredLine">  DOTGraphTraits(bool IsSimple = false) : DefaultDOTGraphTraits(IsSimple) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="uncoveredLine">  static std::string getGraphName(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="uncoveredLine">    return "MSSA CFG for '" + CFGInfo->getFunction()->getName().str() +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="uncoveredLine">           "' function";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="uncoveredLine">  std::string getNodeLabel(const BasicBlock *Node, DOTFuncMSSAInfo *CFGInfo) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="">    return DOTGraphTraits<DOTFuncInfo *>::getCompleteNodeLabel(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="">        Node, nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="uncoveredLine">        [CFGInfo](raw_string_ostream &OS, const BasicBlock &BB) -> void {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">          BB.print(OS, &CFGInfo->getWriter(), true, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="uncoveredLine">        },</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="uncoveredLine">        [](std::string &S, unsigned &I, unsigned Idx) -> void {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="uncoveredLine">          std::string Str = S.substr(I, Idx - I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="uncoveredLine">          StringRef SR = Str;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="uncoveredLine">          if (SR.count(" = MemoryDef(") || SR.count(" = MemoryPhi(") ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="uncoveredLine">              SR.count("MemoryUse("))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="uncoveredLine">            return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="uncoveredLine">          DOTGraphTraits<DOTFuncInfo *>::eraseComment(S, I, Idx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="uncoveredLine">        });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="uncoveredLine">  static std::string getEdgeSourceLabel(const BasicBlock *Node,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="">                                        const_succ_iterator I) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="uncoveredLine">    return DOTGraphTraits<DOTFuncInfo *>::getEdgeSourceLabel(Node, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="">  /// Display the raw branch weights from PGO.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="uncoveredLine">  std::string getEdgeAttributes(const BasicBlock *Node, const_succ_iterator I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="">                                DOTFuncMSSAInfo *CFGInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="uncoveredLine">    return "";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="uncoveredLine">  std::string getNodeAttributes(const BasicBlock *Node,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="">                                DOTFuncMSSAInfo *CFGInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="uncoveredLine">    return getNodeLabel(Node, CFGInfo).find(';') != std::string::npos</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="">               ? "style=filled, fillcolor=lightpink"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="uncoveredLine">               : "";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="">} // namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="">AnalysisKey MemorySSAAnalysis::Key;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="uncoveredLine">MemorySSAAnalysis::Result MemorySSAAnalysis::run(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="">                                                 FunctionAnalysisManager &AM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="uncoveredLine">  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="uncoveredLine">  auto &AA = AM.getResult<AAManager>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="uncoveredLine">  return MemorySSAAnalysis::Result(std::make_unique<MemorySSA>(F, &AA, &DT));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="uncoveredLine">bool MemorySSAAnalysis::Result::invalidate(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="">    Function &F, const PreservedAnalyses &PA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">    FunctionAnalysisManager::Invalidator &Inv) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="uncoveredLine">  auto PAC = PA.getChecker<MemorySSAAnalysis>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="uncoveredLine">  return !(PAC.preserved() || PAC.preservedSet<AllAnalysesOn<Function>>()) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="uncoveredLine">         Inv.invalidate<AAManager>(F, PA) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="uncoveredLine">         Inv.invalidate<DominatorTreeAnalysis>(F, PA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="uncoveredLine">PreservedAnalyses MemorySSAPrinterPass::run(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="">                                            FunctionAnalysisManager &AM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="uncoveredLine">  auto &MSSA = AM.getResult<MemorySSAAnalysis>(F).getMSSA();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="uncoveredLine">  if (EnsureOptimizedUses)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="uncoveredLine">    MSSA.ensureOptimizedUses();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="uncoveredLine">  if (DotCFGMSSA != "") {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="uncoveredLine">    DOTFuncMSSAInfo CFGInfo(F, MSSA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="uncoveredLine">    WriteGraph(&CFGInfo, "", false, "MSSA", DotCFGMSSA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="uncoveredLine">    OS << "MemorySSA for function: " << F.getName() << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="uncoveredLine">    MSSA.print(OS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="uncoveredLine">  return PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="uncoveredLine">PreservedAnalyses MemorySSAWalkerPrinterPass::run(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="">                                                  FunctionAnalysisManager &AM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="uncoveredLine">  auto &MSSA = AM.getResult<MemorySSAAnalysis>(F).getMSSA();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="uncoveredLine">  OS << "MemorySSA (walker) for function: " << F.getName() << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="uncoveredLine">  MemorySSAWalkerAnnotatedWriter Writer(&MSSA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="uncoveredLine">  F.print(OS, &Writer);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="uncoveredLine">  return PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="uncoveredLine">PreservedAnalyses MemorySSAVerifierPass::run(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="">                                             FunctionAnalysisManager &AM) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="uncoveredLine">  AM.getResult<MemorySSAAnalysis>(F).getMSSA().verifyMemorySSA();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="uncoveredLine">  return PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="">char MemorySSAWrapperPass::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="uncoveredLine">MemorySSAWrapperPass::MemorySSAWrapperPass() : FunctionPass(ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="uncoveredLine">  initializeMemorySSAWrapperPassPass(*PassRegistry::getPassRegistry());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="uncoveredLine">void MemorySSAWrapperPass::releaseMemory() { MSSA.reset(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="uncoveredLine">void MemorySSAWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="uncoveredLine">  AU.setPreservesAll();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="uncoveredLine">  AU.addRequiredTransitive<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="uncoveredLine">  AU.addRequiredTransitive<AAResultsWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="uncoveredLine">bool MemorySSAWrapperPass::runOnFunction(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="uncoveredLine">  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="uncoveredLine">  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="uncoveredLine">  MSSA.reset(new MemorySSA(F, &AA, &DT));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="uncoveredLine">void MemorySSAWrapperPass::verifyAnalysis() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="uncoveredLine">  if (VerifyMemorySSA)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="uncoveredLine">    MSSA->verifyMemorySSA();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="uncoveredLine">void MemorySSAWrapperPass::print(raw_ostream &OS, const Module *M) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="uncoveredLine">  MSSA->print(OS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="uncoveredLine">MemorySSAWalker::MemorySSAWalker(MemorySSA *M) : MSSA(M) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="">/// Walk the use-def chains starting at \p StartingAccess and find</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="">/// the MemoryAccess that actually clobbers Loc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="">/// \returns our clobbering memory access</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="uncoveredLine">MemoryAccess *MemorySSA::ClobberWalkerBase::getClobberingMemoryAccessBase(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="">    MemoryAccess *StartingAccess, const MemoryLocation &Loc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="">    BatchAAResults &BAA, unsigned &UpwardWalkLimit) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="uncoveredLine">  assert(!isa<MemoryUse>(StartingAccess) && "Use cannot be defining access");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="uncoveredLine">  Instruction *I = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="uncoveredLine">  if (auto *StartingUseOrDef = dyn_cast<MemoryUseOrDef>(StartingAccess)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="uncoveredLine">    if (MSSA->isLiveOnEntryDef(StartingUseOrDef))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="uncoveredLine">      return StartingUseOrDef;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="uncoveredLine">    I = StartingUseOrDef->getMemoryInst();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="">    // Conservatively, fences are always clobbers, so don't perform the walk if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="">    // we hit a fence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="uncoveredLine">    if (!isa<CallBase>(I) && I->isFenceLike())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="uncoveredLine">      return StartingUseOrDef;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="uncoveredLine">  UpwardsMemoryQuery Q;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="uncoveredLine">  Q.OriginalAccess = StartingAccess;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="uncoveredLine">  Q.StartingLoc = Loc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="uncoveredLine">  Q.Inst = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="uncoveredLine">  Q.IsCall = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="">  // Unlike the other function, do not walk to the def of a def, because we are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="">  // handed something we already believe is the clobbering access.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="">  // We never set SkipSelf to true in Q in this method.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="">  MemoryAccess *Clobber =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="uncoveredLine">      Walker.findClobber(BAA, StartingAccess, Q, UpwardWalkLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="">    dbgs() << "Clobber starting at access " << *StartingAccess << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="">    if (I)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="">      dbgs() << "  for instruction " << *I << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="">    dbgs() << "  is " << *Clobber << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="uncoveredLine">  return Clobber;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="">static const Instruction *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="uncoveredLine">getInvariantGroupClobberingInstruction(Instruction &I, DominatorTree &DT) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="uncoveredLine">  if (!I.hasMetadata(LLVMContext::MD_invariant_group) || I.isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="">  // We consider bitcasts and zero GEPs to be the same pointer value. Start by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="">  // stripping bitcasts and zero GEPs, then we will recursively look at loads</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="">  // and stores through bitcasts and zero GEPs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="uncoveredLine">  Value *PointerOperand = getLoadStorePointerOperand(&I)->stripPointerCasts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="">  // It's not safe to walk the use list of a global value because function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="">  // passes aren't allowed to look outside their functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="">  // FIXME: this could be fixed by filtering instructions from outside of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="">  // current function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="uncoveredLine">  if (isa<Constant>(PointerOperand))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="">  // Queue to process all pointers that are equivalent to load operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="uncoveredLine">  SmallVector<const Value *, 8> PointerUsesQueue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="uncoveredLine">  PointerUsesQueue.push_back(PointerOperand);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="uncoveredLine">  const Instruction *MostDominatingInstruction = &I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="">  // FIXME: This loop is O(n^2) because dominates can be O(n) and in worst case</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="">  // we will see all the instructions. It may not matter in practice. If it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="">  // does, we will have to support MemorySSA construction and updates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="uncoveredLine">  while (!PointerUsesQueue.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="uncoveredLine">    const Value *Ptr = PointerUsesQueue.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="uncoveredLine">    assert(Ptr && !isa<GlobalValue>(Ptr) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="">           "Null or GlobalValue should not be inserted");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="uncoveredLine">    for (const User *Us : Ptr->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="uncoveredLine">      auto *U = dyn_cast<Instruction>(Us);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="uncoveredLine">      if (!U || U == &I || !DT.dominates(U, MostDominatingInstruction))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="">      // Add bitcasts and zero GEPs to queue.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="uncoveredLine">      if (isa<BitCastInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="uncoveredLine">        PointerUsesQueue.push_back(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="uncoveredLine">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="uncoveredLine">        if (GEP->hasAllZeroIndices())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="uncoveredLine">          PointerUsesQueue.push_back(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="">      // If we hit a load/store with an invariant.group metadata and the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="">      // pointer operand, we can assume that value pointed to by the pointer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="">      // operand didn't change.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="uncoveredLine">      if (U->hasMetadata(LLVMContext::MD_invariant_group) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="uncoveredLine">          getLoadStorePointerOperand(U) == Ptr && !U->isVolatile()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="uncoveredLine">        MostDominatingInstruction = U;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="uncoveredLine">  return MostDominatingInstruction == &I ? nullptr : MostDominatingInstruction;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="uncoveredLine">MemoryAccess *MemorySSA::ClobberWalkerBase::getClobberingMemoryAccessBase(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="">    MemoryAccess *MA, BatchAAResults &BAA, unsigned &UpwardWalkLimit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="">    bool SkipSelf, bool UseInvariantGroup) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="uncoveredLine">  auto *StartingAccess = dyn_cast<MemoryUseOrDef>(MA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="">  // If this is a MemoryPhi, we can't do anything.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="uncoveredLine">  if (!StartingAccess)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="uncoveredLine">    return MA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="uncoveredLine">  if (UseInvariantGroup) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="uncoveredLine">    if (auto *I = getInvariantGroupClobberingInstruction(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="uncoveredLine">            *StartingAccess->getMemoryInst(), MSSA->getDomTree())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="uncoveredLine">      assert(isa<LoadInst>(I) || isa<StoreInst>(I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="uncoveredLine">      auto *ClobberMA = MSSA->getMemoryAccess(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="uncoveredLine">      assert(ClobberMA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="uncoveredLine">      if (isa<MemoryUse>(ClobberMA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="uncoveredLine">        return ClobberMA->getDefiningAccess();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="uncoveredLine">      return ClobberMA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="uncoveredLine">  bool IsOptimized = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="">  // If this is an already optimized use or def, return the optimized result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="">  // Note: Currently, we store the optimized def result in a separate field,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="">  // since we can't use the defining access.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="uncoveredLine">  if (StartingAccess->isOptimized()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="uncoveredLine">    if (!SkipSelf || !isa<MemoryDef>(StartingAccess))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="uncoveredLine">      return StartingAccess->getOptimized();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="uncoveredLine">    IsOptimized = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="uncoveredLine">  const Instruction *I = StartingAccess->getMemoryInst();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="">  // We can't sanely do anything with a fence, since they conservatively clobber</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="">  // all memory, and have no locations to get pointers from to try to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="">  // disambiguate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="uncoveredLine">  if (!isa<CallBase>(I) && I->isFenceLike())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="uncoveredLine">    return StartingAccess;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="uncoveredLine">  UpwardsMemoryQuery Q(I, StartingAccess);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="uncoveredLine">  if (isUseTriviallyOptimizableToLiveOnEntry(BAA, I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="uncoveredLine">    MemoryAccess *LiveOnEntry = MSSA->getLiveOnEntryDef();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="uncoveredLine">    StartingAccess->setOptimized(LiveOnEntry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="uncoveredLine">    return LiveOnEntry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="">  MemoryAccess *OptimizedAccess;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="uncoveredLine">  if (!IsOptimized) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="">    // Start with the thing we already think clobbers this location</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="uncoveredLine">    MemoryAccess *DefiningAccess = StartingAccess->getDefiningAccess();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="">    // At this point, DefiningAccess may be the live on entry def.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="">    // If it is, we will not get a better result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="uncoveredLine">    if (MSSA->isLiveOnEntryDef(DefiningAccess)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="uncoveredLine">      StartingAccess->setOptimized(DefiningAccess);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="uncoveredLine">      return DefiningAccess;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="uncoveredLine">    OptimizedAccess =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="uncoveredLine">        Walker.findClobber(BAA, DefiningAccess, Q, UpwardWalkLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="uncoveredLine">    StartingAccess->setOptimized(OptimizedAccess);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="">  } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="uncoveredLine">    OptimizedAccess = StartingAccess->getOptimized();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Starting Memory SSA clobber for " << *I << " is ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << *StartingAccess << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Optimized Memory SSA clobber for " << *I << " is ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << *OptimizedAccess << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="">  MemoryAccess *Result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="uncoveredLine">  if (SkipSelf && isa<MemoryPhi>(OptimizedAccess) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="uncoveredLine">      isa<MemoryDef>(StartingAccess) && UpwardWalkLimit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="uncoveredLine">    assert(isa<MemoryDef>(Q.OriginalAccess));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="uncoveredLine">    Q.SkipSelfAccess = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="uncoveredLine">    Result = Walker.findClobber(BAA, OptimizedAccess, Q, UpwardWalkLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="">  } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="uncoveredLine">    Result = OptimizedAccess;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Result Memory SSA clobber [SkipSelf = " << SkipSelf);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "] for " << *I << " is " << *Result << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="">MemoryAccess *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="uncoveredLine">DoNothingMemorySSAWalker::getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="">                                                    BatchAAResults &) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="uncoveredLine">  if (auto *Use = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="uncoveredLine">    return Use->getDefiningAccess();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="uncoveredLine">  return MA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="uncoveredLine">MemoryAccess *DoNothingMemorySSAWalker::getClobberingMemoryAccess(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="">    MemoryAccess *StartingAccess, const MemoryLocation &, BatchAAResults &) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="uncoveredLine">  if (auto *Use = dyn_cast<MemoryUseOrDef>(StartingAccess))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="uncoveredLine">    return Use->getDefiningAccess();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="uncoveredLine">  return StartingAccess;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="uncoveredLine">void MemoryPhi::deleteMe(DerivedUser *Self) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="uncoveredLine">  delete static_cast<MemoryPhi *>(Self);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="uncoveredLine">void MemoryDef::deleteMe(DerivedUser *Self) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="uncoveredLine">  delete static_cast<MemoryDef *>(Self);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="uncoveredLine">void MemoryUse::deleteMe(DerivedUser *Self) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="uncoveredLine">  delete static_cast<MemoryUse *>(Self);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="uncoveredLine">bool upward_defs_iterator::IsGuaranteedLoopInvariant(const Value *Ptr) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="uncoveredLine">  auto IsGuaranteedLoopInvariantBase = [](const Value *Ptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="uncoveredLine">    Ptr = Ptr->stripPointerCasts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="uncoveredLine">    if (!isa<Instruction>(Ptr))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="uncoveredLine">    return isa<AllocaInst>(Ptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="uncoveredLine">  Ptr = Ptr->stripPointerCasts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="uncoveredLine">  if (auto *I = dyn_cast<Instruction>(Ptr)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="uncoveredLine">    if (I->getParent()->isEntryBlock())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="uncoveredLine">  if (auto *GEP = dyn_cast<GEPOperator>(Ptr)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="uncoveredLine">    return IsGuaranteedLoopInvariantBase(GEP->getPointerOperand()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="uncoveredLine">           GEP->hasAllConstantIndices();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="uncoveredLine">  return IsGuaranteedLoopInvariantBase(Ptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL38initializeMemorySSAWrapperPassPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm34initializeMemorySSAWrapperPassPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">36</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124MemorySSAAnnotatedWriterC2EPKN4llvm9MemorySSAE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124MemorySSAAnnotatedWriter24emitBasicBlockStartAnnotEPKN4llvm10BasicBlockERNS1_21formatted_raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_124MemorySSAAnnotatedWriter20emitInstructionAnnotEPKN4llvm11InstructionERNS1_21formatted_raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_130MemorySSAWalkerAnnotatedWriterC2EPN4llvm9MemorySSAE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_130MemorySSAWalkerAnnotatedWriter24emitBasicBlockStartAnnotEPKN4llvm10BasicBlockERNS1_21formatted_raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_130MemorySSAWalkerAnnotatedWriter20emitInstructionAnnotEPKN4llvm11InstructionERNS1_21formatted_raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_115MemoryLocOrCallC2EPN4llvm14MemoryUseOrDefE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_115MemoryLocOrCallC2EPKN4llvm14MemoryUseOrDefE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_115MemoryLocOrCallC2EPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_115MemoryLocOrCallC2ERKN4llvm14MemoryLocationE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_115MemoryLocOrCall7getCallEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_115MemoryLocOrCall6getLocEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_115MemoryLocOrCalleqERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoIN12_GLOBAL__N_115MemoryLocOrCallEvE11getEmptyKeyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoIN12_GLOBAL__N_115MemoryLocOrCallEvE15getTombstoneKeyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoIN12_GLOBAL__N_115MemoryLocOrCallEvE12getHashValueERKS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoIN12_GLOBAL__N_115MemoryLocOrCallEvE7isEqualERKS2_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL19areLoadsReorderablePKN4llvm8LoadInstES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z24instructionClobbersQueryIN4llvm9AAResultsEEbPKNS0_9MemoryDefERKNS0_14MemoryLocationEPKNS0_11InstructionERT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z24instructionClobbersQueryIN4llvm14BatchAAResultsEEbPKNS0_9MemoryDefERKNS0_14MemoryLocationEPKNS0_11InstructionERT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z24instructionClobbersQueryIN4llvm14BatchAAResultsEEbPNS0_9MemoryDefEPKNS0_14MemoryUseOrDefERKN12_GLOBAL__N_115MemoryLocOrCallERT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z24instructionClobbersQueryIN4llvm9AAResultsEEbPNS0_9MemoryDefEPKNS0_14MemoryUseOrDefERKN12_GLOBAL__N_115MemoryLocOrCallERT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm13MemorySSAUtil19defClobbersUseOrDefEPNS_9MemoryDefEPKNS_14MemoryUseOrDefERNS_9AAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118UpwardsMemoryQueryC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_118UpwardsMemoryQueryC2EPKN4llvm11InstructionEPKNS1_12MemoryAccessE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z38isUseTriviallyOptimizableToLiveOnEntryIN4llvm9AAResultsEEbRT_PKNS0_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z38isUseTriviallyOptimizableToLiveOnEntryIN4llvm14BatchAAResultsEEbRT_PKNS0_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL18checkClobberSanityPKN4llvm12MemoryAccessEPS0_RKNS_14MemoryLocationERKNS_9MemorySSAERKN12_GLOBAL__N_118UpwardsMemoryQueryERNS_14BatchAAResultsEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalker7DefPathC2ERKN4llvm14MemoryLocationEPNS2_12MemoryAccessES7_St8optionalIjE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalker7DefPathC2ERKN4llvm14MemoryLocationEPNS2_12MemoryAccessESt8optionalIjE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_113ClobberWalker13getWalkTargetEPKN4llvm9MemoryPhiE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_113ClobberWalker18walkToPhiOrClobberERNS0_7DefPathEPKN4llvm12MemoryAccessES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalker11addSearchesEPN4llvm9MemoryPhiERNS1_15SmallVectorImplIjEEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalker17getBlockingAccessEPKN4llvm12MemoryAccessERNS1_15SmallVectorImplIjEES7_RNS5_INS0_14TerminatedPathEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalker25generic_def_path_iteratorINS0_7DefPathES0_EC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalker25generic_def_path_iteratorINS0_7DefPathES0_EC2EPS0_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_113ClobberWalker25generic_def_path_iteratorINS0_7DefPathES0_EdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalker25generic_def_path_iteratorINS0_7DefPathES0_EppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_113ClobberWalker25generic_def_path_iteratorINS0_7DefPathES0_EeqERKS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_113ClobberWalker25generic_def_path_iteratorINS0_7DefPathES0_E7curNodeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalker8def_pathEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_113ClobberWalker12defPathIndexERKNS0_7DefPathE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalker14tryOptimizePhiEPN4llvm9MemoryPhiEPNS1_12MemoryAccessERKNS1_14MemoryLocationE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_113ClobberWalker14tryOptimizePhiEPN4llvm9MemoryPhiEPNS1_12MemoryAccessERKNS1_14MemoryLocationEENKUlRNS1_15SmallVectorImplINS0_14TerminatedPathEEEE_clESC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_113ClobberWalker14tryOptimizePhiEPN4llvm9MemoryPhiEPNS1_12MemoryAccessERKNS1_14MemoryLocationEENKUlRKNS0_14TerminatedPathEE0_clESB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_113ClobberWalker14tryOptimizePhiEPN4llvm9MemoryPhiEPNS1_12MemoryAccessERKNS1_14MemoryLocationEENKUlRKNS0_7DefPathEE1_clESB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_113ClobberWalker14tryOptimizePhiEPN4llvm9MemoryPhiEPNS1_12MemoryAccessERKNS1_14MemoryLocationEENKUljE2_clEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_113ClobberWalker15verifyOptResultERKNS0_11OptznResultE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK12_GLOBAL__N_113ClobberWalker15verifyOptResultERKNS0_11OptznResultEENKUlRKNS0_14TerminatedPathEE_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalker18resetPhiOptznStateEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalkerC2ERKN4llvm9MemorySSAERNS1_13DominatorTreeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_113ClobberWalker11findClobberERN4llvm14BatchAAResultsEPNS1_12MemoryAccessERNS_18UpwardsMemoryQueryERj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114RenamePassDataC2EPN4llvm15DomTreeNodeBaseINS1_10BasicBlockEEEPKS5_PNS1_12MemoryAccessE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA17ClobberWalkerBaseC2EPS0_PNS_13DominatorTreeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA13CachingWalkerC2EPS0_PNS0_17ClobberWalkerBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA13CachingWalkerD0Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA13CachingWalkerD2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA13CachingWalker25getClobberingMemoryAccessEPNS_12MemoryAccessERNS_14BatchAAResultsERj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA13CachingWalker25getClobberingMemoryAccessEPNS_12MemoryAccessERKNS_14MemoryLocationERNS_14BatchAAResultsERj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA13CachingWalker46getClobberingMemoryAccessWithoutInvariantGroupEPNS_12MemoryAccessERNS_14BatchAAResultsERj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA13CachingWalker25getClobberingMemoryAccessEPNS_12MemoryAccessERNS_14BatchAAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA13CachingWalker25getClobberingMemoryAccessEPNS_12MemoryAccessERKNS_14MemoryLocationERNS_14BatchAAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA13CachingWalker14invalidateInfoEPNS_12MemoryAccessE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA14SkipSelfWalkerC2EPS0_PNS0_17ClobberWalkerBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA14SkipSelfWalkerD0Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA14SkipSelfWalkerD2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA14SkipSelfWalker25getClobberingMemoryAccessEPNS_12MemoryAccessERNS_14BatchAAResultsERj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA14SkipSelfWalker25getClobberingMemoryAccessEPNS_12MemoryAccessERKNS_14MemoryLocationERNS_14BatchAAResultsERj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA14SkipSelfWalker25getClobberingMemoryAccessEPNS_12MemoryAccessERNS_14BatchAAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA14SkipSelfWalker25getClobberingMemoryAccessEPNS_12MemoryAccessERKNS_14MemoryLocationERNS_14BatchAAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA14SkipSelfWalker14invalidateInfoEPNS_12MemoryAccessE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA19renameSuccessorPhisEPNS_10BasicBlockEPNS_12MemoryAccessEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA11renameBlockEPNS_10BasicBlockEPNS_12MemoryAccessEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA10renamePassEPNS_15DomTreeNodeBaseINS_10BasicBlockEEEPNS_12MemoryAccessERNS_15SmallPtrSetImplIPS2_EEbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA28markUnreachableAsLiveOnEntryEPNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSAC2ERNS_8FunctionEPNS_9AAResultsEPNS_13DominatorTreeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSAD2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA21getOrCreateAccessListEPKNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA19getOrCreateDefsListEPKNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA12OptimizeUsesC2EPS0_PNS0_13CachingWalkerEPNS_14BatchAAResultsEPNS_13DominatorTreeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA12OptimizeUses19optimizeUsesInBlockEPKNS_10BasicBlockERmS5_RNS_15SmallVectorImplIPNS_12MemoryAccessEEERNS_8DenseMapIN12_GLOBAL__N_115MemoryLocOrCallENS1_15MemlocStackInfoENS_12DenseMapInfoISD_vEENS_6detail12DenseMapPairISD_SE_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA12OptimizeUses12optimizeUsesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA13placePHINodesERKNS_15SmallPtrSetImplIPNS_10BasicBlockEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA14buildMemorySSAERNS_14BatchAAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA9getWalkerEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA13getWalkerImplEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA17getSkipSelfWalkerEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA23insertIntoListsForBlockEPNS_12MemoryAccessEPKNS_10BasicBlockENS0_14InsertionPlaceE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm9MemorySSA23insertIntoListsForBlockEPNS_12MemoryAccessEPKNS_10BasicBlockENS0_14InsertionPlaceEENKUlRKS1_E_clES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm9MemorySSA23insertIntoListsForBlockEPNS_12MemoryAccessEPKNS_10BasicBlockENS0_14InsertionPlaceEENKUlRKS1_E0_clES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA21insertIntoListsBeforeEPNS_12MemoryAccessEPKNS_10BasicBlockENS_14ilist_iteratorINS_12ilist_detail12node_optionsIS1_Lb1ELb0ENS_11MSSAHelpers12AllAccessTagEEELb0ELb0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA16prepareForMoveToEPNS_12MemoryAccessEPNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA6moveToEPNS_14MemoryUseOrDefEPNS_10BasicBlockENS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_12MemoryAccessELb1ELb0ENS_11MSSAHelpers12AllAccessTagEEELb0ELb0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA6moveToEPNS_12MemoryAccessEPNS_10BasicBlockENS0_14InsertionPlaceE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA15createMemoryPhiEPNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA19createDefinedAccessEPNS_11InstructionEPNS_12MemoryAccessEPKNS_14MemoryUseOrDefEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL9isOrderedPKN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA15createNewAccessINS_14BatchAAResultsEEEPNS_14MemoryUseOrDefEPNS_11InstructionEPT_PKS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA15createNewAccessINS_9AAResultsEEEPNS_14MemoryUseOrDefEPNS_11InstructionEPT_PKS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA17removeFromLookupsEPNS_12MemoryAccessE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA15removeFromListsEPNS_12MemoryAccessEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemorySSA5printERNS_11raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemorySSA4dumpEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemorySSA15verifyMemorySSAENS0_17VerificationLevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemorySSA19verifyPrevDefInPhisERNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemorySSA23verifyDominationNumbersERKNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemorySSA34verifyOrderingDominationAndDefUsesERNS_8FunctionENS0_17VerificationLevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemorySSA15verifyUseInDefsEPNS_12MemoryAccessES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemorySSA13renumberBlockEPKNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemorySSA16locallyDominatesEPKNS_12MemoryAccessES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemorySSA9dominatesEPKNS_12MemoryAccessES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemorySSA9dominatesEPKNS_12MemoryAccessERKNS_3UseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA19ensureOptimizedUsesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm12MemoryAccess5printERNS_11raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemoryDef5printERNS_11raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK4llvm9MemoryDef5printERNS_11raw_ostreamEENKUlPNS_12MemoryAccessEE_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemoryPhi5printERNS_11raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9MemoryUse5printERNS_11raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm12MemoryAccess4dumpEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN15DOTFuncMSSAInfoC2ERKN4llvm8FunctionERNS0_9MemorySSAE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN15DOTFuncMSSAInfo11getFunctionEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN15DOTFuncMSSAInfo9getWriterEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11GraphTraitsIP15DOTFuncMSSAInfoE11nodes_beginES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11GraphTraitsIP15DOTFuncMSSAInfoE9nodes_endES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14DOTGraphTraitsIP15DOTFuncMSSAInfoEC2Eb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14DOTGraphTraitsIP15DOTFuncMSSAInfoE12getGraphNameB5cxx11ES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14DOTGraphTraitsIP15DOTFuncMSSAInfoE12getNodeLabelB5cxx11EPKNS_10BasicBlockES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm14DOTGraphTraitsIP15DOTFuncMSSAInfoE12getNodeLabelB5cxx11EPKNS_10BasicBlockES2_ENKUlRNS_18raw_string_ostreamERS5_E_clES8_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm14DOTGraphTraitsIP15DOTFuncMSSAInfoE12getNodeLabelB5cxx11EPKNS_10BasicBlockES2_ENKUlRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERjjE0_clESD_SE_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14DOTGraphTraitsIP15DOTFuncMSSAInfoE18getEdgeSourceLabelB5cxx11EPKNS_10BasicBlockENS_12SuccIteratorIKNS_11InstructionES5_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14DOTGraphTraitsIP15DOTFuncMSSAInfoE17getEdgeAttributesB5cxx11EPKNS_10BasicBlockENS_12SuccIteratorIKNS_11InstructionES5_EES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14DOTGraphTraitsIP15DOTFuncMSSAInfoE17getNodeAttributesB5cxx11EPKNS_10BasicBlockES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17MemorySSAAnalysis3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17MemorySSAAnalysis6Result10invalidateERNS_8FunctionERKNS_17PreservedAnalysesERNS_15AnalysisManagerIS2_JEE11InvalidatorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20MemorySSAPrinterPass3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26MemorySSAWalkerPrinterPass3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm21MemorySSAVerifierPass3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20MemorySSAWrapperPassC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20MemorySSAWrapperPass13releaseMemoryEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20MemorySSAWrapperPass16getAnalysisUsageERNS_13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20MemorySSAWrapperPass13runOnFunctionERNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20MemorySSAWrapperPass14verifyAnalysisEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20MemorySSAWrapperPass5printERNS_11raw_ostreamEPKNS_6ModuleE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15MemorySSAWalkerC2EPNS_9MemorySSAE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA17ClobberWalkerBase29getClobberingMemoryAccessBaseEPNS_12MemoryAccessERKNS_14MemoryLocationERNS_14BatchAAResultsERj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL38getInvariantGroupClobberingInstructionRN4llvm11InstructionERNS_13DominatorTreeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemorySSA17ClobberWalkerBase29getClobberingMemoryAccessBaseEPNS_12MemoryAccessERNS_14BatchAAResultsERjbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm24DoNothingMemorySSAWalker25getClobberingMemoryAccessEPNS_12MemoryAccessERNS_14BatchAAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm24DoNothingMemorySSAWalker25getClobberingMemoryAccessEPNS_12MemoryAccessERKNS_14MemoryLocationERNS_14BatchAAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemoryPhi8deleteMeEPNS_11DerivedUserE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemoryDef8deleteMeEPNS_11DerivedUserE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9MemoryUse8deleteMeEPNS_11DerivedUserE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20upward_defs_iterator25IsGuaranteedLoopInvariantEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK4llvm20upward_defs_iterator25IsGuaranteedLoopInvariantEPKNS_5ValueEENKUlS3_E_clES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- MemorySSA.cpp - Memory SSA Builder ---------------------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- MemorySSA.cpp - Memory SSA Builder ---------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This file implements the MemorySSA class.</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This file implements the MemorySSA class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/Analysis/MemorySSA.h"</td>
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/Analysis/MemorySSA.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/ADT/DenseMapInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/DenseSet.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/DenseSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/DepthFirstIterator.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/DepthFirstIterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/Hashing.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/ADT/StringExtras.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/ADT/StringExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/iterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/iterator_range.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/CFGPrinter.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/CFGPrinter.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Analysis/IteratedDominanceFrontier.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Analysis/IteratedDominanceFrontier.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/Analysis/MemoryLocation.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/AssemblyAnnotationWriter.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/AssemblyAnnotationWriter.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/LLVMContext.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/Operator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/Use.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/Use.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/Support/AtomicOrdering.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/Support/FormattedStream.h"</td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/Support/FormattedStream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/Support/GraphWriter.h"</td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/Support/GraphWriter.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">#include <iterator></td>
    <td class="lineNumber">54</td>
    <td class="codeline">#include <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">#include <memory></td>
    <td class="lineNumber">55</td>
    <td class="codeline">#include <memory></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">56</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">58</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline"></td>
    <td class="lineNumber">59</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">#define DEBUG_TYPE "memoryssa"</td>
    <td class="lineNumber">60</td>
    <td class="codeline">#define DEBUG_TYPE "memoryssa"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">static cl::opt<std::string></td>
    <td class="lineNumber">62</td>
    <td class="codeline">static cl::opt<std::string></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">    DotCFGMSSA("dot-cfg-mssa",</td>
    <td class="lineNumber">63</td>
    <td class="codeline">    DotCFGMSSA("dot-cfg-mssa",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">               cl::value_desc("file name for generated dot file"),</td>
    <td class="lineNumber">64</td>
    <td class="codeline">               cl::value_desc("file name for generated dot file"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">               cl::desc("file name for generated dot file"), cl::init(""));</td>
    <td class="lineNumber">65</td>
    <td class="codeline">               cl::desc("file name for generated dot file"), cl::init(""));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(MemorySSAWrapperPass, "memoryssa", "Memory SSA", false,</td>
    <td class="lineNumber">67</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(MemorySSAWrapperPass, "memoryssa", "Memory SSA", false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">                      true)</td>
    <td class="lineNumber">68</td>
    <td class="codeline">                      true)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">69</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">70</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">INITIALIZE_PASS_END(MemorySSAWrapperPass, "memoryssa", "Memory SSA", false,</td>
    <td class="lineNumber">71</td>
    <td class="codeline">INITIALIZE_PASS_END(MemorySSAWrapperPass, "memoryssa", "Memory SSA", false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">                    true)</td>
    <td class="lineNumber">72</td>
    <td class="codeline">                    true)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline"></td>
    <td class="lineNumber">73</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">static cl::opt<unsigned> MaxCheckLimit(</td>
    <td class="lineNumber">74</td>
    <td class="codeline">static cl::opt<unsigned> MaxCheckLimit(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">    "memssa-check-limit", cl::Hidden, cl::init(100),</td>
    <td class="lineNumber">75</td>
    <td class="codeline">    "memssa-check-limit", cl::Hidden, cl::init(100),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">    cl::desc("The maximum number of stores/phis MemorySSA"</td>
    <td class="lineNumber">76</td>
    <td class="codeline">    cl::desc("The maximum number of stores/phis MemorySSA"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">             "will consider trying to walk past (default = 100)"));</td>
    <td class="lineNumber">77</td>
    <td class="codeline">             "will consider trying to walk past (default = 100)"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline"></td>
    <td class="lineNumber">78</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">// Always verify MemorySSA if expensive checking is enabled.</td>
    <td class="lineNumber">79</td>
    <td class="codeline">// Always verify MemorySSA if expensive checking is enabled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">80</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">bool llvm::VerifyMemorySSA = true;</td>
    <td class="lineNumber">81</td>
    <td class="codeline">bool llvm::VerifyMemorySSA = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">#else</td>
    <td class="lineNumber">82</td>
    <td class="codeline">#else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">bool llvm::VerifyMemorySSA = false;</td>
    <td class="lineNumber">83</td>
    <td class="codeline">bool llvm::VerifyMemorySSA = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">84</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline"></td>
    <td class="lineNumber">85</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">static cl::opt<bool, true></td>
    <td class="lineNumber">86</td>
    <td class="codeline">static cl::opt<bool, true></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">    VerifyMemorySSAX("verify-memoryssa", cl::location(VerifyMemorySSA),</td>
    <td class="lineNumber">87</td>
    <td class="codeline">    VerifyMemorySSAX("verify-memoryssa", cl::location(VerifyMemorySSA),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">                     cl::Hidden, cl::desc("Enable verification of MemorySSA."));</td>
    <td class="lineNumber">88</td>
    <td class="codeline">                     cl::Hidden, cl::desc("Enable verification of MemorySSA."));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline"></td>
    <td class="lineNumber">89</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">const static char LiveOnEntryStr[] = "liveOnEntry";</td>
    <td class="lineNumber">90</td>
    <td class="codeline">const static char LiveOnEntryStr[] = "liveOnEntry";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline"></td>
    <td class="lineNumber">91</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">92</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline"></td>
    <td class="lineNumber">93</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">/// An assembly annotator class to print Memory SSA information in</td>
    <td class="lineNumber">94</td>
    <td class="codeline">/// An assembly annotator class to print Memory SSA information in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">/// comments.</td>
    <td class="lineNumber">95</td>
    <td class="codeline">/// comments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">class MemorySSAAnnotatedWriter : public AssemblyAnnotationWriter {</td>
    <td class="lineNumber">96</td>
    <td class="codeline">class MemorySSAAnnotatedWriter : public AssemblyAnnotationWriter {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">  const MemorySSA *MSSA;</td>
    <td class="lineNumber">97</td>
    <td class="codeline">  const MemorySSA *MSSA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline"></td>
    <td class="lineNumber">98</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">99</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  MemorySSAAnnotatedWriter(const MemorySSA *M) : MSSA(M) {}</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  MemorySSAAnnotatedWriter(const MemorySSA *M) : MSSA(M) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline"></td>
    <td class="lineNumber">101</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  void emitBasicBlockStartAnnot(const BasicBlock *BB,</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  void emitBasicBlockStartAnnot(const BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">                                formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">103</td>
    <td class="codeline">                                formatted_raw_ostream &OS) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">    if (MemoryAccess *MA = MSSA->getMemoryAccess(BB))</td>
    <td class="lineNumber">104</td>
    <td class="codeline">    if (MemoryAccess *MA = MSSA->getMemoryAccess(BB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">      OS << "; " << *MA << "\n";</td>
    <td class="lineNumber">105</td>
    <td class="codeline">      OS << "; " << *MA << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">  void emitInstructionAnnot(const Instruction *I,</td>
    <td class="lineNumber">108</td>
    <td class="codeline">  void emitInstructionAnnot(const Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">                            formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">109</td>
    <td class="codeline">                            formatted_raw_ostream &OS) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">    if (MemoryAccess *MA = MSSA->getMemoryAccess(I))</td>
    <td class="lineNumber">110</td>
    <td class="codeline">    if (MemoryAccess *MA = MSSA->getMemoryAccess(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">      OS << "; " << *MA << "\n";</td>
    <td class="lineNumber">111</td>
    <td class="codeline">      OS << "; " << *MA << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">};</td>
    <td class="lineNumber">113</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline"></td>
    <td class="lineNumber">114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">/// An assembly annotator class to print Memory SSA information in</td>
    <td class="lineNumber">115</td>
    <td class="codeline">/// An assembly annotator class to print Memory SSA information in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">/// comments.</td>
    <td class="lineNumber">116</td>
    <td class="codeline">/// comments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">class MemorySSAWalkerAnnotatedWriter : public AssemblyAnnotationWriter {</td>
    <td class="lineNumber">117</td>
    <td class="codeline">class MemorySSAWalkerAnnotatedWriter : public AssemblyAnnotationWriter {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  MemorySSA *MSSA;</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  MemorySSA *MSSA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">  MemorySSAWalker *Walker;</td>
    <td class="lineNumber">119</td>
    <td class="codeline">  MemorySSAWalker *Walker;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">  BatchAAResults BAA;</td>
    <td class="lineNumber">120</td>
    <td class="codeline">  BatchAAResults BAA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">122</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  MemorySSAWalkerAnnotatedWriter(MemorySSA *M)</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  MemorySSAWalkerAnnotatedWriter(MemorySSA *M)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">      : MSSA(M), Walker(M->getWalker()), BAA(M->getAA()) {}</td>
    <td class="lineNumber">124</td>
    <td class="codeline">      : MSSA(M), Walker(M->getWalker()), BAA(M->getAA()) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  void emitBasicBlockStartAnnot(const BasicBlock *BB,</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  void emitBasicBlockStartAnnot(const BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">                                formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">127</td>
    <td class="codeline">                                formatted_raw_ostream &OS) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">    if (MemoryAccess *MA = MSSA->getMemoryAccess(BB))</td>
    <td class="lineNumber">128</td>
    <td class="codeline">    if (MemoryAccess *MA = MSSA->getMemoryAccess(BB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">      OS << "; " << *MA << "\n";</td>
    <td class="lineNumber">129</td>
    <td class="codeline">      OS << "; " << *MA << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline"></td>
    <td class="lineNumber">131</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">  void emitInstructionAnnot(const Instruction *I,</td>
    <td class="lineNumber">132</td>
    <td class="codeline">  void emitInstructionAnnot(const Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">                            formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">133</td>
    <td class="codeline">                            formatted_raw_ostream &OS) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">    if (MemoryAccess *MA = MSSA->getMemoryAccess(I)) {</td>
    <td class="lineNumber">134</td>
    <td class="codeline">    if (MemoryAccess *MA = MSSA->getMemoryAccess(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">      MemoryAccess *Clobber = Walker->getClobberingMemoryAccess(MA, BAA);</td>
    <td class="lineNumber">135</td>
    <td class="codeline">      MemoryAccess *Clobber = Walker->getClobberingMemoryAccess(MA, BAA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">      OS << "; " << *MA;</td>
    <td class="lineNumber">136</td>
    <td class="codeline">      OS << "; " << *MA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">      if (Clobber) {</td>
    <td class="lineNumber">137</td>
    <td class="codeline">      if (Clobber) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">        OS << " - clobbered by ";</td>
    <td class="lineNumber">138</td>
    <td class="codeline">        OS << " - clobbered by ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">        if (MSSA->isLiveOnEntryDef(Clobber))</td>
    <td class="lineNumber">139</td>
    <td class="codeline">        if (MSSA->isLiveOnEntryDef(Clobber))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">          OS << LiveOnEntryStr;</td>
    <td class="lineNumber">140</td>
    <td class="codeline">          OS << LiveOnEntryStr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">        else</td>
    <td class="lineNumber">141</td>
    <td class="codeline">        else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">          OS << *Clobber;</td>
    <td class="lineNumber">142</td>
    <td class="codeline">          OS << *Clobber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">143</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">      OS << "\n";</td>
    <td class="lineNumber">144</td>
    <td class="codeline">      OS << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">145</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">};</td>
    <td class="lineNumber">147</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">} // namespace</td>
    <td class="lineNumber">149</td>
    <td class="codeline">} // namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline"></td>
    <td class="lineNumber">150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">151</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline"></td>
    <td class="lineNumber">152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">/// Our current alias analysis API differentiates heavily between calls and</td>
    <td class="lineNumber">153</td>
    <td class="codeline">/// Our current alias analysis API differentiates heavily between calls and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">/// non-calls, and functions called on one usually assert on the other.</td>
    <td class="lineNumber">154</td>
    <td class="codeline">/// non-calls, and functions called on one usually assert on the other.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">/// This class encapsulates the distinction to simplify other code that wants</td>
    <td class="lineNumber">155</td>
    <td class="codeline">/// This class encapsulates the distinction to simplify other code that wants</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">/// "Memory affecting instructions and related data" to use as a key.</td>
    <td class="lineNumber">156</td>
    <td class="codeline">/// "Memory affecting instructions and related data" to use as a key.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">/// For example, this class is used as a densemap key in the use optimizer.</td>
    <td class="lineNumber">157</td>
    <td class="codeline">/// For example, this class is used as a densemap key in the use optimizer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">class MemoryLocOrCall {</td>
    <td class="lineNumber">158</td>
    <td class="codeline">class MemoryLocOrCall {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">159</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">  bool IsCall = false;</td>
    <td class="lineNumber">160</td>
    <td class="codeline">  bool IsCall = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline"></td>
    <td class="lineNumber">161</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">  MemoryLocOrCall(MemoryUseOrDef *MUD)</td>
    <td class="lineNumber">162</td>
    <td class="codeline">  MemoryLocOrCall(MemoryUseOrDef *MUD)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">      : MemoryLocOrCall(MUD->getMemoryInst()) {}</td>
    <td class="lineNumber">163</td>
    <td class="codeline">      : MemoryLocOrCall(MUD->getMemoryInst()) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  MemoryLocOrCall(const MemoryUseOrDef *MUD)</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  MemoryLocOrCall(const MemoryUseOrDef *MUD)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">      : MemoryLocOrCall(MUD->getMemoryInst()) {}</td>
    <td class="lineNumber">165</td>
    <td class="codeline">      : MemoryLocOrCall(MUD->getMemoryInst()) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline"></td>
    <td class="lineNumber">166</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">  MemoryLocOrCall(Instruction *Inst) {</td>
    <td class="lineNumber">167</td>
    <td class="codeline">  MemoryLocOrCall(Instruction *Inst) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">    if (auto *C = dyn_cast<CallBase>(Inst)) {</td>
    <td class="lineNumber">168</td>
    <td class="codeline">    if (auto *C = dyn_cast<CallBase>(Inst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">      IsCall = true;</td>
    <td class="lineNumber">169</td>
    <td class="codeline">      IsCall = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">      Call = C;</td>
    <td class="lineNumber">170</td>
    <td class="codeline">      Call = C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">171</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">      IsCall = false;</td>
    <td class="lineNumber">172</td>
    <td class="codeline">      IsCall = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">      // There is no such thing as a memorylocation for a fence inst, and it is</td>
    <td class="lineNumber">173</td>
    <td class="codeline">      // There is no such thing as a memorylocation for a fence inst, and it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">      // unique in that regard.</td>
    <td class="lineNumber">174</td>
    <td class="codeline">      // unique in that regard.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">      if (!isa<FenceInst>(Inst))</td>
    <td class="lineNumber">175</td>
    <td class="codeline">      if (!isa<FenceInst>(Inst))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">        Loc = MemoryLocation::get(Inst);</td>
    <td class="lineNumber">176</td>
    <td class="codeline">        Loc = MemoryLocation::get(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">177</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline"></td>
    <td class="lineNumber">179</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">  explicit MemoryLocOrCall(const MemoryLocation &Loc) : Loc(Loc) {}</td>
    <td class="lineNumber">180</td>
    <td class="codeline">  explicit MemoryLocOrCall(const MemoryLocation &Loc) : Loc(Loc) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  const CallBase *getCall() const {</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  const CallBase *getCall() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">    assert(IsCall);</td>
    <td class="lineNumber">183</td>
    <td class="codeline">    assert(IsCall);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">    return Call;</td>
    <td class="lineNumber">184</td>
    <td class="codeline">    return Call;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline"></td>
    <td class="lineNumber">186</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  MemoryLocation getLoc() const {</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  MemoryLocation getLoc() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">    assert(!IsCall);</td>
    <td class="lineNumber">188</td>
    <td class="codeline">    assert(!IsCall);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">    return Loc;</td>
    <td class="lineNumber">189</td>
    <td class="codeline">    return Loc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline"></td>
    <td class="lineNumber">191</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">  bool operator==(const MemoryLocOrCall &Other) const {</td>
    <td class="lineNumber">192</td>
    <td class="codeline">  bool operator==(const MemoryLocOrCall &Other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">    if (IsCall != Other.IsCall)</td>
    <td class="lineNumber">193</td>
    <td class="codeline">    if (IsCall != Other.IsCall)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">194</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline"></td>
    <td class="lineNumber">195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">    if (!IsCall)</td>
    <td class="lineNumber">196</td>
    <td class="codeline">    if (!IsCall)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">      return Loc == Other.Loc;</td>
    <td class="lineNumber">197</td>
    <td class="codeline">      return Loc == Other.Loc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">    if (Call->getCalledOperand() != Other.Call->getCalledOperand())</td>
    <td class="lineNumber">199</td>
    <td class="codeline">    if (Call->getCalledOperand() != Other.Call->getCalledOperand())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">200</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline"></td>
    <td class="lineNumber">201</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">    return Call->arg_size() == Other.Call->arg_size() &&</td>
    <td class="lineNumber">202</td>
    <td class="codeline">    return Call->arg_size() == Other.Call->arg_size() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">           std::equal(Call->arg_begin(), Call->arg_end(),</td>
    <td class="lineNumber">203</td>
    <td class="codeline">           std::equal(Call->arg_begin(), Call->arg_end(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">                      Other.Call->arg_begin());</td>
    <td class="lineNumber">204</td>
    <td class="codeline">                      Other.Call->arg_begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">207</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  union {</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  union {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    const CallBase *Call;</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    const CallBase *Call;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">    MemoryLocation Loc;</td>
    <td class="lineNumber">210</td>
    <td class="codeline">    MemoryLocation Loc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">};</td>
    <td class="lineNumber">212</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline"></td>
    <td class="lineNumber">213</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">214</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">216</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">template <> struct DenseMapInfo<MemoryLocOrCall> {</td>
    <td class="lineNumber">218</td>
    <td class="codeline">template <> struct DenseMapInfo<MemoryLocOrCall> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  static inline MemoryLocOrCall getEmptyKey() {</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  static inline MemoryLocOrCall getEmptyKey() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">    return MemoryLocOrCall(DenseMapInfo<MemoryLocation>::getEmptyKey());</td>
    <td class="lineNumber">220</td>
    <td class="codeline">    return MemoryLocOrCall(DenseMapInfo<MemoryLocation>::getEmptyKey());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline"></td>
    <td class="lineNumber">222</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  static inline MemoryLocOrCall getTombstoneKey() {</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  static inline MemoryLocOrCall getTombstoneKey() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">    return MemoryLocOrCall(DenseMapInfo<MemoryLocation>::getTombstoneKey());</td>
    <td class="lineNumber">224</td>
    <td class="codeline">    return MemoryLocOrCall(DenseMapInfo<MemoryLocation>::getTombstoneKey());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">225</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline"></td>
    <td class="lineNumber">226</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">  static unsigned getHashValue(const MemoryLocOrCall &MLOC) {</td>
    <td class="lineNumber">227</td>
    <td class="codeline">  static unsigned getHashValue(const MemoryLocOrCall &MLOC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">    if (!MLOC.IsCall)</td>
    <td class="lineNumber">228</td>
    <td class="codeline">    if (!MLOC.IsCall)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">      return hash_combine(</td>
    <td class="lineNumber">229</td>
    <td class="codeline">      return hash_combine(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">          MLOC.IsCall,</td>
    <td class="lineNumber">230</td>
    <td class="codeline">          MLOC.IsCall,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">          DenseMapInfo<MemoryLocation>::getHashValue(MLOC.getLoc()));</td>
    <td class="lineNumber">231</td>
    <td class="codeline">          DenseMapInfo<MemoryLocation>::getHashValue(MLOC.getLoc()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">    hash_code hash =</td>
    <td class="lineNumber">233</td>
    <td class="codeline">    hash_code hash =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">        hash_combine(MLOC.IsCall, DenseMapInfo<const Value *>::getHashValue(</td>
    <td class="lineNumber">234</td>
    <td class="codeline">        hash_combine(MLOC.IsCall, DenseMapInfo<const Value *>::getHashValue(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">                                      MLOC.getCall()->getCalledOperand()));</td>
    <td class="lineNumber">235</td>
    <td class="codeline">                                      MLOC.getCall()->getCalledOperand()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">    for (const Value *Arg : MLOC.getCall()->args())</td>
    <td class="lineNumber">237</td>
    <td class="codeline">    for (const Value *Arg : MLOC.getCall()->args())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">      hash = hash_combine(hash, DenseMapInfo<const Value *>::getHashValue(Arg));</td>
    <td class="lineNumber">238</td>
    <td class="codeline">      hash = hash_combine(hash, DenseMapInfo<const Value *>::getHashValue(Arg));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    return hash;</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    return hash;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline"></td>
    <td class="lineNumber">241</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  static bool isEqual(const MemoryLocOrCall &LHS, const MemoryLocOrCall &RHS) {</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  static bool isEqual(const MemoryLocOrCall &LHS, const MemoryLocOrCall &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">    return LHS == RHS;</td>
    <td class="lineNumber">243</td>
    <td class="codeline">    return LHS == RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">};</td>
    <td class="lineNumber">245</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">247</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">/// This does one-way checks to see if Use could theoretically be hoisted above</td>
    <td class="lineNumber">249</td>
    <td class="codeline">/// This does one-way checks to see if Use could theoretically be hoisted above</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">/// MayClobber. This will not check the other way around.</td>
    <td class="lineNumber">250</td>
    <td class="codeline">/// MayClobber. This will not check the other way around.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">///</td>
    <td class="lineNumber">251</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">/// This assumes that, for the purposes of MemorySSA, Use comes directly after</td>
    <td class="lineNumber">252</td>
    <td class="codeline">/// This assumes that, for the purposes of MemorySSA, Use comes directly after</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">/// MayClobber, with no potentially clobbering operations in between them.</td>
    <td class="lineNumber">253</td>
    <td class="codeline">/// MayClobber, with no potentially clobbering operations in between them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">/// (Where potentially clobbering ops are memory barriers, aliased stores, etc.)</td>
    <td class="lineNumber">254</td>
    <td class="codeline">/// (Where potentially clobbering ops are memory barriers, aliased stores, etc.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">static bool areLoadsReorderable(const LoadInst *Use,</td>
    <td class="lineNumber">255</td>
    <td class="codeline">static bool areLoadsReorderable(const LoadInst *Use,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">                                const LoadInst *MayClobber) {</td>
    <td class="lineNumber">256</td>
    <td class="codeline">                                const LoadInst *MayClobber) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  bool VolatileUse = Use->isVolatile();</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  bool VolatileUse = Use->isVolatile();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">  bool VolatileClobber = MayClobber->isVolatile();</td>
    <td class="lineNumber">258</td>
    <td class="codeline">  bool VolatileClobber = MayClobber->isVolatile();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  // Volatile operations may never be reordered with other volatile operations.</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  // Volatile operations may never be reordered with other volatile operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  if (VolatileUse && VolatileClobber)</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  if (VolatileUse && VolatileClobber)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">261</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  // Otherwise, volatile doesn't matter here. From the language reference:</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  // Otherwise, volatile doesn't matter here. From the language reference:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">  // 'optimizers may change the order of volatile operations relative to</td>
    <td class="lineNumber">263</td>
    <td class="codeline">  // 'optimizers may change the order of volatile operations relative to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  // non-volatile operations.'"</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  // non-volatile operations.'"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  // If a load is seq_cst, it cannot be moved above other loads. If its ordering</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  // If a load is seq_cst, it cannot be moved above other loads. If its ordering</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  // is weaker, it can be moved above other loads. We just need to be sure that</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  // is weaker, it can be moved above other loads. We just need to be sure that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">  // MayClobber isn't an acquire load, because loads can't be moved above</td>
    <td class="lineNumber">268</td>
    <td class="codeline">  // MayClobber isn't an acquire load, because loads can't be moved above</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  // acquire loads.</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  // acquire loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  // Note that this explicitly *does* allow the free reordering of monotonic (or</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  // Note that this explicitly *does* allow the free reordering of monotonic (or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  // weaker) loads of the same address.</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  // weaker) loads of the same address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  bool SeqCstUse = Use->getOrdering() == AtomicOrdering::SequentiallyConsistent;</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  bool SeqCstUse = Use->getOrdering() == AtomicOrdering::SequentiallyConsistent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  bool MayClobberIsAcquire = isAtLeastOrStrongerThan(MayClobber->getOrdering(),</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  bool MayClobberIsAcquire = isAtLeastOrStrongerThan(MayClobber->getOrdering(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">                                                     AtomicOrdering::Acquire);</td>
    <td class="lineNumber">275</td>
    <td class="codeline">                                                     AtomicOrdering::Acquire);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  return !(SeqCstUse || MayClobberIsAcquire);</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  return !(SeqCstUse || MayClobberIsAcquire);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">}</td>
    <td class="lineNumber">277</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">template <typename AliasAnalysisType></td>
    <td class="lineNumber">279</td>
    <td class="codeline">template <typename AliasAnalysisType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">static bool</td>
    <td class="lineNumber">280</td>
    <td class="codeline">static bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">instructionClobbersQuery(const MemoryDef *MD, const MemoryLocation &UseLoc,</td>
    <td class="lineNumber">281</td>
    <td class="codeline">instructionClobbersQuery(const MemoryDef *MD, const MemoryLocation &UseLoc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">                         const Instruction *UseInst, AliasAnalysisType &AA) {</td>
    <td class="lineNumber">282</td>
    <td class="codeline">                         const Instruction *UseInst, AliasAnalysisType &AA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  Instruction *DefInst = MD->getMemoryInst();</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  Instruction *DefInst = MD->getMemoryInst();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  assert(DefInst && "Defining instruction not actually an instruction");</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  assert(DefInst && "Defining instruction not actually an instruction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(DefInst)) {</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(DefInst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">    // These intrinsics will show up as affecting memory, but they are just</td>
    <td class="lineNumber">287</td>
    <td class="codeline">    // These intrinsics will show up as affecting memory, but they are just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">    // markers, mostly.</td>
    <td class="lineNumber">288</td>
    <td class="codeline">    // markers, mostly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">289</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">    // FIXME: We probably don't actually want MemorySSA to model these at all</td>
    <td class="lineNumber">290</td>
    <td class="codeline">    // FIXME: We probably don't actually want MemorySSA to model these at all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">    // (including creating MemoryAccesses for them): we just end up inventing</td>
    <td class="lineNumber">291</td>
    <td class="codeline">    // (including creating MemoryAccesses for them): we just end up inventing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">    // clobbers where they don't really exist at all. Please see D43269 for</td>
    <td class="lineNumber">292</td>
    <td class="codeline">    // clobbers where they don't really exist at all. Please see D43269 for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">    // context.</td>
    <td class="lineNumber">293</td>
    <td class="codeline">    // context.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">294</td>
    <td class="codeline">    switch (II->getIntrinsicID()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">    case Intrinsic::invariant_start:</td>
    <td class="lineNumber">295</td>
    <td class="codeline">    case Intrinsic::invariant_start:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">    case Intrinsic::invariant_end:</td>
    <td class="lineNumber">296</td>
    <td class="codeline">    case Intrinsic::invariant_end:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">    case Intrinsic::assume:</td>
    <td class="lineNumber">297</td>
    <td class="codeline">    case Intrinsic::assume:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">    case Intrinsic::experimental_noalias_scope_decl:</td>
    <td class="lineNumber">298</td>
    <td class="codeline">    case Intrinsic::experimental_noalias_scope_decl:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">    case Intrinsic::pseudoprobe:</td>
    <td class="lineNumber">299</td>
    <td class="codeline">    case Intrinsic::pseudoprobe:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">300</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">    case Intrinsic::dbg_declare:</td>
    <td class="lineNumber">301</td>
    <td class="codeline">    case Intrinsic::dbg_declare:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">    case Intrinsic::dbg_label:</td>
    <td class="lineNumber">302</td>
    <td class="codeline">    case Intrinsic::dbg_label:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">    case Intrinsic::dbg_value:</td>
    <td class="lineNumber">303</td>
    <td class="codeline">    case Intrinsic::dbg_value:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">      llvm_unreachable("debuginfo shouldn't have associated defs!");</td>
    <td class="lineNumber">304</td>
    <td class="codeline">      llvm_unreachable("debuginfo shouldn't have associated defs!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">305</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">306</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">307</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">308</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline"></td>
    <td class="lineNumber">309</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">  if (auto *CB = dyn_cast_or_null<CallBase>(UseInst)) {</td>
    <td class="lineNumber">310</td>
    <td class="codeline">  if (auto *CB = dyn_cast_or_null<CallBase>(UseInst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">    ModRefInfo I = AA.getModRefInfo(DefInst, CB);</td>
    <td class="lineNumber">311</td>
    <td class="codeline">    ModRefInfo I = AA.getModRefInfo(DefInst, CB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    return isModOrRefSet(I);</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    return isModOrRefSet(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">313</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline"></td>
    <td class="lineNumber">314</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">  if (auto *DefLoad = dyn_cast<LoadInst>(DefInst))</td>
    <td class="lineNumber">315</td>
    <td class="codeline">  if (auto *DefLoad = dyn_cast<LoadInst>(DefInst))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">    if (auto *UseLoad = dyn_cast_or_null<LoadInst>(UseInst))</td>
    <td class="lineNumber">316</td>
    <td class="codeline">    if (auto *UseLoad = dyn_cast_or_null<LoadInst>(UseInst))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">      return !areLoadsReorderable(UseLoad, DefLoad);</td>
    <td class="lineNumber">317</td>
    <td class="codeline">      return !areLoadsReorderable(UseLoad, DefLoad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline"></td>
    <td class="lineNumber">318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">  ModRefInfo I = AA.getModRefInfo(DefInst, UseLoc);</td>
    <td class="lineNumber">319</td>
    <td class="codeline">  ModRefInfo I = AA.getModRefInfo(DefInst, UseLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">  return isModSet(I);</td>
    <td class="lineNumber">320</td>
    <td class="codeline">  return isModSet(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">}</td>
    <td class="lineNumber">321</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline"></td>
    <td class="lineNumber">322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">template <typename AliasAnalysisType></td>
    <td class="lineNumber">323</td>
    <td class="codeline">template <typename AliasAnalysisType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">static bool instructionClobbersQuery(MemoryDef *MD, const MemoryUseOrDef *MU,</td>
    <td class="lineNumber">324</td>
    <td class="codeline">static bool instructionClobbersQuery(MemoryDef *MD, const MemoryUseOrDef *MU,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">                                     const MemoryLocOrCall &UseMLOC,</td>
    <td class="lineNumber">325</td>
    <td class="codeline">                                     const MemoryLocOrCall &UseMLOC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">                                     AliasAnalysisType &AA) {</td>
    <td class="lineNumber">326</td>
    <td class="codeline">                                     AliasAnalysisType &AA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">  // FIXME: This is a temporary hack to allow a single instructionClobbersQuery</td>
    <td class="lineNumber">327</td>
    <td class="codeline">  // FIXME: This is a temporary hack to allow a single instructionClobbersQuery</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">  // to exist while MemoryLocOrCall is pushed through places.</td>
    <td class="lineNumber">328</td>
    <td class="codeline">  // to exist while MemoryLocOrCall is pushed through places.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  if (UseMLOC.IsCall)</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  if (UseMLOC.IsCall)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">    return instructionClobbersQuery(MD, MemoryLocation(), MU->getMemoryInst(),</td>
    <td class="lineNumber">330</td>
    <td class="codeline">    return instructionClobbersQuery(MD, MemoryLocation(), MU->getMemoryInst(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">                                    AA);</td>
    <td class="lineNumber">331</td>
    <td class="codeline">                                    AA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  return instructionClobbersQuery(MD, UseMLOC.getLoc(), MU->getMemoryInst(),</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  return instructionClobbersQuery(MD, UseMLOC.getLoc(), MU->getMemoryInst(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">                                  AA);</td>
    <td class="lineNumber">333</td>
    <td class="codeline">                                  AA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">}</td>
    <td class="lineNumber">334</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline"></td>
    <td class="lineNumber">335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">// Return true when MD may alias MU, return false otherwise.</td>
    <td class="lineNumber">336</td>
    <td class="codeline">// Return true when MD may alias MU, return false otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">bool MemorySSAUtil::defClobbersUseOrDef(MemoryDef *MD, const MemoryUseOrDef *MU,</td>
    <td class="lineNumber">337</td>
    <td class="codeline">bool MemorySSAUtil::defClobbersUseOrDef(MemoryDef *MD, const MemoryUseOrDef *MU,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">                                        AliasAnalysis &AA) {</td>
    <td class="lineNumber">338</td>
    <td class="codeline">                                        AliasAnalysis &AA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">  return instructionClobbersQuery(MD, MU, MemoryLocOrCall(MU), AA);</td>
    <td class="lineNumber">339</td>
    <td class="codeline">  return instructionClobbersQuery(MD, MU, MemoryLocOrCall(MU), AA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">}</td>
    <td class="lineNumber">340</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">342</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline"></td>
    <td class="lineNumber">343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">struct UpwardsMemoryQuery {</td>
    <td class="lineNumber">344</td>
    <td class="codeline">struct UpwardsMemoryQuery {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  // True if our original query started off as a call</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  // True if our original query started off as a call</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">  bool IsCall = false;</td>
    <td class="lineNumber">346</td>
    <td class="codeline">  bool IsCall = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">  // The pointer location we started the query with. This will be empty if</td>
    <td class="lineNumber">347</td>
    <td class="codeline">  // The pointer location we started the query with. This will be empty if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">  // IsCall is true.</td>
    <td class="lineNumber">348</td>
    <td class="codeline">  // IsCall is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  MemoryLocation StartingLoc;</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  MemoryLocation StartingLoc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">  // This is the instruction we were querying about.</td>
    <td class="lineNumber">350</td>
    <td class="codeline">  // This is the instruction we were querying about.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">  const Instruction *Inst = nullptr;</td>
    <td class="lineNumber">351</td>
    <td class="codeline">  const Instruction *Inst = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">  // The MemoryAccess we actually got called with, used to test local domination</td>
    <td class="lineNumber">352</td>
    <td class="codeline">  // The MemoryAccess we actually got called with, used to test local domination</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  const MemoryAccess *OriginalAccess = nullptr;</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  const MemoryAccess *OriginalAccess = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  bool SkipSelfAccess = false;</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  bool SkipSelfAccess = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline"></td>
    <td class="lineNumber">355</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  UpwardsMemoryQuery() = default;</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  UpwardsMemoryQuery() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline"></td>
    <td class="lineNumber">357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">  UpwardsMemoryQuery(const Instruction *Inst, const MemoryAccess *Access)</td>
    <td class="lineNumber">358</td>
    <td class="codeline">  UpwardsMemoryQuery(const Instruction *Inst, const MemoryAccess *Access)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">      : IsCall(isa<CallBase>(Inst)), Inst(Inst), OriginalAccess(Access) {</td>
    <td class="lineNumber">359</td>
    <td class="codeline">      : IsCall(isa<CallBase>(Inst)), Inst(Inst), OriginalAccess(Access) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">    if (!IsCall)</td>
    <td class="lineNumber">360</td>
    <td class="codeline">    if (!IsCall)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">      StartingLoc = MemoryLocation::get(Inst);</td>
    <td class="lineNumber">361</td>
    <td class="codeline">      StartingLoc = MemoryLocation::get(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">362</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">};</td>
    <td class="lineNumber">363</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">365</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline"></td>
    <td class="lineNumber">366</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">template <typename AliasAnalysisType></td>
    <td class="lineNumber">367</td>
    <td class="codeline">template <typename AliasAnalysisType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">static bool isUseTriviallyOptimizableToLiveOnEntry(AliasAnalysisType &AA,</td>
    <td class="lineNumber">368</td>
    <td class="codeline">static bool isUseTriviallyOptimizableToLiveOnEntry(AliasAnalysisType &AA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">                                                   const Instruction *I) {</td>
    <td class="lineNumber">369</td>
    <td class="codeline">                                                   const Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  // If the memory can't be changed, then loads of the memory can't be</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  // If the memory can't be changed, then loads of the memory can't be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  // clobbered.</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  // clobbered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">    return I->hasMetadata(LLVMContext::MD_invariant_load) ||</td>
    <td class="lineNumber">373</td>
    <td class="codeline">    return I->hasMetadata(LLVMContext::MD_invariant_load) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">           !isModSet(AA.getModRefInfoMask(MemoryLocation::get(LI)));</td>
    <td class="lineNumber">374</td>
    <td class="codeline">           !isModSet(AA.getModRefInfoMask(MemoryLocation::get(LI)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">375</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">376</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">}</td>
    <td class="lineNumber">377</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">/// Verifies that `Start` is clobbered by `ClobberAt`, and that nothing</td>
    <td class="lineNumber">379</td>
    <td class="codeline">/// Verifies that `Start` is clobbered by `ClobberAt`, and that nothing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">/// inbetween `Start` and `ClobberAt` can clobbers `Start`.</td>
    <td class="lineNumber">380</td>
    <td class="codeline">/// inbetween `Start` and `ClobberAt` can clobbers `Start`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">///</td>
    <td class="lineNumber">381</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">/// This is meant to be as simple and self-contained as possible. Because it</td>
    <td class="lineNumber">382</td>
    <td class="codeline">/// This is meant to be as simple and self-contained as possible. Because it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">/// uses no cache, etc., it can be relatively expensive.</td>
    <td class="lineNumber">383</td>
    <td class="codeline">/// uses no cache, etc., it can be relatively expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">///</td>
    <td class="lineNumber">384</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">/// \param Start     The MemoryAccess that we want to walk from.</td>
    <td class="lineNumber">385</td>
    <td class="codeline">/// \param Start     The MemoryAccess that we want to walk from.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">/// \param ClobberAt A clobber for Start.</td>
    <td class="lineNumber">386</td>
    <td class="codeline">/// \param ClobberAt A clobber for Start.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">/// \param StartLoc  The MemoryLocation for Start.</td>
    <td class="lineNumber">387</td>
    <td class="codeline">/// \param StartLoc  The MemoryLocation for Start.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">/// \param MSSA      The MemorySSA instance that Start and ClobberAt belong to.</td>
    <td class="lineNumber">388</td>
    <td class="codeline">/// \param MSSA      The MemorySSA instance that Start and ClobberAt belong to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">/// \param Query     The UpwardsMemoryQuery we used for our search.</td>
    <td class="lineNumber">389</td>
    <td class="codeline">/// \param Query     The UpwardsMemoryQuery we used for our search.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">/// \param AA        The AliasAnalysis we used for our search.</td>
    <td class="lineNumber">390</td>
    <td class="codeline">/// \param AA        The AliasAnalysis we used for our search.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">/// \param AllowImpreciseClobber Always false, unless we do relaxed verify.</td>
    <td class="lineNumber">391</td>
    <td class="codeline">/// \param AllowImpreciseClobber Always false, unless we do relaxed verify.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline"></td>
    <td class="lineNumber">392</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">LLVM_ATTRIBUTE_UNUSED static void</td>
    <td class="lineNumber">393</td>
    <td class="codeline">LLVM_ATTRIBUTE_UNUSED static void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">checkClobberSanity(const MemoryAccess *Start, MemoryAccess *ClobberAt,</td>
    <td class="lineNumber">394</td>
    <td class="codeline">checkClobberSanity(const MemoryAccess *Start, MemoryAccess *ClobberAt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">                   const MemoryLocation &StartLoc, const MemorySSA &MSSA,</td>
    <td class="lineNumber">395</td>
    <td class="codeline">                   const MemoryLocation &StartLoc, const MemorySSA &MSSA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">                   const UpwardsMemoryQuery &Query, BatchAAResults &AA,</td>
    <td class="lineNumber">396</td>
    <td class="codeline">                   const UpwardsMemoryQuery &Query, BatchAAResults &AA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">                   bool AllowImpreciseClobber = false) {</td>
    <td class="lineNumber">397</td>
    <td class="codeline">                   bool AllowImpreciseClobber = false) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  assert(MSSA.dominates(ClobberAt, Start) && "Clobber doesn't dominate start?");</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  assert(MSSA.dominates(ClobberAt, Start) && "Clobber doesn't dominate start?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline"></td>
    <td class="lineNumber">399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  if (MSSA.isLiveOnEntryDef(Start)) {</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  if (MSSA.isLiveOnEntryDef(Start)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">    assert(MSSA.isLiveOnEntryDef(ClobberAt) &&</td>
    <td class="lineNumber">401</td>
    <td class="codeline">    assert(MSSA.isLiveOnEntryDef(ClobberAt) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">           "liveOnEntry must clobber itself");</td>
    <td class="lineNumber">402</td>
    <td class="codeline">           "liveOnEntry must clobber itself");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">403</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline"></td>
    <td class="lineNumber">405</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">  bool FoundClobber = false;</td>
    <td class="lineNumber">406</td>
    <td class="codeline">  bool FoundClobber = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">  DenseSet<ConstMemoryAccessPair> VisitedPhis;</td>
    <td class="lineNumber">407</td>
    <td class="codeline">  DenseSet<ConstMemoryAccessPair> VisitedPhis;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">  SmallVector<ConstMemoryAccessPair, 8> Worklist;</td>
    <td class="lineNumber">408</td>
    <td class="codeline">  SmallVector<ConstMemoryAccessPair, 8> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  Worklist.emplace_back(Start, StartLoc);</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  Worklist.emplace_back(Start, StartLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">  // Walk all paths from Start to ClobberAt, while looking for clobbers. If one</td>
    <td class="lineNumber">410</td>
    <td class="codeline">  // Walk all paths from Start to ClobberAt, while looking for clobbers. If one</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  // is found, complain.</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  // is found, complain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">    auto MAP = Worklist.pop_back_val();</td>
    <td class="lineNumber">413</td>
    <td class="codeline">    auto MAP = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">    // All we care about is that nothing from Start to ClobberAt clobbers Start.</td>
    <td class="lineNumber">414</td>
    <td class="codeline">    // All we care about is that nothing from Start to ClobberAt clobbers Start.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">    // We learn nothing from revisiting nodes.</td>
    <td class="lineNumber">415</td>
    <td class="codeline">    // We learn nothing from revisiting nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">    if (!VisitedPhis.insert(MAP).second)</td>
    <td class="lineNumber">416</td>
    <td class="codeline">    if (!VisitedPhis.insert(MAP).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">417</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline"></td>
    <td class="lineNumber">418</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">    for (const auto *MA : def_chain(MAP.first)) {</td>
    <td class="lineNumber">419</td>
    <td class="codeline">    for (const auto *MA : def_chain(MAP.first)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">      if (MA == ClobberAt) {</td>
    <td class="lineNumber">420</td>
    <td class="codeline">      if (MA == ClobberAt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">        if (const auto *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td class="lineNumber">421</td>
    <td class="codeline">        if (const auto *MD = dyn_cast<MemoryDef>(MA)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">          // instructionClobbersQuery isn't essentially free, so don't use `|=`,</td>
    <td class="lineNumber">422</td>
    <td class="codeline">          // instructionClobbersQuery isn't essentially free, so don't use `|=`,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">          // since it won't let us short-circuit.</td>
    <td class="lineNumber">423</td>
    <td class="codeline">          // since it won't let us short-circuit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">          //</td>
    <td class="lineNumber">424</td>
    <td class="codeline">          //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">          // Also, note that this can't be hoisted out of the `Worklist` loop,</td>
    <td class="lineNumber">425</td>
    <td class="codeline">          // Also, note that this can't be hoisted out of the `Worklist` loop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">          // since MD may only act as a clobber for 1 of N MemoryLocations.</td>
    <td class="lineNumber">426</td>
    <td class="codeline">          // since MD may only act as a clobber for 1 of N MemoryLocations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">          FoundClobber = FoundClobber || MSSA.isLiveOnEntryDef(MD);</td>
    <td class="lineNumber">427</td>
    <td class="codeline">          FoundClobber = FoundClobber || MSSA.isLiveOnEntryDef(MD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">          if (!FoundClobber) {</td>
    <td class="lineNumber">428</td>
    <td class="codeline">          if (!FoundClobber) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">            if (instructionClobbersQuery(MD, MAP.second, Query.Inst, AA))</td>
    <td class="lineNumber">429</td>
    <td class="codeline">            if (instructionClobbersQuery(MD, MAP.second, Query.Inst, AA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">              FoundClobber = true;</td>
    <td class="lineNumber">430</td>
    <td class="codeline">              FoundClobber = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">431</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">432</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">433</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">434</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline"></td>
    <td class="lineNumber">435</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">      // We should never hit liveOnEntry, unless it's the clobber.</td>
    <td class="lineNumber">436</td>
    <td class="codeline">      // We should never hit liveOnEntry, unless it's the clobber.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">      assert(!MSSA.isLiveOnEntryDef(MA) && "Hit liveOnEntry before clobber?");</td>
    <td class="lineNumber">437</td>
    <td class="codeline">      assert(!MSSA.isLiveOnEntryDef(MA) && "Hit liveOnEntry before clobber?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">      if (const auto *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td class="lineNumber">439</td>
    <td class="codeline">      if (const auto *MD = dyn_cast<MemoryDef>(MA)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">        // If Start is a Def, skip self.</td>
    <td class="lineNumber">440</td>
    <td class="codeline">        // If Start is a Def, skip self.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">        if (MD == Start)</td>
    <td class="lineNumber">441</td>
    <td class="codeline">        if (MD == Start)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">442</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">        assert(!instructionClobbersQuery(MD, MAP.second, Query.Inst, AA) &&</td>
    <td class="lineNumber">444</td>
    <td class="codeline">        assert(!instructionClobbersQuery(MD, MAP.second, Query.Inst, AA) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">               "Found clobber before reaching ClobberAt!");</td>
    <td class="lineNumber">445</td>
    <td class="codeline">               "Found clobber before reaching ClobberAt!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">446</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">447</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">      if (const auto *MU = dyn_cast<MemoryUse>(MA)) {</td>
    <td class="lineNumber">449</td>
    <td class="codeline">      if (const auto *MU = dyn_cast<MemoryUse>(MA)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">        (void)MU;</td>
    <td class="lineNumber">450</td>
    <td class="codeline">        (void)MU;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">        assert (MU == Start &&</td>
    <td class="lineNumber">451</td>
    <td class="codeline">        assert (MU == Start &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">                "Can only find use in def chain if Start is a use");</td>
    <td class="lineNumber">452</td>
    <td class="codeline">                "Can only find use in def chain if Start is a use");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">453</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">454</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">      assert(isa<MemoryPhi>(MA));</td>
    <td class="lineNumber">456</td>
    <td class="codeline">      assert(isa<MemoryPhi>(MA));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline"></td>
    <td class="lineNumber">457</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">      // Add reachable phi predecessors</td>
    <td class="lineNumber">458</td>
    <td class="codeline">      // Add reachable phi predecessors</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">      for (auto ItB = upward_defs_begin(</td>
    <td class="lineNumber">459</td>
    <td class="codeline">      for (auto ItB = upward_defs_begin(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">                    {const_cast<MemoryAccess *>(MA), MAP.second},</td>
    <td class="lineNumber">460</td>
    <td class="codeline">                    {const_cast<MemoryAccess *>(MA), MAP.second},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">                    MSSA.getDomTree()),</td>
    <td class="lineNumber">461</td>
    <td class="codeline">                    MSSA.getDomTree()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">                ItE = upward_defs_end();</td>
    <td class="lineNumber">462</td>
    <td class="codeline">                ItE = upward_defs_end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">           ItB != ItE; ++ItB)</td>
    <td class="lineNumber">463</td>
    <td class="codeline">           ItB != ItE; ++ItB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">        if (MSSA.getDomTree().isReachableFromEntry(ItB.getPhiArgBlock()))</td>
    <td class="lineNumber">464</td>
    <td class="codeline">        if (MSSA.getDomTree().isReachableFromEntry(ItB.getPhiArgBlock()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">          Worklist.emplace_back(*ItB);</td>
    <td class="lineNumber">465</td>
    <td class="codeline">          Worklist.emplace_back(*ItB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">466</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline"></td>
    <td class="lineNumber">468</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">  // If the verify is done following an optimization, it's possible that</td>
    <td class="lineNumber">469</td>
    <td class="codeline">  // If the verify is done following an optimization, it's possible that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  // ClobberAt was a conservative clobbering, that we can now infer is not a</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  // ClobberAt was a conservative clobbering, that we can now infer is not a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">  // true clobbering access. Don't fail the verify if that's the case.</td>
    <td class="lineNumber">471</td>
    <td class="codeline">  // true clobbering access. Don't fail the verify if that's the case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  // We do have accesses that claim they're optimized, but could be optimized</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  // We do have accesses that claim they're optimized, but could be optimized</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  // further. Updating all these can be expensive, so allow it for now (FIXME).</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  // further. Updating all these can be expensive, so allow it for now (FIXME).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  if (AllowImpreciseClobber)</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  if (AllowImpreciseClobber)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">475</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  // If ClobberAt is a MemoryPhi, we can assume something above it acted as a</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  // If ClobberAt is a MemoryPhi, we can assume something above it acted as a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  // clobber. Otherwise, `ClobberAt` should've acted as a clobber at some point.</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  // clobber. Otherwise, `ClobberAt` should've acted as a clobber at some point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  assert((isa<MemoryPhi>(ClobberAt) || FoundClobber) &&</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  assert((isa<MemoryPhi>(ClobberAt) || FoundClobber) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">         "ClobberAt never acted as a clobber");</td>
    <td class="lineNumber">480</td>
    <td class="codeline">         "ClobberAt never acted as a clobber");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">}</td>
    <td class="lineNumber">481</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline"></td>
    <td class="lineNumber">482</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">483</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline"></td>
    <td class="lineNumber">484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">/// Our algorithm for walking (and trying to optimize) clobbers, all wrapped up</td>
    <td class="lineNumber">485</td>
    <td class="codeline">/// Our algorithm for walking (and trying to optimize) clobbers, all wrapped up</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">/// in one class.</td>
    <td class="lineNumber">486</td>
    <td class="codeline">/// in one class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">class ClobberWalker {</td>
    <td class="lineNumber">487</td>
    <td class="codeline">class ClobberWalker {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">  /// Save a few bytes by using unsigned instead of size_t.</td>
    <td class="lineNumber">488</td>
    <td class="codeline">  /// Save a few bytes by using unsigned instead of size_t.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  using ListIndex = unsigned;</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  using ListIndex = unsigned;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline"></td>
    <td class="lineNumber">490</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  /// Represents a span of contiguous MemoryDefs, potentially ending in a</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  /// Represents a span of contiguous MemoryDefs, potentially ending in a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  /// MemoryPhi.</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  /// MemoryPhi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  struct DefPath {</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  struct DefPath {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">    MemoryLocation Loc;</td>
    <td class="lineNumber">494</td>
    <td class="codeline">    MemoryLocation Loc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">    // Note that, because we always walk in reverse, Last will always dominate</td>
    <td class="lineNumber">495</td>
    <td class="codeline">    // Note that, because we always walk in reverse, Last will always dominate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">    // First. Also note that First and Last are inclusive.</td>
    <td class="lineNumber">496</td>
    <td class="codeline">    // First. Also note that First and Last are inclusive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">    MemoryAccess *First;</td>
    <td class="lineNumber">497</td>
    <td class="codeline">    MemoryAccess *First;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">    MemoryAccess *Last;</td>
    <td class="lineNumber">498</td>
    <td class="codeline">    MemoryAccess *Last;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    std::optional<ListIndex> Previous;</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    std::optional<ListIndex> Previous;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline"></td>
    <td class="lineNumber">500</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">    DefPath(const MemoryLocation &Loc, MemoryAccess *First, MemoryAccess *Last,</td>
    <td class="lineNumber">501</td>
    <td class="codeline">    DefPath(const MemoryLocation &Loc, MemoryAccess *First, MemoryAccess *Last,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">            std::optional<ListIndex> Previous)</td>
    <td class="lineNumber">502</td>
    <td class="codeline">            std::optional<ListIndex> Previous)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">        : Loc(Loc), First(First), Last(Last), Previous(Previous) {}</td>
    <td class="lineNumber">503</td>
    <td class="codeline">        : Loc(Loc), First(First), Last(Last), Previous(Previous) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">    DefPath(const MemoryLocation &Loc, MemoryAccess *Init,</td>
    <td class="lineNumber">505</td>
    <td class="codeline">    DefPath(const MemoryLocation &Loc, MemoryAccess *Init,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">            std::optional<ListIndex> Previous)</td>
    <td class="lineNumber">506</td>
    <td class="codeline">            std::optional<ListIndex> Previous)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">        : DefPath(Loc, Init, Init, Previous) {}</td>
    <td class="lineNumber">507</td>
    <td class="codeline">        : DefPath(Loc, Init, Init, Previous) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline"></td>
    <td class="lineNumber">509</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  const MemorySSA &MSSA;</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  const MemorySSA &MSSA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  DominatorTree &DT;</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  DominatorTree &DT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  BatchAAResults *AA;</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  BatchAAResults *AA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">  UpwardsMemoryQuery *Query;</td>
    <td class="lineNumber">513</td>
    <td class="codeline">  UpwardsMemoryQuery *Query;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  unsigned *UpwardWalkLimit;</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  unsigned *UpwardWalkLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline"></td>
    <td class="lineNumber">515</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  // Phi optimization bookkeeping:</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  // Phi optimization bookkeeping:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">  // List of DefPath to process during the current phi optimization walk.</td>
    <td class="lineNumber">517</td>
    <td class="codeline">  // List of DefPath to process during the current phi optimization walk.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">  SmallVector<DefPath, 32> Paths;</td>
    <td class="lineNumber">518</td>
    <td class="codeline">  SmallVector<DefPath, 32> Paths;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  // List of visited <Access, Location> pairs; we can skip paths already</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  // List of visited <Access, Location> pairs; we can skip paths already</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">  // visited with the same memory location.</td>
    <td class="lineNumber">520</td>
    <td class="codeline">  // visited with the same memory location.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  DenseSet<ConstMemoryAccessPair> VisitedPhis;</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  DenseSet<ConstMemoryAccessPair> VisitedPhis;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline"></td>
    <td class="lineNumber">522</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  /// Find the nearest def or phi that `From` can legally be optimized to.</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  /// Find the nearest def or phi that `From` can legally be optimized to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">  const MemoryAccess *getWalkTarget(const MemoryPhi *From) const {</td>
    <td class="lineNumber">524</td>
    <td class="codeline">  const MemoryAccess *getWalkTarget(const MemoryPhi *From) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">    assert(From->getNumOperands() && "Phi with no operands?");</td>
    <td class="lineNumber">525</td>
    <td class="codeline">    assert(From->getNumOperands() && "Phi with no operands?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">    BasicBlock *BB = From->getBlock();</td>
    <td class="lineNumber">527</td>
    <td class="codeline">    BasicBlock *BB = From->getBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">    MemoryAccess *Result = MSSA.getLiveOnEntryDef();</td>
    <td class="lineNumber">528</td>
    <td class="codeline">    MemoryAccess *Result = MSSA.getLiveOnEntryDef();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">    DomTreeNode *Node = DT.getNode(BB);</td>
    <td class="lineNumber">529</td>
    <td class="codeline">    DomTreeNode *Node = DT.getNode(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">    while ((Node = Node->getIDom())) {</td>
    <td class="lineNumber">530</td>
    <td class="codeline">    while ((Node = Node->getIDom())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">      auto *Defs = MSSA.getBlockDefs(Node->getBlock());</td>
    <td class="lineNumber">531</td>
    <td class="codeline">      auto *Defs = MSSA.getBlockDefs(Node->getBlock());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">      if (Defs)</td>
    <td class="lineNumber">532</td>
    <td class="codeline">      if (Defs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">        return &*Defs->rbegin();</td>
    <td class="lineNumber">533</td>
    <td class="codeline">        return &*Defs->rbegin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">534</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">    return Result;</td>
    <td class="lineNumber">535</td>
    <td class="codeline">    return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline"></td>
    <td class="lineNumber">537</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">  /// Result of calling walkToPhiOrClobber.</td>
    <td class="lineNumber">538</td>
    <td class="codeline">  /// Result of calling walkToPhiOrClobber.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  struct UpwardsWalkResult {</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  struct UpwardsWalkResult {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">    /// The "Result" of the walk. Either a clobber, the last thing we walked, or</td>
    <td class="lineNumber">540</td>
    <td class="codeline">    /// The "Result" of the walk. Either a clobber, the last thing we walked, or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">    /// both. Include alias info when clobber found.</td>
    <td class="lineNumber">541</td>
    <td class="codeline">    /// both. Include alias info when clobber found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">    MemoryAccess *Result;</td>
    <td class="lineNumber">542</td>
    <td class="codeline">    MemoryAccess *Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">    bool IsKnownClobber;</td>
    <td class="lineNumber">543</td>
    <td class="codeline">    bool IsKnownClobber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">544</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline"></td>
    <td class="lineNumber">545</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  /// Walk to the next Phi or Clobber in the def chain starting at Desc.Last.</td>
    <td class="lineNumber">546</td>
    <td class="codeline">  /// Walk to the next Phi or Clobber in the def chain starting at Desc.Last.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  /// This will update Desc.Last as it walks. It will (optionally) also stop at</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  /// This will update Desc.Last as it walks. It will (optionally) also stop at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  /// StopAt.</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  /// StopAt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">549</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  /// This does not test for whether StopAt is a clobber</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  /// This does not test for whether StopAt is a clobber</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">  UpwardsWalkResult</td>
    <td class="lineNumber">551</td>
    <td class="codeline">  UpwardsWalkResult</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  walkToPhiOrClobber(DefPath &Desc, const MemoryAccess *StopAt = nullptr,</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  walkToPhiOrClobber(DefPath &Desc, const MemoryAccess *StopAt = nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">                     const MemoryAccess *SkipStopAt = nullptr) const {</td>
    <td class="lineNumber">553</td>
    <td class="codeline">                     const MemoryAccess *SkipStopAt = nullptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">    assert(!isa<MemoryUse>(Desc.Last) && "Uses don't exist in my world");</td>
    <td class="lineNumber">554</td>
    <td class="codeline">    assert(!isa<MemoryUse>(Desc.Last) && "Uses don't exist in my world");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">    assert(UpwardWalkLimit && "Need a valid walk limit");</td>
    <td class="lineNumber">555</td>
    <td class="codeline">    assert(UpwardWalkLimit && "Need a valid walk limit");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">    bool LimitAlreadyReached = false;</td>
    <td class="lineNumber">556</td>
    <td class="codeline">    bool LimitAlreadyReached = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">    // (*UpwardWalkLimit) may be 0 here, due to the loop in tryOptimizePhi. Set</td>
    <td class="lineNumber">557</td>
    <td class="codeline">    // (*UpwardWalkLimit) may be 0 here, due to the loop in tryOptimizePhi. Set</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">    // it to 1. This will not do any alias() calls. It either returns in the</td>
    <td class="lineNumber">558</td>
    <td class="codeline">    // it to 1. This will not do any alias() calls. It either returns in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">    // first iteration in the loop below, or is set back to 0 if all def chains</td>
    <td class="lineNumber">559</td>
    <td class="codeline">    // first iteration in the loop below, or is set back to 0 if all def chains</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">    // are free of MemoryDefs.</td>
    <td class="lineNumber">560</td>
    <td class="codeline">    // are free of MemoryDefs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">    if (!*UpwardWalkLimit) {</td>
    <td class="lineNumber">561</td>
    <td class="codeline">    if (!*UpwardWalkLimit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">      *UpwardWalkLimit = 1;</td>
    <td class="lineNumber">562</td>
    <td class="codeline">      *UpwardWalkLimit = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">      LimitAlreadyReached = true;</td>
    <td class="lineNumber">563</td>
    <td class="codeline">      LimitAlreadyReached = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">564</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">    for (MemoryAccess *Current : def_chain(Desc.Last)) {</td>
    <td class="lineNumber">566</td>
    <td class="codeline">    for (MemoryAccess *Current : def_chain(Desc.Last)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">      Desc.Last = Current;</td>
    <td class="lineNumber">567</td>
    <td class="codeline">      Desc.Last = Current;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">      if (Current == StopAt || Current == SkipStopAt)</td>
    <td class="lineNumber">568</td>
    <td class="codeline">      if (Current == StopAt || Current == SkipStopAt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">        return {Current, false};</td>
    <td class="lineNumber">569</td>
    <td class="codeline">        return {Current, false};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">      if (auto *MD = dyn_cast<MemoryDef>(Current)) {</td>
    <td class="lineNumber">571</td>
    <td class="codeline">      if (auto *MD = dyn_cast<MemoryDef>(Current)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">        if (MSSA.isLiveOnEntryDef(MD))</td>
    <td class="lineNumber">572</td>
    <td class="codeline">        if (MSSA.isLiveOnEntryDef(MD))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">          return {MD, true};</td>
    <td class="lineNumber">573</td>
    <td class="codeline">          return {MD, true};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline"></td>
    <td class="lineNumber">574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">        if (!--*UpwardWalkLimit)</td>
    <td class="lineNumber">575</td>
    <td class="codeline">        if (!--*UpwardWalkLimit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">          return {Current, true};</td>
    <td class="lineNumber">576</td>
    <td class="codeline">          return {Current, true};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline"></td>
    <td class="lineNumber">577</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">        if (instructionClobbersQuery(MD, Desc.Loc, Query->Inst, *AA))</td>
    <td class="lineNumber">578</td>
    <td class="codeline">        if (instructionClobbersQuery(MD, Desc.Loc, Query->Inst, *AA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">          return {MD, true};</td>
    <td class="lineNumber">579</td>
    <td class="codeline">          return {MD, true};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">580</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">581</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">    if (LimitAlreadyReached)</td>
    <td class="lineNumber">583</td>
    <td class="codeline">    if (LimitAlreadyReached)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">      *UpwardWalkLimit = 0;</td>
    <td class="lineNumber">584</td>
    <td class="codeline">      *UpwardWalkLimit = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline"></td>
    <td class="lineNumber">585</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">    assert(isa<MemoryPhi>(Desc.Last) &&</td>
    <td class="lineNumber">586</td>
    <td class="codeline">    assert(isa<MemoryPhi>(Desc.Last) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">           "Ended at a non-clobber that's not a phi?");</td>
    <td class="lineNumber">587</td>
    <td class="codeline">           "Ended at a non-clobber that's not a phi?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">    return {Desc.Last, false};</td>
    <td class="lineNumber">588</td>
    <td class="codeline">    return {Desc.Last, false};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">  void addSearches(MemoryPhi *Phi, SmallVectorImpl<ListIndex> &PausedSearches,</td>
    <td class="lineNumber">591</td>
    <td class="codeline">  void addSearches(MemoryPhi *Phi, SmallVectorImpl<ListIndex> &PausedSearches,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">                   ListIndex PriorNode) {</td>
    <td class="lineNumber">592</td>
    <td class="codeline">                   ListIndex PriorNode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    auto UpwardDefsBegin = upward_defs_begin({Phi, Paths[PriorNode].Loc}, DT);</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    auto UpwardDefsBegin = upward_defs_begin({Phi, Paths[PriorNode].Loc}, DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">    auto UpwardDefs = make_range(UpwardDefsBegin, upward_defs_end());</td>
    <td class="lineNumber">594</td>
    <td class="codeline">    auto UpwardDefs = make_range(UpwardDefsBegin, upward_defs_end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">    for (const MemoryAccessPair &P : UpwardDefs) {</td>
    <td class="lineNumber">595</td>
    <td class="codeline">    for (const MemoryAccessPair &P : UpwardDefs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">      PausedSearches.push_back(Paths.size());</td>
    <td class="lineNumber">596</td>
    <td class="codeline">      PausedSearches.push_back(Paths.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">      Paths.emplace_back(P.second, P.first, PriorNode);</td>
    <td class="lineNumber">597</td>
    <td class="codeline">      Paths.emplace_back(P.second, P.first, PriorNode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">598</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline"></td>
    <td class="lineNumber">600</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">  /// Represents a search that terminated after finding a clobber. This clobber</td>
    <td class="lineNumber">601</td>
    <td class="codeline">  /// Represents a search that terminated after finding a clobber. This clobber</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">  /// may or may not be present in the path of defs from LastNode..SearchStart,</td>
    <td class="lineNumber">602</td>
    <td class="codeline">  /// may or may not be present in the path of defs from LastNode..SearchStart,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">  /// since it may have been retrieved from cache.</td>
    <td class="lineNumber">603</td>
    <td class="codeline">  /// since it may have been retrieved from cache.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  struct TerminatedPath {</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  struct TerminatedPath {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    MemoryAccess *Clobber;</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    MemoryAccess *Clobber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">    ListIndex LastNode;</td>
    <td class="lineNumber">606</td>
    <td class="codeline">    ListIndex LastNode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">607</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline"></td>
    <td class="lineNumber">608</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">  /// Get an access that keeps us from optimizing to the given phi.</td>
    <td class="lineNumber">609</td>
    <td class="codeline">  /// Get an access that keeps us from optimizing to the given phi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">610</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">  /// PausedSearches is an array of indices into the Paths array. Its incoming</td>
    <td class="lineNumber">611</td>
    <td class="codeline">  /// PausedSearches is an array of indices into the Paths array. Its incoming</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">  /// value is the indices of searches that stopped at the last phi optimization</td>
    <td class="lineNumber">612</td>
    <td class="codeline">  /// value is the indices of searches that stopped at the last phi optimization</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">  /// target. It's left in an unspecified state.</td>
    <td class="lineNumber">613</td>
    <td class="codeline">  /// target. It's left in an unspecified state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">614</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  /// If this returns std::nullopt, NewPaused is a vector of searches that</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  /// If this returns std::nullopt, NewPaused is a vector of searches that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  /// state.</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  /// state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">  std::optional<TerminatedPath></td>
    <td class="lineNumber">618</td>
    <td class="codeline">  std::optional<TerminatedPath></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  getBlockingAccess(const MemoryAccess *StopWhere,</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  getBlockingAccess(const MemoryAccess *StopWhere,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">                    SmallVectorImpl<ListIndex> &PausedSearches,</td>
    <td class="lineNumber">620</td>
    <td class="codeline">                    SmallVectorImpl<ListIndex> &PausedSearches,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">                    SmallVectorImpl<ListIndex> &NewPaused,</td>
    <td class="lineNumber">621</td>
    <td class="codeline">                    SmallVectorImpl<ListIndex> &NewPaused,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">                    SmallVectorImpl<TerminatedPath> &Terminated) {</td>
    <td class="lineNumber">622</td>
    <td class="codeline">                    SmallVectorImpl<TerminatedPath> &Terminated) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">    assert(!PausedSearches.empty() && "No searches to continue?");</td>
    <td class="lineNumber">623</td>
    <td class="codeline">    assert(!PausedSearches.empty() && "No searches to continue?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline"></td>
    <td class="lineNumber">624</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">    // BFS vs DFS really doesn't make a difference here, so just do a DFS with</td>
    <td class="lineNumber">625</td>
    <td class="codeline">    // BFS vs DFS really doesn't make a difference here, so just do a DFS with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">    // PausedSearches as our stack.</td>
    <td class="lineNumber">626</td>
    <td class="codeline">    // PausedSearches as our stack.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">    while (!PausedSearches.empty()) {</td>
    <td class="lineNumber">627</td>
    <td class="codeline">    while (!PausedSearches.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">      ListIndex PathIndex = PausedSearches.pop_back_val();</td>
    <td class="lineNumber">628</td>
    <td class="codeline">      ListIndex PathIndex = PausedSearches.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">      DefPath &Node = Paths[PathIndex];</td>
    <td class="lineNumber">629</td>
    <td class="codeline">      DefPath &Node = Paths[PathIndex];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">      // If we've already visited this path with this MemoryLocation, we don't</td>
    <td class="lineNumber">631</td>
    <td class="codeline">      // If we've already visited this path with this MemoryLocation, we don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">      // need to do so again.</td>
    <td class="lineNumber">632</td>
    <td class="codeline">      // need to do so again.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">633</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">      // NOTE: That we just drop these paths on the ground makes caching</td>
    <td class="lineNumber">634</td>
    <td class="codeline">      // NOTE: That we just drop these paths on the ground makes caching</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">      // behavior sporadic. e.g. given a diamond:</td>
    <td class="lineNumber">635</td>
    <td class="codeline">      // behavior sporadic. e.g. given a diamond:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">      //  A</td>
    <td class="lineNumber">636</td>
    <td class="codeline">      //  A</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">      // B C</td>
    <td class="lineNumber">637</td>
    <td class="codeline">      // B C</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">      //  D</td>
    <td class="lineNumber">638</td>
    <td class="codeline">      //  D</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">639</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">      // ...If we walk D, B, A, C, we'll only cache the result of phi</td>
    <td class="lineNumber">640</td>
    <td class="codeline">      // ...If we walk D, B, A, C, we'll only cache the result of phi</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">      // optimization for A, B, and D; C will be skipped because it dies here.</td>
    <td class="lineNumber">641</td>
    <td class="codeline">      // optimization for A, B, and D; C will be skipped because it dies here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">      // This arguably isn't the worst thing ever, since:</td>
    <td class="lineNumber">642</td>
    <td class="codeline">      // This arguably isn't the worst thing ever, since:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">      //   - We generally query things in a top-down order, so if we got below D</td>
    <td class="lineNumber">643</td>
    <td class="codeline">      //   - We generally query things in a top-down order, so if we got below D</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">      //     without needing cache entries for {C, MemLoc}, then chances are</td>
    <td class="lineNumber">644</td>
    <td class="codeline">      //     without needing cache entries for {C, MemLoc}, then chances are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">      //     that those cache entries would end up ultimately unused.</td>
    <td class="lineNumber">645</td>
    <td class="codeline">      //     that those cache entries would end up ultimately unused.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">      //   - We still cache things for A, so C only needs to walk up a bit.</td>
    <td class="lineNumber">646</td>
    <td class="codeline">      //   - We still cache things for A, so C only needs to walk up a bit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">      // If this behavior becomes problematic, we can fix without a ton of extra</td>
    <td class="lineNumber">647</td>
    <td class="codeline">      // If this behavior becomes problematic, we can fix without a ton of extra</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">      // work.</td>
    <td class="lineNumber">648</td>
    <td class="codeline">      // work.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">      if (!VisitedPhis.insert({Node.Last, Node.Loc}).second)</td>
    <td class="lineNumber">649</td>
    <td class="codeline">      if (!VisitedPhis.insert({Node.Last, Node.Loc}).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">650</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline"></td>
    <td class="lineNumber">651</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">      const MemoryAccess *SkipStopWhere = nullptr;</td>
    <td class="lineNumber">652</td>
    <td class="codeline">      const MemoryAccess *SkipStopWhere = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">      if (Query->SkipSelfAccess && Node.Loc == Query->StartingLoc) {</td>
    <td class="lineNumber">653</td>
    <td class="codeline">      if (Query->SkipSelfAccess && Node.Loc == Query->StartingLoc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">        assert(isa<MemoryDef>(Query->OriginalAccess));</td>
    <td class="lineNumber">654</td>
    <td class="codeline">        assert(isa<MemoryDef>(Query->OriginalAccess));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">        SkipStopWhere = Query->OriginalAccess;</td>
    <td class="lineNumber">655</td>
    <td class="codeline">        SkipStopWhere = Query->OriginalAccess;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">656</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">      UpwardsWalkResult Res = walkToPhiOrClobber(Node,</td>
    <td class="lineNumber">658</td>
    <td class="codeline">      UpwardsWalkResult Res = walkToPhiOrClobber(Node,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">                                                 /*StopAt=*/StopWhere,</td>
    <td class="lineNumber">659</td>
    <td class="codeline">                                                 /*StopAt=*/StopWhere,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">                                                 /*SkipStopAt=*/SkipStopWhere);</td>
    <td class="lineNumber">660</td>
    <td class="codeline">                                                 /*SkipStopAt=*/SkipStopWhere);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">      if (Res.IsKnownClobber) {</td>
    <td class="lineNumber">661</td>
    <td class="codeline">      if (Res.IsKnownClobber) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">        assert(Res.Result != StopWhere && Res.Result != SkipStopWhere);</td>
    <td class="lineNumber">662</td>
    <td class="codeline">        assert(Res.Result != StopWhere && Res.Result != SkipStopWhere);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">        // If this wasn't a cache hit, we hit a clobber when walking. That's a</td>
    <td class="lineNumber">664</td>
    <td class="codeline">        // If this wasn't a cache hit, we hit a clobber when walking. That's a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">        // failure.</td>
    <td class="lineNumber">665</td>
    <td class="codeline">        // failure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">        TerminatedPath Term{Res.Result, PathIndex};</td>
    <td class="lineNumber">666</td>
    <td class="codeline">        TerminatedPath Term{Res.Result, PathIndex};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">        if (!MSSA.dominates(Res.Result, StopWhere))</td>
    <td class="lineNumber">667</td>
    <td class="codeline">        if (!MSSA.dominates(Res.Result, StopWhere))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">          return Term;</td>
    <td class="lineNumber">668</td>
    <td class="codeline">          return Term;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline"></td>
    <td class="lineNumber">669</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">        // Otherwise, it's a valid thing to potentially optimize to.</td>
    <td class="lineNumber">670</td>
    <td class="codeline">        // Otherwise, it's a valid thing to potentially optimize to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">        Terminated.push_back(Term);</td>
    <td class="lineNumber">671</td>
    <td class="codeline">        Terminated.push_back(Term);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">672</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">673</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline"></td>
    <td class="lineNumber">674</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">      if (Res.Result == StopWhere || Res.Result == SkipStopWhere) {</td>
    <td class="lineNumber">675</td>
    <td class="codeline">      if (Res.Result == StopWhere || Res.Result == SkipStopWhere) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">        // We've hit our target. Save this path off for if we want to continue</td>
    <td class="lineNumber">676</td>
    <td class="codeline">        // We've hit our target. Save this path off for if we want to continue</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">        // walking. If we are in the mode of skipping the OriginalAccess, and</td>
    <td class="lineNumber">677</td>
    <td class="codeline">        // walking. If we are in the mode of skipping the OriginalAccess, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">        // we've reached back to the OriginalAccess, do not save path, we've</td>
    <td class="lineNumber">678</td>
    <td class="codeline">        // we've reached back to the OriginalAccess, do not save path, we've</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">        // just looped back to self.</td>
    <td class="lineNumber">679</td>
    <td class="codeline">        // just looped back to self.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">        if (Res.Result != SkipStopWhere)</td>
    <td class="lineNumber">680</td>
    <td class="codeline">        if (Res.Result != SkipStopWhere)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">          NewPaused.push_back(PathIndex);</td>
    <td class="lineNumber">681</td>
    <td class="codeline">          NewPaused.push_back(PathIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">682</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">683</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline"></td>
    <td class="lineNumber">684</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">      assert(!MSSA.isLiveOnEntryDef(Res.Result) && "liveOnEntry is a clobber");</td>
    <td class="lineNumber">685</td>
    <td class="codeline">      assert(!MSSA.isLiveOnEntryDef(Res.Result) && "liveOnEntry is a clobber");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">      addSearches(cast<MemoryPhi>(Res.Result), PausedSearches, PathIndex);</td>
    <td class="lineNumber">686</td>
    <td class="codeline">      addSearches(cast<MemoryPhi>(Res.Result), PausedSearches, PathIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">687</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline"></td>
    <td class="lineNumber">688</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">689</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  template <typename T, typename Walker></td>
    <td class="lineNumber">692</td>
    <td class="codeline">  template <typename T, typename Walker></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  struct generic_def_path_iterator</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  struct generic_def_path_iterator</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">      : public iterator_facade_base<generic_def_path_iterator<T, Walker>,</td>
    <td class="lineNumber">694</td>
    <td class="codeline">      : public iterator_facade_base<generic_def_path_iterator<T, Walker>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">                                    std::forward_iterator_tag, T *> {</td>
    <td class="lineNumber">695</td>
    <td class="codeline">                                    std::forward_iterator_tag, T *> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">    generic_def_path_iterator() = default;</td>
    <td class="lineNumber">696</td>
    <td class="codeline">    generic_def_path_iterator() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">    generic_def_path_iterator(Walker *W, ListIndex N) : W(W), N(N) {}</td>
    <td class="lineNumber">697</td>
    <td class="codeline">    generic_def_path_iterator(Walker *W, ListIndex N) : W(W), N(N) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline"></td>
    <td class="lineNumber">698</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">    T &operator*() const { return curNode(); }</td>
    <td class="lineNumber">699</td>
    <td class="codeline">    T &operator*() const { return curNode(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline"></td>
    <td class="lineNumber">700</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">    generic_def_path_iterator &operator++() {</td>
    <td class="lineNumber">701</td>
    <td class="codeline">    generic_def_path_iterator &operator++() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">      N = curNode().Previous;</td>
    <td class="lineNumber">702</td>
    <td class="codeline">      N = curNode().Previous;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">703</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">704</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline"></td>
    <td class="lineNumber">705</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">    bool operator==(const generic_def_path_iterator &O) const {</td>
    <td class="lineNumber">706</td>
    <td class="codeline">    bool operator==(const generic_def_path_iterator &O) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">      if (N.has_value() != O.N.has_value())</td>
    <td class="lineNumber">707</td>
    <td class="codeline">      if (N.has_value() != O.N.has_value())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">708</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">      return !N || *N == *O.N;</td>
    <td class="lineNumber">709</td>
    <td class="codeline">      return !N || *N == *O.N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">710</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">  private:</td>
    <td class="lineNumber">712</td>
    <td class="codeline">  private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">    T &curNode() const { return W->Paths[*N]; }</td>
    <td class="lineNumber">713</td>
    <td class="codeline">    T &curNode() const { return W->Paths[*N]; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline"></td>
    <td class="lineNumber">714</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">    Walker *W = nullptr;</td>
    <td class="lineNumber">715</td>
    <td class="codeline">    Walker *W = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">    std::optional<ListIndex> N;</td>
    <td class="lineNumber">716</td>
    <td class="codeline">    std::optional<ListIndex> N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">717</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline"></td>
    <td class="lineNumber">718</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">  using def_path_iterator = generic_def_path_iterator<DefPath, ClobberWalker>;</td>
    <td class="lineNumber">719</td>
    <td class="codeline">  using def_path_iterator = generic_def_path_iterator<DefPath, ClobberWalker>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">  using const_def_path_iterator =</td>
    <td class="lineNumber">720</td>
    <td class="codeline">  using const_def_path_iterator =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">      generic_def_path_iterator<const DefPath, const ClobberWalker>;</td>
    <td class="lineNumber">721</td>
    <td class="codeline">      generic_def_path_iterator<const DefPath, const ClobberWalker>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  iterator_range<def_path_iterator> def_path(ListIndex From) {</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  iterator_range<def_path_iterator> def_path(ListIndex From) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">    return make_range(def_path_iterator(this, From), def_path_iterator());</td>
    <td class="lineNumber">724</td>
    <td class="codeline">    return make_range(def_path_iterator(this, From), def_path_iterator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">725</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">  iterator_range<const_def_path_iterator> const_def_path(ListIndex From) const {</td>
    <td class="lineNumber">727</td>
    <td class="codeline">  iterator_range<const_def_path_iterator> const_def_path(ListIndex From) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">    return make_range(const_def_path_iterator(this, From),</td>
    <td class="lineNumber">728</td>
    <td class="codeline">    return make_range(const_def_path_iterator(this, From),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">                      const_def_path_iterator());</td>
    <td class="lineNumber">729</td>
    <td class="codeline">                      const_def_path_iterator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">730</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline"></td>
    <td class="lineNumber">731</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">  struct OptznResult {</td>
    <td class="lineNumber">732</td>
    <td class="codeline">  struct OptznResult {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">    /// The path that contains our result.</td>
    <td class="lineNumber">733</td>
    <td class="codeline">    /// The path that contains our result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">    TerminatedPath PrimaryClobber;</td>
    <td class="lineNumber">734</td>
    <td class="codeline">    TerminatedPath PrimaryClobber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">    /// The paths that we can legally cache back from, but that aren't</td>
    <td class="lineNumber">735</td>
    <td class="codeline">    /// The paths that we can legally cache back from, but that aren't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">    /// necessarily the result of the Phi optimization.</td>
    <td class="lineNumber">736</td>
    <td class="codeline">    /// necessarily the result of the Phi optimization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">    SmallVector<TerminatedPath, 4> OtherClobbers;</td>
    <td class="lineNumber">737</td>
    <td class="codeline">    SmallVector<TerminatedPath, 4> OtherClobbers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">  ListIndex defPathIndex(const DefPath &N) const {</td>
    <td class="lineNumber">740</td>
    <td class="codeline">  ListIndex defPathIndex(const DefPath &N) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">    // The assert looks nicer if we don't need to do &N</td>
    <td class="lineNumber">741</td>
    <td class="codeline">    // The assert looks nicer if we don't need to do &N</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    const DefPath *NP = &N;</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    const DefPath *NP = &N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">    assert(!Paths.empty() && NP >= &Paths.front() && NP <= &Paths.back() &&</td>
    <td class="lineNumber">743</td>
    <td class="codeline">    assert(!Paths.empty() && NP >= &Paths.front() && NP <= &Paths.back() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">           "Out of bounds DefPath!");</td>
    <td class="lineNumber">744</td>
    <td class="codeline">           "Out of bounds DefPath!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">    return NP - &Paths.front();</td>
    <td class="lineNumber">745</td>
    <td class="codeline">    return NP - &Paths.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline"></td>
    <td class="lineNumber">747</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  /// Try to optimize a phi as best as we can. Returns a SmallVector of Paths</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  /// Try to optimize a phi as best as we can. Returns a SmallVector of Paths</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">  /// that act as legal clobbers. Note that this won't return *all* clobbers.</td>
    <td class="lineNumber">749</td>
    <td class="codeline">  /// that act as legal clobbers. Note that this won't return *all* clobbers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">750</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">  /// Phi optimization algorithm tl;dr:</td>
    <td class="lineNumber">751</td>
    <td class="codeline">  /// Phi optimization algorithm tl;dr:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">  ///   - Find the earliest def/phi, A, we can optimize to</td>
    <td class="lineNumber">752</td>
    <td class="codeline">  ///   - Find the earliest def/phi, A, we can optimize to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">  ///   - Find if all paths from the starting memory access ultimately reach A</td>
    <td class="lineNumber">753</td>
    <td class="codeline">  ///   - Find if all paths from the starting memory access ultimately reach A</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">  ///     - If not, optimization isn't possible.</td>
    <td class="lineNumber">754</td>
    <td class="codeline">  ///     - If not, optimization isn't possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">  ///     - Otherwise, walk from A to another clobber or phi, A'.</td>
    <td class="lineNumber">755</td>
    <td class="codeline">  ///     - Otherwise, walk from A to another clobber or phi, A'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">  ///       - If A' is a def, we're done.</td>
    <td class="lineNumber">756</td>
    <td class="codeline">  ///       - If A' is a def, we're done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">  ///       - If A' is a phi, try to optimize it.</td>
    <td class="lineNumber">757</td>
    <td class="codeline">  ///       - If A' is a phi, try to optimize it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">758</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">  /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path</td>
    <td class="lineNumber">759</td>
    <td class="codeline">  /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">  /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.</td>
    <td class="lineNumber">760</td>
    <td class="codeline">  /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">  OptznResult tryOptimizePhi(MemoryPhi *Phi, MemoryAccess *Start,</td>
    <td class="lineNumber">761</td>
    <td class="codeline">  OptznResult tryOptimizePhi(MemoryPhi *Phi, MemoryAccess *Start,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">                             const MemoryLocation &Loc) {</td>
    <td class="lineNumber">762</td>
    <td class="codeline">                             const MemoryLocation &Loc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">    assert(Paths.empty() && VisitedPhis.empty() &&</td>
    <td class="lineNumber">763</td>
    <td class="codeline">    assert(Paths.empty() && VisitedPhis.empty() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">           "Reset the optimization state.");</td>
    <td class="lineNumber">764</td>
    <td class="codeline">           "Reset the optimization state.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline"></td>
    <td class="lineNumber">765</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">    Paths.emplace_back(Loc, Start, Phi, std::nullopt);</td>
    <td class="lineNumber">766</td>
    <td class="codeline">    Paths.emplace_back(Loc, Start, Phi, std::nullopt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">    // Stores how many "valid" optimization nodes we had prior to calling</td>
    <td class="lineNumber">767</td>
    <td class="codeline">    // Stores how many "valid" optimization nodes we had prior to calling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">    // addSearches/getBlockingAccess. Necessary for caching if we had a blocker.</td>
    <td class="lineNumber">768</td>
    <td class="codeline">    // addSearches/getBlockingAccess. Necessary for caching if we had a blocker.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">    auto PriorPathsSize = Paths.size();</td>
    <td class="lineNumber">769</td>
    <td class="codeline">    auto PriorPathsSize = Paths.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline"></td>
    <td class="lineNumber">770</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">    SmallVector<ListIndex, 16> PausedSearches;</td>
    <td class="lineNumber">771</td>
    <td class="codeline">    SmallVector<ListIndex, 16> PausedSearches;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">    SmallVector<ListIndex, 8> NewPaused;</td>
    <td class="lineNumber">772</td>
    <td class="codeline">    SmallVector<ListIndex, 8> NewPaused;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">    SmallVector<TerminatedPath, 4> TerminatedPaths;</td>
    <td class="lineNumber">773</td>
    <td class="codeline">    SmallVector<TerminatedPath, 4> TerminatedPaths;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline"></td>
    <td class="lineNumber">774</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">    addSearches(Phi, PausedSearches, 0);</td>
    <td class="lineNumber">775</td>
    <td class="codeline">    addSearches(Phi, PausedSearches, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline"></td>
    <td class="lineNumber">776</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">    // Moves the TerminatedPath with the "most dominated" Clobber to the end of</td>
    <td class="lineNumber">777</td>
    <td class="codeline">    // Moves the TerminatedPath with the "most dominated" Clobber to the end of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">    // Paths.</td>
    <td class="lineNumber">778</td>
    <td class="codeline">    // Paths.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">    auto MoveDominatedPathToEnd = [&](SmallVectorImpl<TerminatedPath> &Paths) {</td>
    <td class="lineNumber">779</td>
    <td class="codeline">    auto MoveDominatedPathToEnd = [&](SmallVectorImpl<TerminatedPath> &Paths) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">      assert(!Paths.empty() && "Need a path to move");</td>
    <td class="lineNumber">780</td>
    <td class="codeline">      assert(!Paths.empty() && "Need a path to move");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">      auto Dom = Paths.begin();</td>
    <td class="lineNumber">781</td>
    <td class="codeline">      auto Dom = Paths.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">      for (auto I = std::next(Dom), E = Paths.end(); I != E; ++I)</td>
    <td class="lineNumber">782</td>
    <td class="codeline">      for (auto I = std::next(Dom), E = Paths.end(); I != E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">        if (!MSSA.dominates(I->Clobber, Dom->Clobber))</td>
    <td class="lineNumber">783</td>
    <td class="codeline">        if (!MSSA.dominates(I->Clobber, Dom->Clobber))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">          Dom = I;</td>
    <td class="lineNumber">784</td>
    <td class="codeline">          Dom = I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">      auto Last = Paths.end() - 1;</td>
    <td class="lineNumber">785</td>
    <td class="codeline">      auto Last = Paths.end() - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">      if (Last != Dom)</td>
    <td class="lineNumber">786</td>
    <td class="codeline">      if (Last != Dom)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">        std::iter_swap(Last, Dom);</td>
    <td class="lineNumber">787</td>
    <td class="codeline">        std::iter_swap(Last, Dom);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">788</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline"></td>
    <td class="lineNumber">789</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">    MemoryPhi *Current = Phi;</td>
    <td class="lineNumber">790</td>
    <td class="codeline">    MemoryPhi *Current = Phi;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">    while (true) {</td>
    <td class="lineNumber">791</td>
    <td class="codeline">    while (true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">      assert(!MSSA.isLiveOnEntryDef(Current) &&</td>
    <td class="lineNumber">792</td>
    <td class="codeline">      assert(!MSSA.isLiveOnEntryDef(Current) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">             "liveOnEntry wasn't treated as a clobber?");</td>
    <td class="lineNumber">793</td>
    <td class="codeline">             "liveOnEntry wasn't treated as a clobber?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline"></td>
    <td class="lineNumber">794</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">      const auto *Target = getWalkTarget(Current);</td>
    <td class="lineNumber">795</td>
    <td class="codeline">      const auto *Target = getWalkTarget(Current);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">      // If a TerminatedPath doesn't dominate Target, then it wasn't a legal</td>
    <td class="lineNumber">796</td>
    <td class="codeline">      // If a TerminatedPath doesn't dominate Target, then it wasn't a legal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">      // optimization for the prior phi.</td>
    <td class="lineNumber">797</td>
    <td class="codeline">      // optimization for the prior phi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">      assert(all_of(TerminatedPaths, [&](const TerminatedPath &P) {</td>
    <td class="lineNumber">798</td>
    <td class="codeline">      assert(all_of(TerminatedPaths, [&](const TerminatedPath &P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">        return MSSA.dominates(P.Clobber, Target);</td>
    <td class="lineNumber">799</td>
    <td class="codeline">        return MSSA.dominates(P.Clobber, Target);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">      }));</td>
    <td class="lineNumber">800</td>
    <td class="codeline">      }));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline"></td>
    <td class="lineNumber">801</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">      // FIXME: This is broken, because the Blocker may be reported to be</td>
    <td class="lineNumber">802</td>
    <td class="codeline">      // FIXME: This is broken, because the Blocker may be reported to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">      // liveOnEntry, and we'll happily wait for that to disappear (read: never)</td>
    <td class="lineNumber">803</td>
    <td class="codeline">      // liveOnEntry, and we'll happily wait for that to disappear (read: never)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">      // For the moment, this is fine, since we do nothing with blocker info.</td>
    <td class="lineNumber">804</td>
    <td class="codeline">      // For the moment, this is fine, since we do nothing with blocker info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">      if (std::optional<TerminatedPath> Blocker = getBlockingAccess(</td>
    <td class="lineNumber">805</td>
    <td class="codeline">      if (std::optional<TerminatedPath> Blocker = getBlockingAccess(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">              Target, PausedSearches, NewPaused, TerminatedPaths)) {</td>
    <td class="lineNumber">806</td>
    <td class="codeline">              Target, PausedSearches, NewPaused, TerminatedPaths)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">        // Find the node we started at. We can't search based on N->Last, since</td>
    <td class="lineNumber">808</td>
    <td class="codeline">        // Find the node we started at. We can't search based on N->Last, since</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">        // we may have gone around a loop with a different MemoryLocation.</td>
    <td class="lineNumber">809</td>
    <td class="codeline">        // we may have gone around a loop with a different MemoryLocation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">        auto Iter = find_if(def_path(Blocker->LastNode), [&](const DefPath &N) {</td>
    <td class="lineNumber">810</td>
    <td class="codeline">        auto Iter = find_if(def_path(Blocker->LastNode), [&](const DefPath &N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">          return defPathIndex(N) < PriorPathsSize;</td>
    <td class="lineNumber">811</td>
    <td class="codeline">          return defPathIndex(N) < PriorPathsSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">812</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">        assert(Iter != def_path_iterator());</td>
    <td class="lineNumber">813</td>
    <td class="codeline">        assert(Iter != def_path_iterator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">        DefPath &CurNode = *Iter;</td>
    <td class="lineNumber">815</td>
    <td class="codeline">        DefPath &CurNode = *Iter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">        assert(CurNode.Last == Current);</td>
    <td class="lineNumber">816</td>
    <td class="codeline">        assert(CurNode.Last == Current);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline"></td>
    <td class="lineNumber">817</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">        // Two things:</td>
    <td class="lineNumber">818</td>
    <td class="codeline">        // Two things:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">        // A. We can't reliably cache all of NewPaused back. Consider a case</td>
    <td class="lineNumber">819</td>
    <td class="codeline">        // A. We can't reliably cache all of NewPaused back. Consider a case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">        //    where we have two paths in NewPaused; one of which can't optimize</td>
    <td class="lineNumber">820</td>
    <td class="codeline">        //    where we have two paths in NewPaused; one of which can't optimize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">        //    above this phi, whereas the other can. If we cache the second path</td>
    <td class="lineNumber">821</td>
    <td class="codeline">        //    above this phi, whereas the other can. If we cache the second path</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">        //    back, we'll end up with suboptimal cache entries. We can handle</td>
    <td class="lineNumber">822</td>
    <td class="codeline">        //    back, we'll end up with suboptimal cache entries. We can handle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">        //    cases like this a bit better when we either try to find all</td>
    <td class="lineNumber">823</td>
    <td class="codeline">        //    cases like this a bit better when we either try to find all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">        //    clobbers that block phi optimization, or when our cache starts</td>
    <td class="lineNumber">824</td>
    <td class="codeline">        //    clobbers that block phi optimization, or when our cache starts</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">        //    supporting unfinished searches.</td>
    <td class="lineNumber">825</td>
    <td class="codeline">        //    supporting unfinished searches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">        // B. We can't reliably cache TerminatedPaths back here without doing</td>
    <td class="lineNumber">826</td>
    <td class="codeline">        // B. We can't reliably cache TerminatedPaths back here without doing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">        //    extra checks; consider a case like:</td>
    <td class="lineNumber">827</td>
    <td class="codeline">        //    extra checks; consider a case like:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">        //       T</td>
    <td class="lineNumber">828</td>
    <td class="codeline">        //       T</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">        //      / \</td>
    <td class="lineNumber">829</td>
    <td class="codeline">        //      / \</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">        //     D   C</td>
    <td class="lineNumber">830</td>
    <td class="codeline">        //     D   C</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">        //      \ /</td>
    <td class="lineNumber">831</td>
    <td class="codeline">        //      \ /</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">        //       S</td>
    <td class="lineNumber">832</td>
    <td class="codeline">        //       S</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">        //    Where T is our target, C is a node with a clobber on it, D is a</td>
    <td class="lineNumber">833</td>
    <td class="codeline">        //    Where T is our target, C is a node with a clobber on it, D is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">        //    diamond (with a clobber *only* on the left or right node, N), and</td>
    <td class="lineNumber">834</td>
    <td class="codeline">        //    diamond (with a clobber *only* on the left or right node, N), and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">        //    S is our start. Say we walk to D, through the node opposite N</td>
    <td class="lineNumber">835</td>
    <td class="codeline">        //    S is our start. Say we walk to D, through the node opposite N</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">        //    (read: ignoring the clobber), and see a cache entry in the top</td>
    <td class="lineNumber">836</td>
    <td class="codeline">        //    (read: ignoring the clobber), and see a cache entry in the top</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">        //    node of D. That cache entry gets put into TerminatedPaths. We then</td>
    <td class="lineNumber">837</td>
    <td class="codeline">        //    node of D. That cache entry gets put into TerminatedPaths. We then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">        //    walk up to C (N is later in our worklist), find the clobber, and</td>
    <td class="lineNumber">838</td>
    <td class="codeline">        //    walk up to C (N is later in our worklist), find the clobber, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">        //    quit. If we append TerminatedPaths to OtherClobbers, we'll cache</td>
    <td class="lineNumber">839</td>
    <td class="codeline">        //    quit. If we append TerminatedPaths to OtherClobbers, we'll cache</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">        //    the bottom part of D to the cached clobber, ignoring the clobber</td>
    <td class="lineNumber">840</td>
    <td class="codeline">        //    the bottom part of D to the cached clobber, ignoring the clobber</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">        //    in N. Again, this problem goes away if we start tracking all</td>
    <td class="lineNumber">841</td>
    <td class="codeline">        //    in N. Again, this problem goes away if we start tracking all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">        //    blockers for a given phi optimization.</td>
    <td class="lineNumber">842</td>
    <td class="codeline">        //    blockers for a given phi optimization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">        TerminatedPath Result{CurNode.Last, defPathIndex(CurNode)};</td>
    <td class="lineNumber">843</td>
    <td class="codeline">        TerminatedPath Result{CurNode.Last, defPathIndex(CurNode)};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">        return {Result, {}};</td>
    <td class="lineNumber">844</td>
    <td class="codeline">        return {Result, {}};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">845</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline"></td>
    <td class="lineNumber">846</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">      // If there's nothing left to search, then all paths led to valid clobbers</td>
    <td class="lineNumber">847</td>
    <td class="codeline">      // If there's nothing left to search, then all paths led to valid clobbers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">      // that we got from our cache; pick the nearest to the start, and allow</td>
    <td class="lineNumber">848</td>
    <td class="codeline">      // that we got from our cache; pick the nearest to the start, and allow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">      // the rest to be cached back.</td>
    <td class="lineNumber">849</td>
    <td class="codeline">      // the rest to be cached back.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">      if (NewPaused.empty()) {</td>
    <td class="lineNumber">850</td>
    <td class="codeline">      if (NewPaused.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">        MoveDominatedPathToEnd(TerminatedPaths);</td>
    <td class="lineNumber">851</td>
    <td class="codeline">        MoveDominatedPathToEnd(TerminatedPaths);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">        TerminatedPath Result = TerminatedPaths.pop_back_val();</td>
    <td class="lineNumber">852</td>
    <td class="codeline">        TerminatedPath Result = TerminatedPaths.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">        return {Result, std::move(TerminatedPaths)};</td>
    <td class="lineNumber">853</td>
    <td class="codeline">        return {Result, std::move(TerminatedPaths)};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">854</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline"></td>
    <td class="lineNumber">855</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">      MemoryAccess *DefChainEnd = nullptr;</td>
    <td class="lineNumber">856</td>
    <td class="codeline">      MemoryAccess *DefChainEnd = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">      SmallVector<TerminatedPath, 4> Clobbers;</td>
    <td class="lineNumber">857</td>
    <td class="codeline">      SmallVector<TerminatedPath, 4> Clobbers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">      for (ListIndex Paused : NewPaused) {</td>
    <td class="lineNumber">858</td>
    <td class="codeline">      for (ListIndex Paused : NewPaused) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">        UpwardsWalkResult WR = walkToPhiOrClobber(Paths[Paused]);</td>
    <td class="lineNumber">859</td>
    <td class="codeline">        UpwardsWalkResult WR = walkToPhiOrClobber(Paths[Paused]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">        if (WR.IsKnownClobber)</td>
    <td class="lineNumber">860</td>
    <td class="codeline">        if (WR.IsKnownClobber)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">          Clobbers.push_back({WR.Result, Paused});</td>
    <td class="lineNumber">861</td>
    <td class="codeline">          Clobbers.push_back({WR.Result, Paused});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">        else</td>
    <td class="lineNumber">862</td>
    <td class="codeline">        else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">          // Micro-opt: If we hit the end of the chain, save it.</td>
    <td class="lineNumber">863</td>
    <td class="codeline">          // Micro-opt: If we hit the end of the chain, save it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">          DefChainEnd = WR.Result;</td>
    <td class="lineNumber">864</td>
    <td class="codeline">          DefChainEnd = WR.Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">865</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline"></td>
    <td class="lineNumber">866</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">      if (!TerminatedPaths.empty()) {</td>
    <td class="lineNumber">867</td>
    <td class="codeline">      if (!TerminatedPaths.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">        // If we couldn't find the dominating phi/liveOnEntry in the above loop,</td>
    <td class="lineNumber">868</td>
    <td class="codeline">        // If we couldn't find the dominating phi/liveOnEntry in the above loop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">        // do it now.</td>
    <td class="lineNumber">869</td>
    <td class="codeline">        // do it now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">        if (!DefChainEnd)</td>
    <td class="lineNumber">870</td>
    <td class="codeline">        if (!DefChainEnd)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">          for (auto *MA : def_chain(const_cast<MemoryAccess *>(Target)))</td>
    <td class="lineNumber">871</td>
    <td class="codeline">          for (auto *MA : def_chain(const_cast<MemoryAccess *>(Target)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">            DefChainEnd = MA;</td>
    <td class="lineNumber">872</td>
    <td class="codeline">            DefChainEnd = MA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">        assert(DefChainEnd && "Failed to find dominating phi/liveOnEntry");</td>
    <td class="lineNumber">873</td>
    <td class="codeline">        assert(DefChainEnd && "Failed to find dominating phi/liveOnEntry");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">        // If any of the terminated paths don't dominate the phi we'll try to</td>
    <td class="lineNumber">875</td>
    <td class="codeline">        // If any of the terminated paths don't dominate the phi we'll try to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">        // optimize, we need to figure out what they are and quit.</td>
    <td class="lineNumber">876</td>
    <td class="codeline">        // optimize, we need to figure out what they are and quit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">        const BasicBlock *ChainBB = DefChainEnd->getBlock();</td>
    <td class="lineNumber">877</td>
    <td class="codeline">        const BasicBlock *ChainBB = DefChainEnd->getBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">        for (const TerminatedPath &TP : TerminatedPaths) {</td>
    <td class="lineNumber">878</td>
    <td class="codeline">        for (const TerminatedPath &TP : TerminatedPaths) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">          // Because we know that DefChainEnd is as "high" as we can go, we</td>
    <td class="lineNumber">879</td>
    <td class="codeline">          // Because we know that DefChainEnd is as "high" as we can go, we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">          // don't need local dominance checks; BB dominance is sufficient.</td>
    <td class="lineNumber">880</td>
    <td class="codeline">          // don't need local dominance checks; BB dominance is sufficient.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">          if (DT.dominates(ChainBB, TP.Clobber->getBlock()))</td>
    <td class="lineNumber">881</td>
    <td class="codeline">          if (DT.dominates(ChainBB, TP.Clobber->getBlock()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">            Clobbers.push_back(TP);</td>
    <td class="lineNumber">882</td>
    <td class="codeline">            Clobbers.push_back(TP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">883</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">884</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline"></td>
    <td class="lineNumber">885</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">      // If we have clobbers in the def chain, find the one closest to Current</td>
    <td class="lineNumber">886</td>
    <td class="codeline">      // If we have clobbers in the def chain, find the one closest to Current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">      // and quit.</td>
    <td class="lineNumber">887</td>
    <td class="codeline">      // and quit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">      if (!Clobbers.empty()) {</td>
    <td class="lineNumber">888</td>
    <td class="codeline">      if (!Clobbers.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">        MoveDominatedPathToEnd(Clobbers);</td>
    <td class="lineNumber">889</td>
    <td class="codeline">        MoveDominatedPathToEnd(Clobbers);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">        TerminatedPath Result = Clobbers.pop_back_val();</td>
    <td class="lineNumber">890</td>
    <td class="codeline">        TerminatedPath Result = Clobbers.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">        return {Result, std::move(Clobbers)};</td>
    <td class="lineNumber">891</td>
    <td class="codeline">        return {Result, std::move(Clobbers)};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">892</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline"></td>
    <td class="lineNumber">893</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">      assert(all_of(NewPaused,</td>
    <td class="lineNumber">894</td>
    <td class="codeline">      assert(all_of(NewPaused,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">                    [&](ListIndex I) { return Paths[I].Last == DefChainEnd; }));</td>
    <td class="lineNumber">895</td>
    <td class="codeline">                    [&](ListIndex I) { return Paths[I].Last == DefChainEnd; }));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline"></td>
    <td class="lineNumber">896</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">      // Because liveOnEntry is a clobber, this must be a phi.</td>
    <td class="lineNumber">897</td>
    <td class="codeline">      // Because liveOnEntry is a clobber, this must be a phi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">      auto *DefChainPhi = cast<MemoryPhi>(DefChainEnd);</td>
    <td class="lineNumber">898</td>
    <td class="codeline">      auto *DefChainPhi = cast<MemoryPhi>(DefChainEnd);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline"></td>
    <td class="lineNumber">899</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">      PriorPathsSize = Paths.size();</td>
    <td class="lineNumber">900</td>
    <td class="codeline">      PriorPathsSize = Paths.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">      PausedSearches.clear();</td>
    <td class="lineNumber">901</td>
    <td class="codeline">      PausedSearches.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">      for (ListIndex I : NewPaused)</td>
    <td class="lineNumber">902</td>
    <td class="codeline">      for (ListIndex I : NewPaused)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">        addSearches(DefChainPhi, PausedSearches, I);</td>
    <td class="lineNumber">903</td>
    <td class="codeline">        addSearches(DefChainPhi, PausedSearches, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">      NewPaused.clear();</td>
    <td class="lineNumber">904</td>
    <td class="codeline">      NewPaused.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline"></td>
    <td class="lineNumber">905</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">      Current = DefChainPhi;</td>
    <td class="lineNumber">906</td>
    <td class="codeline">      Current = DefChainPhi;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">907</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">908</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">  void verifyOptResult(const OptznResult &R) const {</td>
    <td class="lineNumber">910</td>
    <td class="codeline">  void verifyOptResult(const OptznResult &R) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">    assert(all_of(R.OtherClobbers, [&](const TerminatedPath &P) {</td>
    <td class="lineNumber">911</td>
    <td class="codeline">    assert(all_of(R.OtherClobbers, [&](const TerminatedPath &P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">      return MSSA.dominates(P.Clobber, R.PrimaryClobber.Clobber);</td>
    <td class="lineNumber">912</td>
    <td class="codeline">      return MSSA.dominates(P.Clobber, R.PrimaryClobber.Clobber);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">    }));</td>
    <td class="lineNumber">913</td>
    <td class="codeline">    }));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">914</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">  void resetPhiOptznState() {</td>
    <td class="lineNumber">916</td>
    <td class="codeline">  void resetPhiOptznState() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">    Paths.clear();</td>
    <td class="lineNumber">917</td>
    <td class="codeline">    Paths.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">    VisitedPhis.clear();</td>
    <td class="lineNumber">918</td>
    <td class="codeline">    VisitedPhis.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">919</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">921</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">  ClobberWalker(const MemorySSA &MSSA, DominatorTree &DT)</td>
    <td class="lineNumber">922</td>
    <td class="codeline">  ClobberWalker(const MemorySSA &MSSA, DominatorTree &DT)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">      : MSSA(MSSA), DT(DT) {}</td>
    <td class="lineNumber">923</td>
    <td class="codeline">      : MSSA(MSSA), DT(DT) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline"></td>
    <td class="lineNumber">924</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">  /// Finds the nearest clobber for the given query, optimizing phis if</td>
    <td class="lineNumber">925</td>
    <td class="codeline">  /// Finds the nearest clobber for the given query, optimizing phis if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">  /// possible.</td>
    <td class="lineNumber">926</td>
    <td class="codeline">  /// possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">  MemoryAccess *findClobber(BatchAAResults &BAA, MemoryAccess *Start,</td>
    <td class="lineNumber">927</td>
    <td class="codeline">  MemoryAccess *findClobber(BatchAAResults &BAA, MemoryAccess *Start,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">                            UpwardsMemoryQuery &Q, unsigned &UpWalkLimit) {</td>
    <td class="lineNumber">928</td>
    <td class="codeline">                            UpwardsMemoryQuery &Q, unsigned &UpWalkLimit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">    AA = &BAA;</td>
    <td class="lineNumber">929</td>
    <td class="codeline">    AA = &BAA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">    Query = &Q;</td>
    <td class="lineNumber">930</td>
    <td class="codeline">    Query = &Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">    UpwardWalkLimit = &UpWalkLimit;</td>
    <td class="lineNumber">931</td>
    <td class="codeline">    UpwardWalkLimit = &UpWalkLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">    // Starting limit must be > 0.</td>
    <td class="lineNumber">932</td>
    <td class="codeline">    // Starting limit must be > 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">    if (!UpWalkLimit)</td>
    <td class="lineNumber">933</td>
    <td class="codeline">    if (!UpWalkLimit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">      UpWalkLimit++;</td>
    <td class="lineNumber">934</td>
    <td class="codeline">      UpWalkLimit++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline"></td>
    <td class="lineNumber">935</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">    MemoryAccess *Current = Start;</td>
    <td class="lineNumber">936</td>
    <td class="codeline">    MemoryAccess *Current = Start;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">    // This walker pretends uses don't exist. If we're handed one, silently grab</td>
    <td class="lineNumber">937</td>
    <td class="codeline">    // This walker pretends uses don't exist. If we're handed one, silently grab</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">    // its def. (This has the nice side-effect of ensuring we never cache uses)</td>
    <td class="lineNumber">938</td>
    <td class="codeline">    // its def. (This has the nice side-effect of ensuring we never cache uses)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">    if (auto *MU = dyn_cast<MemoryUse>(Start))</td>
    <td class="lineNumber">939</td>
    <td class="codeline">    if (auto *MU = dyn_cast<MemoryUse>(Start))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">      Current = MU->getDefiningAccess();</td>
    <td class="lineNumber">940</td>
    <td class="codeline">      Current = MU->getDefiningAccess();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline"></td>
    <td class="lineNumber">941</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">    DefPath FirstDesc(Q.StartingLoc, Current, Current, std::nullopt);</td>
    <td class="lineNumber">942</td>
    <td class="codeline">    DefPath FirstDesc(Q.StartingLoc, Current, Current, std::nullopt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">    // Fast path for the overly-common case (no crazy phi optimization</td>
    <td class="lineNumber">943</td>
    <td class="codeline">    // Fast path for the overly-common case (no crazy phi optimization</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">    // necessary)</td>
    <td class="lineNumber">944</td>
    <td class="codeline">    // necessary)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">    UpwardsWalkResult WalkResult = walkToPhiOrClobber(FirstDesc);</td>
    <td class="lineNumber">945</td>
    <td class="codeline">    UpwardsWalkResult WalkResult = walkToPhiOrClobber(FirstDesc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">    MemoryAccess *Result;</td>
    <td class="lineNumber">946</td>
    <td class="codeline">    MemoryAccess *Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">    if (WalkResult.IsKnownClobber) {</td>
    <td class="lineNumber">947</td>
    <td class="codeline">    if (WalkResult.IsKnownClobber) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">      Result = WalkResult.Result;</td>
    <td class="lineNumber">948</td>
    <td class="codeline">      Result = WalkResult.Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">949</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">      OptznResult OptRes = tryOptimizePhi(cast<MemoryPhi>(FirstDesc.Last),</td>
    <td class="lineNumber">950</td>
    <td class="codeline">      OptznResult OptRes = tryOptimizePhi(cast<MemoryPhi>(FirstDesc.Last),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">                                          Current, Q.StartingLoc);</td>
    <td class="lineNumber">951</td>
    <td class="codeline">                                          Current, Q.StartingLoc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">      verifyOptResult(OptRes);</td>
    <td class="lineNumber">952</td>
    <td class="codeline">      verifyOptResult(OptRes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">      resetPhiOptznState();</td>
    <td class="lineNumber">953</td>
    <td class="codeline">      resetPhiOptznState();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">      Result = OptRes.PrimaryClobber.Clobber;</td>
    <td class="lineNumber">954</td>
    <td class="codeline">      Result = OptRes.PrimaryClobber.Clobber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">955</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">957</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">    if (!Q.SkipSelfAccess && *UpwardWalkLimit > 0)</td>
    <td class="lineNumber">958</td>
    <td class="codeline">    if (!Q.SkipSelfAccess && *UpwardWalkLimit > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">      checkClobberSanity(Current, Result, Q.StartingLoc, MSSA, Q, BAA);</td>
    <td class="lineNumber">959</td>
    <td class="codeline">      checkClobberSanity(Current, Result, Q.StartingLoc, MSSA, Q, BAA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">960</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">    return Result;</td>
    <td class="lineNumber">961</td>
    <td class="codeline">    return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">962</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">};</td>
    <td class="lineNumber">963</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline"></td>
    <td class="lineNumber">964</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">struct RenamePassData {</td>
    <td class="lineNumber">965</td>
    <td class="codeline">struct RenamePassData {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  DomTreeNode *DTN;</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  DomTreeNode *DTN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  DomTreeNode::const_iterator ChildIt;</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  DomTreeNode::const_iterator ChildIt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  MemoryAccess *IncomingVal;</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  MemoryAccess *IncomingVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline"></td>
    <td class="lineNumber">969</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">  RenamePassData(DomTreeNode *D, DomTreeNode::const_iterator It,</td>
    <td class="lineNumber">970</td>
    <td class="codeline">  RenamePassData(DomTreeNode *D, DomTreeNode::const_iterator It,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">                 MemoryAccess *M)</td>
    <td class="lineNumber">971</td>
    <td class="codeline">                 MemoryAccess *M)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">      : DTN(D), ChildIt(It), IncomingVal(M) {}</td>
    <td class="lineNumber">972</td>
    <td class="codeline">      : DTN(D), ChildIt(It), IncomingVal(M) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">  void swap(RenamePassData &RHS) {</td>
    <td class="lineNumber">974</td>
    <td class="codeline">  void swap(RenamePassData &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">    std::swap(DTN, RHS.DTN);</td>
    <td class="lineNumber">975</td>
    <td class="codeline">    std::swap(DTN, RHS.DTN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">    std::swap(ChildIt, RHS.ChildIt);</td>
    <td class="lineNumber">976</td>
    <td class="codeline">    std::swap(ChildIt, RHS.ChildIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">    std::swap(IncomingVal, RHS.IncomingVal);</td>
    <td class="lineNumber">977</td>
    <td class="codeline">    std::swap(IncomingVal, RHS.IncomingVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">978</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">};</td>
    <td class="lineNumber">979</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline"></td>
    <td class="lineNumber">980</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">981</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline"></td>
    <td class="lineNumber">982</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">983</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline"></td>
    <td class="lineNumber">984</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">class MemorySSA::ClobberWalkerBase {</td>
    <td class="lineNumber">985</td>
    <td class="codeline">class MemorySSA::ClobberWalkerBase {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">  ClobberWalker Walker;</td>
    <td class="lineNumber">986</td>
    <td class="codeline">  ClobberWalker Walker;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">  MemorySSA *MSSA;</td>
    <td class="lineNumber">987</td>
    <td class="codeline">  MemorySSA *MSSA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">989</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">  ClobberWalkerBase(MemorySSA *M, DominatorTree *D) : Walker(*M, *D), MSSA(M) {}</td>
    <td class="lineNumber">990</td>
    <td class="codeline">  ClobberWalkerBase(MemorySSA *M, DominatorTree *D) : Walker(*M, *D), MSSA(M) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccessBase(MemoryAccess *,</td>
    <td class="lineNumber">992</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccessBase(MemoryAccess *,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">                                              const MemoryLocation &,</td>
    <td class="lineNumber">993</td>
    <td class="codeline">                                              const MemoryLocation &,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">                                              BatchAAResults &, unsigned &);</td>
    <td class="lineNumber">994</td>
    <td class="codeline">                                              BatchAAResults &, unsigned &);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">  // Third argument (bool), defines whether the clobber search should skip the</td>
    <td class="lineNumber">995</td>
    <td class="codeline">  // Third argument (bool), defines whether the clobber search should skip the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">  // original queried access. If true, there will be a follow-up query searching</td>
    <td class="lineNumber">996</td>
    <td class="codeline">  // original queried access. If true, there will be a follow-up query searching</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">  // for a clobber access past "self". Note that the Optimized access is not</td>
    <td class="lineNumber">997</td>
    <td class="codeline">  // for a clobber access past "self". Note that the Optimized access is not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  // updated if a new clobber is found by this SkipSelf search. If this</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  // updated if a new clobber is found by this SkipSelf search. If this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">  // additional query becomes heavily used we may decide to cache the result.</td>
    <td class="lineNumber">999</td>
    <td class="codeline">  // additional query becomes heavily used we may decide to cache the result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">  // Walker instantiations will decide how to set the SkipSelf bool.</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">  // Walker instantiations will decide how to set the SkipSelf bool.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccessBase(MemoryAccess *, BatchAAResults &,</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccessBase(MemoryAccess *, BatchAAResults &,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">                                              unsigned &, bool,</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">                                              unsigned &, bool,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">                                              bool UseInvariantGroup = true);</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">                                              bool UseInvariantGroup = true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline"></td>
    <td class="lineNumber">1005</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">/// A MemorySSAWalker that does AA walks to disambiguate accesses. It no</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">/// A MemorySSAWalker that does AA walks to disambiguate accesses. It no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">/// longer does caching on its own, but the name has been retained for the</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">/// longer does caching on its own, but the name has been retained for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">/// moment.</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">/// moment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">class MemorySSA::CachingWalker final : public MemorySSAWalker {</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">class MemorySSA::CachingWalker final : public MemorySSAWalker {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">  ClobberWalkerBase *Walker;</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">  ClobberWalkerBase *Walker;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline"></td>
    <td class="lineNumber">1011</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">  CachingWalker(MemorySSA *M, ClobberWalkerBase *W)</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">  CachingWalker(MemorySSA *M, ClobberWalkerBase *W)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">      : MemorySSAWalker(M), Walker(W) {}</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">      : MemorySSAWalker(M), Walker(W) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">  ~CachingWalker() override = default;</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">  ~CachingWalker() override = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline"></td>
    <td class="lineNumber">1016</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">  using MemorySSAWalker::getClobberingMemoryAccess;</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">  using MemorySSAWalker::getClobberingMemoryAccess;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, BatchAAResults &BAA,</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, BatchAAResults &BAA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">                                          unsigned &UWL) {</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">                                          unsigned &UWL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, false);</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">                                          const MemoryLocation &Loc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">                                          BatchAAResults &BAA, unsigned &UWL) {</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">                                          BatchAAResults &BAA, unsigned &UWL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">    return Walker->getClobberingMemoryAccessBase(MA, Loc, BAA, UWL);</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">    return Walker->getClobberingMemoryAccessBase(MA, Loc, BAA, UWL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  // This method is not accessible outside of this file.</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  // This method is not accessible outside of this file.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccessWithoutInvariantGroup(</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccessWithoutInvariantGroup(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">      MemoryAccess *MA, BatchAAResults &BAA, unsigned &UWL) {</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">      MemoryAccess *MA, BatchAAResults &BAA, unsigned &UWL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, false, false);</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, false, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">                                          BatchAAResults &BAA) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">    return getClobberingMemoryAccess(MA, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">    return getClobberingMemoryAccess(MA, BAA, UpwardWalkLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">                                          const MemoryLocation &Loc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">                                          BatchAAResults &BAA) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">    return getClobberingMemoryAccess(MA, Loc, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">    return getClobberingMemoryAccess(MA, Loc, BAA, UpwardWalkLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline"></td>
    <td class="lineNumber">1045</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">  void invalidateInfo(MemoryAccess *MA) override {</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">  void invalidateInfo(MemoryAccess *MA) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">      MUD->resetOptimized();</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">      MUD->resetOptimized();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline"></td>
    <td class="lineNumber">1051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">class MemorySSA::SkipSelfWalker final : public MemorySSAWalker {</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">class MemorySSA::SkipSelfWalker final : public MemorySSAWalker {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">  ClobberWalkerBase *Walker;</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">  ClobberWalkerBase *Walker;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline"></td>
    <td class="lineNumber">1054</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">  SkipSelfWalker(MemorySSA *M, ClobberWalkerBase *W)</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">  SkipSelfWalker(MemorySSA *M, ClobberWalkerBase *W)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">      : MemorySSAWalker(M), Walker(W) {}</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">      : MemorySSAWalker(M), Walker(W) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">  ~SkipSelfWalker() override = default;</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">  ~SkipSelfWalker() override = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline"></td>
    <td class="lineNumber">1059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  using MemorySSAWalker::getClobberingMemoryAccess;</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  using MemorySSAWalker::getClobberingMemoryAccess;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline"></td>
    <td class="lineNumber">1061</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, BatchAAResults &BAA,</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, BatchAAResults &BAA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">                                          unsigned &UWL) {</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">                                          unsigned &UWL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, true);</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">                                          const MemoryLocation &Loc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">                                          BatchAAResults &BAA, unsigned &UWL) {</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">                                          BatchAAResults &BAA, unsigned &UWL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">    return Walker->getClobberingMemoryAccessBase(MA, Loc, BAA, UWL);</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">    return Walker->getClobberingMemoryAccessBase(MA, Loc, BAA, UWL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">                                          BatchAAResults &BAA) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">    return getClobberingMemoryAccess(MA, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">    return getClobberingMemoryAccess(MA, BAA, UpwardWalkLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">                                          const MemoryLocation &Loc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">                                          BatchAAResults &BAA) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">    return getClobberingMemoryAccess(MA, Loc, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">    return getClobberingMemoryAccess(MA, Loc, BAA, UpwardWalkLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline"></td>
    <td class="lineNumber">1083</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">  void invalidateInfo(MemoryAccess *MA) override {</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">  void invalidateInfo(MemoryAccess *MA) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">      MUD->resetOptimized();</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">      MUD->resetOptimized();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline"></td>
    <td class="lineNumber">1089</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">void MemorySSA::renameSuccessorPhis(BasicBlock *BB, MemoryAccess *IncomingVal,</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">void MemorySSA::renameSuccessorPhis(BasicBlock *BB, MemoryAccess *IncomingVal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">                                    bool RenameAllUses) {</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">                                    bool RenameAllUses) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">  // Pass through values to our successors</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">  // Pass through values to our successors</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">  for (const BasicBlock *S : successors(BB)) {</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">  for (const BasicBlock *S : successors(BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">    auto It = PerBlockAccesses.find(S);</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">    auto It = PerBlockAccesses.find(S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">    // Rename the phi nodes in our successor block</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">    // Rename the phi nodes in our successor block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">    if (It == PerBlockAccesses.end() || !isa<MemoryPhi>(It->second->front()))</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">    if (It == PerBlockAccesses.end() || !isa<MemoryPhi>(It->second->front()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">    AccessList *Accesses = It->second.get();</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">    AccessList *Accesses = It->second.get();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">    auto *Phi = cast<MemoryPhi>(&Accesses->front());</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">    auto *Phi = cast<MemoryPhi>(&Accesses->front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">    if (RenameAllUses) {</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">    if (RenameAllUses) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">      bool ReplacementDone = false;</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">      bool ReplacementDone = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">      for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I)</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">      for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">        if (Phi->getIncomingBlock(I) == BB) {</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">        if (Phi->getIncomingBlock(I) == BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">          Phi->setIncomingValue(I, IncomingVal);</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">          Phi->setIncomingValue(I, IncomingVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">          ReplacementDone = true;</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">          ReplacementDone = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">      (void) ReplacementDone;</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">      (void) ReplacementDone;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">      assert(ReplacementDone && "Incomplete phi during partial rename");</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">      assert(ReplacementDone && "Incomplete phi during partial rename");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">    } else</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">    } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">      Phi->addIncoming(IncomingVal, BB);</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">      Phi->addIncoming(IncomingVal, BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline"></td>
    <td class="lineNumber">1115</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">/// Rename a single basic block into MemorySSA form.</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">/// Rename a single basic block into MemorySSA form.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">/// Uses the standard SSA renaming algorithm.</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">/// Uses the standard SSA renaming algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">/// \returns The new incoming value.</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">/// \returns The new incoming value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">MemoryAccess *MemorySSA::renameBlock(BasicBlock *BB, MemoryAccess *IncomingVal,</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">MemoryAccess *MemorySSA::renameBlock(BasicBlock *BB, MemoryAccess *IncomingVal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">                                     bool RenameAllUses) {</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">                                     bool RenameAllUses) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">  auto It = PerBlockAccesses.find(BB);</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">  auto It = PerBlockAccesses.find(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">  // Skip most processing if the list is empty.</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">  // Skip most processing if the list is empty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">  if (It != PerBlockAccesses.end()) {</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">  if (It != PerBlockAccesses.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">    AccessList *Accesses = It->second.get();</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">    AccessList *Accesses = It->second.get();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">    for (MemoryAccess &L : *Accesses) {</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">    for (MemoryAccess &L : *Accesses) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">      if (MemoryUseOrDef *MUD = dyn_cast<MemoryUseOrDef>(&L)) {</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">      if (MemoryUseOrDef *MUD = dyn_cast<MemoryUseOrDef>(&L)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">        if (MUD->getDefiningAccess() == nullptr || RenameAllUses)</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">        if (MUD->getDefiningAccess() == nullptr || RenameAllUses)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">          MUD->setDefiningAccess(IncomingVal);</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">          MUD->setDefiningAccess(IncomingVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">        if (isa<MemoryDef>(&L))</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">        if (isa<MemoryDef>(&L))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">          IncomingVal = &L;</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">          IncomingVal = &L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">        IncomingVal = &L;</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">        IncomingVal = &L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">  return IncomingVal;</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">  return IncomingVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline"></td>
    <td class="lineNumber">1138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">/// This is the standard SSA renaming algorithm.</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">/// This is the standard SSA renaming algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">/// We walk the dominator tree in preorder, renaming accesses, and then filling</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">/// We walk the dominator tree in preorder, renaming accesses, and then filling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">/// in phi nodes in our successors.</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">/// in phi nodes in our successors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">void MemorySSA::renamePass(DomTreeNode *Root, MemoryAccess *IncomingVal,</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">void MemorySSA::renamePass(DomTreeNode *Root, MemoryAccess *IncomingVal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">                           SmallPtrSetImpl<BasicBlock *> &Visited,</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">                           SmallPtrSetImpl<BasicBlock *> &Visited,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">                           bool SkipVisited, bool RenameAllUses) {</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">                           bool SkipVisited, bool RenameAllUses) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">  assert(Root && "Trying to rename accesses in an unreachable block");</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">  assert(Root && "Trying to rename accesses in an unreachable block");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline"></td>
    <td class="lineNumber">1147</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">  SmallVector<RenamePassData, 32> WorkStack;</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">  SmallVector<RenamePassData, 32> WorkStack;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">  // Skip everything if we already renamed this block and we are skipping.</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">  // Skip everything if we already renamed this block and we are skipping.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">  // Note: You can't sink this into the if, because we need it to occur</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">  // Note: You can't sink this into the if, because we need it to occur</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">  // regardless of whether we skip blocks or not.</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">  // regardless of whether we skip blocks or not.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">  bool AlreadyVisited = !Visited.insert(Root->getBlock()).second;</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">  bool AlreadyVisited = !Visited.insert(Root->getBlock()).second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  if (SkipVisited && AlreadyVisited)</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  if (SkipVisited && AlreadyVisited)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline"></td>
    <td class="lineNumber">1155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">  IncomingVal = renameBlock(Root->getBlock(), IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">  IncomingVal = renameBlock(Root->getBlock(), IncomingVal, RenameAllUses);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">  renameSuccessorPhis(Root->getBlock(), IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">  renameSuccessorPhis(Root->getBlock(), IncomingVal, RenameAllUses);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">  WorkStack.push_back({Root, Root->begin(), IncomingVal});</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">  WorkStack.push_back({Root, Root->begin(), IncomingVal});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  while (!WorkStack.empty()) {</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  while (!WorkStack.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">    DomTreeNode *Node = WorkStack.back().DTN;</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">    DomTreeNode *Node = WorkStack.back().DTN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">    DomTreeNode::const_iterator ChildIt = WorkStack.back().ChildIt;</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">    DomTreeNode::const_iterator ChildIt = WorkStack.back().ChildIt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">    IncomingVal = WorkStack.back().IncomingVal;</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">    IncomingVal = WorkStack.back().IncomingVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline"></td>
    <td class="lineNumber">1164</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">    if (ChildIt == Node->end()) {</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">    if (ChildIt == Node->end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">      WorkStack.pop_back();</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">      WorkStack.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">      DomTreeNode *Child = *ChildIt;</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">      DomTreeNode *Child = *ChildIt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">      ++WorkStack.back().ChildIt;</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">      ++WorkStack.back().ChildIt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">      BasicBlock *BB = Child->getBlock();</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">      BasicBlock *BB = Child->getBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">      // Note: You can't sink this into the if, because we need it to occur</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">      // Note: You can't sink this into the if, because we need it to occur</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">      // regardless of whether we skip blocks or not.</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">      // regardless of whether we skip blocks or not.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">      AlreadyVisited = !Visited.insert(BB).second;</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">      AlreadyVisited = !Visited.insert(BB).second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">      if (SkipVisited && AlreadyVisited) {</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">      if (SkipVisited && AlreadyVisited) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">        // We already visited this during our renaming, which can happen when</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">        // We already visited this during our renaming, which can happen when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">        // being asked to rename multiple blocks. Figure out the incoming val,</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">        // being asked to rename multiple blocks. Figure out the incoming val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">        // which is the last def.</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">        // which is the last def.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">        // Incoming value can only change if there is a block def, and in that</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">        // Incoming value can only change if there is a block def, and in that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">        // case, it's the last block def in the list.</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">        // case, it's the last block def in the list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">        if (auto *BlockDefs = getWritableBlockDefs(BB))</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">        if (auto *BlockDefs = getWritableBlockDefs(BB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">          IncomingVal = &*BlockDefs->rbegin();</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">          IncomingVal = &*BlockDefs->rbegin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">      } else</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">      } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">        IncomingVal = renameBlock(BB, IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">        IncomingVal = renameBlock(BB, IncomingVal, RenameAllUses);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">      renameSuccessorPhis(BB, IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">      renameSuccessorPhis(BB, IncomingVal, RenameAllUses);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">      WorkStack.push_back({Child, Child->begin(), IncomingVal});</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">      WorkStack.push_back({Child, Child->begin(), IncomingVal});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline"></td>
    <td class="lineNumber">1189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">/// This handles unreachable block accesses by deleting phi nodes in</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">/// This handles unreachable block accesses by deleting phi nodes in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">/// unreachable blocks, and marking all other unreachable MemoryAccess's as</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">/// unreachable blocks, and marking all other unreachable MemoryAccess's as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">/// being uses of the live on entry definition.</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">/// being uses of the live on entry definition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">void MemorySSA::markUnreachableAsLiveOnEntry(BasicBlock *BB) {</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">void MemorySSA::markUnreachableAsLiveOnEntry(BasicBlock *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">  assert(!DT->isReachableFromEntry(BB) &&</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">  assert(!DT->isReachableFromEntry(BB) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">         "Reachable block found while handling unreachable blocks");</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">         "Reachable block found while handling unreachable blocks");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline"></td>
    <td class="lineNumber">1196</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">  // Make sure phi nodes in our reachable successors end up with a</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">  // Make sure phi nodes in our reachable successors end up with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">  // LiveOnEntryDef for our incoming edge, even though our block is forward</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">  // LiveOnEntryDef for our incoming edge, even though our block is forward</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">  // unreachable.  We could just disconnect these blocks from the CFG fully,</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">  // unreachable.  We could just disconnect these blocks from the CFG fully,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">  // but we do not right now.</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">  // but we do not right now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">  for (const BasicBlock *S : successors(BB)) {</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">  for (const BasicBlock *S : successors(BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">    if (!DT->isReachableFromEntry(S))</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">    if (!DT->isReachableFromEntry(S))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">    auto It = PerBlockAccesses.find(S);</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">    auto It = PerBlockAccesses.find(S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">    // Rename the phi nodes in our successor block</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">    // Rename the phi nodes in our successor block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">    if (It == PerBlockAccesses.end() || !isa<MemoryPhi>(It->second->front()))</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">    if (It == PerBlockAccesses.end() || !isa<MemoryPhi>(It->second->front()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">    AccessList *Accesses = It->second.get();</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">    AccessList *Accesses = It->second.get();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">    auto *Phi = cast<MemoryPhi>(&Accesses->front());</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">    auto *Phi = cast<MemoryPhi>(&Accesses->front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">    Phi->addIncoming(LiveOnEntryDef.get(), BB);</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">    Phi->addIncoming(LiveOnEntryDef.get(), BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">  auto It = PerBlockAccesses.find(BB);</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">  auto It = PerBlockAccesses.find(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  if (It == PerBlockAccesses.end())</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  if (It == PerBlockAccesses.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline"></td>
    <td class="lineNumber">1216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">  auto &Accesses = It->second;</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">  auto &Accesses = It->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  for (auto AI = Accesses->begin(), AE = Accesses->end(); AI != AE;) {</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  for (auto AI = Accesses->begin(), AE = Accesses->end(); AI != AE;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">    auto Next = std::next(AI);</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">    auto Next = std::next(AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">    // If we have a phi, just remove it. We are going to replace all</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">    // If we have a phi, just remove it. We are going to replace all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">    // users with live on entry.</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">    // users with live on entry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">    if (auto *UseOrDef = dyn_cast<MemoryUseOrDef>(AI))</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">    if (auto *UseOrDef = dyn_cast<MemoryUseOrDef>(AI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">      UseOrDef->setDefiningAccess(LiveOnEntryDef.get());</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">      UseOrDef->setDefiningAccess(LiveOnEntryDef.get());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">      Accesses->erase(AI);</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">      Accesses->erase(AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">    AI = Next;</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">    AI = Next;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline"></td>
    <td class="lineNumber">1229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">MemorySSA::MemorySSA(Function &Func, AliasAnalysis *AA, DominatorTree *DT)</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">MemorySSA::MemorySSA(Function &Func, AliasAnalysis *AA, DominatorTree *DT)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">    : DT(DT), F(Func), LiveOnEntryDef(nullptr), Walker(nullptr),</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">    : DT(DT), F(Func), LiveOnEntryDef(nullptr), Walker(nullptr),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">      SkipWalker(nullptr) {</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">      SkipWalker(nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">  // Build MemorySSA using a batch alias analysis. This reuses the internal</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">  // Build MemorySSA using a batch alias analysis. This reuses the internal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">  // state that AA collects during an alias()/getModRefInfo() call. This is</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">  // state that AA collects during an alias()/getModRefInfo() call. This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  // safe because there are no CFG changes while building MemorySSA and can</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  // safe because there are no CFG changes while building MemorySSA and can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">  // significantly reduce the time spent by the compiler in AA, because we will</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">  // significantly reduce the time spent by the compiler in AA, because we will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  // make queries about all the instructions in the Function.</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  // make queries about all the instructions in the Function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">  assert(AA && "No alias analysis?");</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">  assert(AA && "No alias analysis?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">  BatchAAResults BatchAA(*AA);</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">  BatchAAResults BatchAA(*AA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">  buildMemorySSA(BatchAA);</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">  buildMemorySSA(BatchAA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  // Intentionally leave AA to nullptr while building so we don't accidently</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  // Intentionally leave AA to nullptr while building so we don't accidently</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">  // use non-batch AliasAnalysis.</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">  // use non-batch AliasAnalysis.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">  this->AA = AA;</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">  this->AA = AA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">  // Also create the walker here.</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">  // Also create the walker here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">  getWalker();</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">  getWalker();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline"></td>
    <td class="lineNumber">1247</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">MemorySSA::~MemorySSA() {</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">MemorySSA::~MemorySSA() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">  // Drop all our references</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">  // Drop all our references</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">  for (const auto &Pair : PerBlockAccesses)</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">  for (const auto &Pair : PerBlockAccesses)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">    for (MemoryAccess &MA : *Pair.second)</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">    for (MemoryAccess &MA : *Pair.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">      MA.dropAllReferences();</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">      MA.dropAllReferences();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline"></td>
    <td class="lineNumber">1254</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">MemorySSA::AccessList *MemorySSA::getOrCreateAccessList(const BasicBlock *BB) {</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">MemorySSA::AccessList *MemorySSA::getOrCreateAccessList(const BasicBlock *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  auto Res = PerBlockAccesses.insert(std::make_pair(BB, nullptr));</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  auto Res = PerBlockAccesses.insert(std::make_pair(BB, nullptr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline"></td>
    <td class="lineNumber">1257</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  if (Res.second)</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  if (Res.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">    Res.first->second = std::make_unique<AccessList>();</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">    Res.first->second = std::make_unique<AccessList>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  return Res.first->second.get();</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  return Res.first->second.get();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline"></td>
    <td class="lineNumber">1262</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">MemorySSA::DefsList *MemorySSA::getOrCreateDefsList(const BasicBlock *BB) {</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">MemorySSA::DefsList *MemorySSA::getOrCreateDefsList(const BasicBlock *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">  auto Res = PerBlockDefs.insert(std::make_pair(BB, nullptr));</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">  auto Res = PerBlockDefs.insert(std::make_pair(BB, nullptr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline"></td>
    <td class="lineNumber">1265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">  if (Res.second)</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">  if (Res.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">    Res.first->second = std::make_unique<DefsList>();</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">    Res.first->second = std::make_unique<DefsList>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">  return Res.first->second.get();</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">  return Res.first->second.get();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline"></td>
    <td class="lineNumber">1270</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline"></td>
    <td class="lineNumber">1272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">/// This class is a batch walker of all MemoryUse's in the program, and points</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">/// This class is a batch walker of all MemoryUse's in the program, and points</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">/// their defining access at the thing that actually clobbers them.  Because it</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">/// their defining access at the thing that actually clobbers them.  Because it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">/// is a batch walker that touches everything, it does not operate like the</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">/// is a batch walker that touches everything, it does not operate like the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">/// other walkers.  This walker is basically performing a top-down SSA renaming</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">/// other walkers.  This walker is basically performing a top-down SSA renaming</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">/// pass, where the version stack is used as the cache.  This enables it to be</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">/// pass, where the version stack is used as the cache.  This enables it to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">/// significantly more time and memory efficient than using the regular walker,</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">/// significantly more time and memory efficient than using the regular walker,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">/// which is walking bottom-up.</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">/// which is walking bottom-up.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">class MemorySSA::OptimizeUses {</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">class MemorySSA::OptimizeUses {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">  OptimizeUses(MemorySSA *MSSA, CachingWalker *Walker, BatchAAResults *BAA,</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">  OptimizeUses(MemorySSA *MSSA, CachingWalker *Walker, BatchAAResults *BAA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">               DominatorTree *DT)</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">               DominatorTree *DT)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">      : MSSA(MSSA), Walker(Walker), AA(BAA), DT(DT) {}</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">      : MSSA(MSSA), Walker(Walker), AA(BAA), DT(DT) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">  void optimizeUses();</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">  void optimizeUses();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline"></td>
    <td class="lineNumber">1287</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">  /// This represents where a given memorylocation is in the stack.</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">  /// This represents where a given memorylocation is in the stack.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">  struct MemlocStackInfo {</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">  struct MemlocStackInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">    // This essentially is keeping track of versions of the stack. Whenever</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">    // This essentially is keeping track of versions of the stack. Whenever</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">    // the stack changes due to pushes or pops, these versions increase.</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">    // the stack changes due to pushes or pops, these versions increase.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">    unsigned long StackEpoch;</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">    unsigned long StackEpoch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">    unsigned long PopEpoch;</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">    unsigned long PopEpoch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">    // This is the lower bound of places on the stack to check. It is equal to</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">    // This is the lower bound of places on the stack to check. It is equal to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">    // the place the last stack walk ended.</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">    // the place the last stack walk ended.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">    // Note: Correctness depends on this being initialized to 0, which densemap</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">    // Note: Correctness depends on this being initialized to 0, which densemap</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">    // does</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">    // does</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">    unsigned long LowerBound;</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">    unsigned long LowerBound;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">    const BasicBlock *LowerBoundBlock;</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">    const BasicBlock *LowerBoundBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">    // This is where the last walk for this memory location ended.</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">    // This is where the last walk for this memory location ended.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">    unsigned long LastKill;</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">    unsigned long LastKill;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">    bool LastKillValid;</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">    bool LastKillValid;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline"></td>
    <td class="lineNumber">1305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">  void optimizeUsesInBlock(const BasicBlock *, unsigned long &, unsigned long &,</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">  void optimizeUsesInBlock(const BasicBlock *, unsigned long &, unsigned long &,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">                           SmallVectorImpl<MemoryAccess *> &,</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">                           SmallVectorImpl<MemoryAccess *> &,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">                           DenseMap<MemoryLocOrCall, MemlocStackInfo> &);</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">                           DenseMap<MemoryLocOrCall, MemlocStackInfo> &);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline"></td>
    <td class="lineNumber">1309</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">  MemorySSA *MSSA;</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">  MemorySSA *MSSA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">  CachingWalker *Walker;</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">  CachingWalker *Walker;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">  BatchAAResults *AA;</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">  BatchAAResults *AA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  DominatorTree *DT;</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  DominatorTree *DT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">/// Optimize the uses in a given block This is basically the SSA renaming</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">/// Optimize the uses in a given block This is basically the SSA renaming</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">/// algorithm, with one caveat: We are able to use a single stack for all</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">/// algorithm, with one caveat: We are able to use a single stack for all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">/// MemoryUses.  This is because the set of *possible* reaching MemoryDefs is</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">/// MemoryUses.  This is because the set of *possible* reaching MemoryDefs is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">/// the same for every MemoryUse.  The *actual* clobbering MemoryDef is just</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">/// the same for every MemoryUse.  The *actual* clobbering MemoryDef is just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">/// going to be some position in that stack of possible ones.</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">/// going to be some position in that stack of possible ones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">/// We track the stack positions that each MemoryLocation needs</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">/// We track the stack positions that each MemoryLocation needs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">/// to check, and last ended at.  This is because we only want to check the</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">/// to check, and last ended at.  This is because we only want to check the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">/// things that changed since last time.  The same MemoryLocation should</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">/// things that changed since last time.  The same MemoryLocation should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">/// get clobbered by the same store (getModRefInfo does not use invariantness or</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">/// get clobbered by the same store (getModRefInfo does not use invariantness or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">/// things like this, and if they start, we can modify MemoryLocOrCall to</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">/// things like this, and if they start, we can modify MemoryLocOrCall to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">/// include relevant data)</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">/// include relevant data)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">void MemorySSA::OptimizeUses::optimizeUsesInBlock(</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">void MemorySSA::OptimizeUses::optimizeUsesInBlock(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">    const BasicBlock *BB, unsigned long &StackEpoch, unsigned long &PopEpoch,</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">    const BasicBlock *BB, unsigned long &StackEpoch, unsigned long &PopEpoch,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">    SmallVectorImpl<MemoryAccess *> &VersionStack,</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">    SmallVectorImpl<MemoryAccess *> &VersionStack,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">    DenseMap<MemoryLocOrCall, MemlocStackInfo> &LocStackInfo) {</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">    DenseMap<MemoryLocOrCall, MemlocStackInfo> &LocStackInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline"></td>
    <td class="lineNumber">1334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">  /// If no accesses, nothing to do.</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">  /// If no accesses, nothing to do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">  MemorySSA::AccessList *Accesses = MSSA->getWritableBlockAccesses(BB);</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">  MemorySSA::AccessList *Accesses = MSSA->getWritableBlockAccesses(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">  if (Accesses == nullptr)</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">  if (Accesses == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline"></td>
    <td class="lineNumber">1339</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">  // Pop everything that doesn't dominate the current block off the stack,</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">  // Pop everything that doesn't dominate the current block off the stack,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">  // increment the PopEpoch to account for this.</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">  // increment the PopEpoch to account for this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">  while (true) {</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">  while (true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">    assert(</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">    assert(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">        !VersionStack.empty() &&</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">        !VersionStack.empty() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">        "Version stack should have liveOnEntry sentinel dominating everything");</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">        "Version stack should have liveOnEntry sentinel dominating everything");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">    BasicBlock *BackBlock = VersionStack.back()->getBlock();</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">    BasicBlock *BackBlock = VersionStack.back()->getBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">    if (DT->dominates(BackBlock, BB))</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">    if (DT->dominates(BackBlock, BB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">    while (VersionStack.back()->getBlock() == BackBlock)</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">    while (VersionStack.back()->getBlock() == BackBlock)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">      VersionStack.pop_back();</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">      VersionStack.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">    ++PopEpoch;</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">    ++PopEpoch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline"></td>
    <td class="lineNumber">1353</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">  for (MemoryAccess &MA : *Accesses) {</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">  for (MemoryAccess &MA : *Accesses) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">    auto *MU = dyn_cast<MemoryUse>(&MA);</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">    auto *MU = dyn_cast<MemoryUse>(&MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">    if (!MU) {</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">    if (!MU) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">      VersionStack.push_back(&MA);</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">      VersionStack.push_back(&MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">      ++StackEpoch;</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">      ++StackEpoch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline"></td>
    <td class="lineNumber">1361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">    if (MU->isOptimized())</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">    if (MU->isOptimized())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline"></td>
    <td class="lineNumber">1364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">    MemoryLocOrCall UseMLOC(MU);</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">    MemoryLocOrCall UseMLOC(MU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">    auto &LocInfo = LocStackInfo[UseMLOC];</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">    auto &LocInfo = LocStackInfo[UseMLOC];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">    // If the pop epoch changed, it means we've removed stuff from top of</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">    // If the pop epoch changed, it means we've removed stuff from top of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">    // stack due to changing blocks. We may have to reset the lower bound or</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">    // stack due to changing blocks. We may have to reset the lower bound or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">    // last kill info.</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">    // last kill info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">    if (LocInfo.PopEpoch != PopEpoch) {</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">    if (LocInfo.PopEpoch != PopEpoch) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">      LocInfo.PopEpoch = PopEpoch;</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">      LocInfo.PopEpoch = PopEpoch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">      LocInfo.StackEpoch = StackEpoch;</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">      LocInfo.StackEpoch = StackEpoch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">      // If the lower bound was in something that no longer dominates us, we</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">      // If the lower bound was in something that no longer dominates us, we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">      // have to reset it.</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">      // have to reset it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">      // We can't simply track stack size, because the stack may have had</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">      // We can't simply track stack size, because the stack may have had</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">      // pushes/pops in the meantime.</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">      // pushes/pops in the meantime.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">      // XXX: This is non-optimal, but only is slower cases with heavily</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">      // XXX: This is non-optimal, but only is slower cases with heavily</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">      // branching dominator trees.  To get the optimal number of queries would</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">      // branching dominator trees.  To get the optimal number of queries would</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">      // be to make lowerbound and lastkill a per-loc stack, and pop it until</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">      // be to make lowerbound and lastkill a per-loc stack, and pop it until</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">      // the top of that stack dominates us.  This does not seem worth it ATM.</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">      // the top of that stack dominates us.  This does not seem worth it ATM.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">      // A much cheaper optimization would be to always explore the deepest</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">      // A much cheaper optimization would be to always explore the deepest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">      // branch of the dominator tree first. This will guarantee this resets on</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">      // branch of the dominator tree first. This will guarantee this resets on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">      // the smallest set of blocks.</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">      // the smallest set of blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">      if (LocInfo.LowerBoundBlock && LocInfo.LowerBoundBlock != BB &&</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">      if (LocInfo.LowerBoundBlock && LocInfo.LowerBoundBlock != BB &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">          !DT->dominates(LocInfo.LowerBoundBlock, BB)) {</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">          !DT->dominates(LocInfo.LowerBoundBlock, BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">        // Reset the lower bound of things to check.</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">        // Reset the lower bound of things to check.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">        // TODO: Some day we should be able to reset to last kill, rather than</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">        // TODO: Some day we should be able to reset to last kill, rather than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">        // 0.</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">        // 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">        LocInfo.LowerBound = 0;</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">        LocInfo.LowerBound = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">        LocInfo.LowerBoundBlock = VersionStack[0]->getBlock();</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">        LocInfo.LowerBoundBlock = VersionStack[0]->getBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">        LocInfo.LastKillValid = false;</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">        LocInfo.LastKillValid = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">    } else if (LocInfo.StackEpoch != StackEpoch) {</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">    } else if (LocInfo.StackEpoch != StackEpoch) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">      // If all that has changed is the StackEpoch, we only have to check the</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">      // If all that has changed is the StackEpoch, we only have to check the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">      // new things on the stack, because we've checked everything before.  In</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">      // new things on the stack, because we've checked everything before.  In</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">      // this case, the lower bound of things to check remains the same.</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">      // this case, the lower bound of things to check remains the same.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">      LocInfo.PopEpoch = PopEpoch;</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">      LocInfo.PopEpoch = PopEpoch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">      LocInfo.StackEpoch = StackEpoch;</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">      LocInfo.StackEpoch = StackEpoch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">    if (!LocInfo.LastKillValid) {</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">    if (!LocInfo.LastKillValid) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">      LocInfo.LastKill = VersionStack.size() - 1;</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">      LocInfo.LastKill = VersionStack.size() - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">      LocInfo.LastKillValid = true;</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">      LocInfo.LastKillValid = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline"></td>
    <td class="lineNumber">1404</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">    // At this point, we should have corrected last kill and LowerBound to be</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">    // At this point, we should have corrected last kill and LowerBound to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">    // in bounds.</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">    // in bounds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">    assert(LocInfo.LowerBound < VersionStack.size() &&</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">    assert(LocInfo.LowerBound < VersionStack.size() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">           "Lower bound out of range");</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">           "Lower bound out of range");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">    assert(LocInfo.LastKill < VersionStack.size() &&</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">    assert(LocInfo.LastKill < VersionStack.size() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">           "Last kill info out of range");</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">           "Last kill info out of range");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">    // In any case, the new upper bound is the top of the stack.</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">    // In any case, the new upper bound is the top of the stack.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">    unsigned long UpperBound = VersionStack.size() - 1;</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">    unsigned long UpperBound = VersionStack.size() - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline"></td>
    <td class="lineNumber">1413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">    if (UpperBound - LocInfo.LowerBound > MaxCheckLimit) {</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">    if (UpperBound - LocInfo.LowerBound > MaxCheckLimit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "MemorySSA skipping optimization of " << *MU << " ("</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "MemorySSA skipping optimization of " << *MU << " ("</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">                        << *(MU->getMemoryInst()) << ")"</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">                        << *(MU->getMemoryInst()) << ")"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">                        << " because there are "</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">                        << " because there are "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">                        << UpperBound - LocInfo.LowerBound</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">                        << UpperBound - LocInfo.LowerBound</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">                        << " stores to disambiguate\n");</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">                        << " stores to disambiguate\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">      // Because we did not walk, LastKill is no longer valid, as this may</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">      // Because we did not walk, LastKill is no longer valid, as this may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">      // have been a kill.</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">      // have been a kill.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">      LocInfo.LastKillValid = false;</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">      LocInfo.LastKillValid = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">    bool FoundClobberResult = false;</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">    bool FoundClobberResult = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">    while (UpperBound > LocInfo.LowerBound) {</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">    while (UpperBound > LocInfo.LowerBound) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">      if (isa<MemoryPhi>(VersionStack[UpperBound])) {</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">      if (isa<MemoryPhi>(VersionStack[UpperBound])) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">        // For phis, use the walker, see where we ended up, go there.</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">        // For phis, use the walker, see where we ended up, go there.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">        // The invariant.group handling in MemorySSA is ad-hoc and doesn't</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">        // The invariant.group handling in MemorySSA is ad-hoc and doesn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">        // support updates, so don't use it to optimize uses.</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">        // support updates, so don't use it to optimize uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">        MemoryAccess *Result =</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">        MemoryAccess *Result =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">            Walker->getClobberingMemoryAccessWithoutInvariantGroup(</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">            Walker->getClobberingMemoryAccessWithoutInvariantGroup(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">                MU, *AA, UpwardWalkLimit);</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">                MU, *AA, UpwardWalkLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">        // We are guaranteed to find it or something is wrong.</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">        // We are guaranteed to find it or something is wrong.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">        while (VersionStack[UpperBound] != Result) {</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">        while (VersionStack[UpperBound] != Result) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">          assert(UpperBound != 0);</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">          assert(UpperBound != 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">          --UpperBound;</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">          --UpperBound;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">        FoundClobberResult = true;</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">        FoundClobberResult = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline"></td>
    <td class="lineNumber">1443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">      MemoryDef *MD = cast<MemoryDef>(VersionStack[UpperBound]);</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">      MemoryDef *MD = cast<MemoryDef>(VersionStack[UpperBound]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">      if (instructionClobbersQuery(MD, MU, UseMLOC, *AA)) {</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">      if (instructionClobbersQuery(MD, MU, UseMLOC, *AA)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">        FoundClobberResult = true;</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">        FoundClobberResult = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">      --UpperBound;</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">      --UpperBound;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline"></td>
    <td class="lineNumber">1451</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">    // At the end of this loop, UpperBound is either a clobber, or lower bound</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">    // At the end of this loop, UpperBound is either a clobber, or lower bound</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">    // PHI walking may cause it to be < LowerBound, and in fact, < LastKill.</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">    // PHI walking may cause it to be < LowerBound, and in fact, < LastKill.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">    if (FoundClobberResult || UpperBound < LocInfo.LastKill) {</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">    if (FoundClobberResult || UpperBound < LocInfo.LastKill) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">      MU->setDefiningAccess(VersionStack[UpperBound], true);</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">      MU->setDefiningAccess(VersionStack[UpperBound], true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">      LocInfo.LastKill = UpperBound;</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">      LocInfo.LastKill = UpperBound;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">      // Otherwise, we checked all the new ones, and now we know we can get to</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">      // Otherwise, we checked all the new ones, and now we know we can get to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">      // LastKill.</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">      // LastKill.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">      MU->setDefiningAccess(VersionStack[LocInfo.LastKill], true);</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">      MU->setDefiningAccess(VersionStack[LocInfo.LastKill], true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">    LocInfo.LowerBound = VersionStack.size() - 1;</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">    LocInfo.LowerBound = VersionStack.size() - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">    LocInfo.LowerBoundBlock = BB;</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">    LocInfo.LowerBoundBlock = BB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">/// Optimize uses to point to their actual clobbering definitions.</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">/// Optimize uses to point to their actual clobbering definitions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">void MemorySSA::OptimizeUses::optimizeUses() {</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">void MemorySSA::OptimizeUses::optimizeUses() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">  SmallVector<MemoryAccess *, 16> VersionStack;</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">  SmallVector<MemoryAccess *, 16> VersionStack;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">  DenseMap<MemoryLocOrCall, MemlocStackInfo> LocStackInfo;</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">  DenseMap<MemoryLocOrCall, MemlocStackInfo> LocStackInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">  VersionStack.push_back(MSSA->getLiveOnEntryDef());</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">  VersionStack.push_back(MSSA->getLiveOnEntryDef());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline"></td>
    <td class="lineNumber">1472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">  unsigned long StackEpoch = 1;</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">  unsigned long StackEpoch = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">  unsigned long PopEpoch = 1;</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">  unsigned long PopEpoch = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">  // We perform a non-recursive top-down dominator tree walk.</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">  // We perform a non-recursive top-down dominator tree walk.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">  for (const auto *DomNode : depth_first(DT->getRootNode()))</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">  for (const auto *DomNode : depth_first(DT->getRootNode()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">    optimizeUsesInBlock(DomNode->getBlock(), StackEpoch, PopEpoch, VersionStack,</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">    optimizeUsesInBlock(DomNode->getBlock(), StackEpoch, PopEpoch, VersionStack,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">                        LocStackInfo);</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">                        LocStackInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline"></td>
    <td class="lineNumber">1480</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">void MemorySSA::placePHINodes(</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">void MemorySSA::placePHINodes(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">    const SmallPtrSetImpl<BasicBlock *> &DefiningBlocks) {</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">    const SmallPtrSetImpl<BasicBlock *> &DefiningBlocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">  // Determine where our MemoryPhi's should go</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">  // Determine where our MemoryPhi's should go</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">  ForwardIDFCalculator IDFs(*DT);</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">  ForwardIDFCalculator IDFs(*DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">  IDFs.setDefiningBlocks(DefiningBlocks);</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">  IDFs.setDefiningBlocks(DefiningBlocks);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">  SmallVector<BasicBlock *, 32> IDFBlocks;</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">  SmallVector<BasicBlock *, 32> IDFBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">  IDFs.calculate(IDFBlocks);</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">  IDFs.calculate(IDFBlocks);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">  // Now place MemoryPhi nodes.</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">  // Now place MemoryPhi nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">  for (auto &BB : IDFBlocks)</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">  for (auto &BB : IDFBlocks)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">    createMemoryPhi(BB);</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">    createMemoryPhi(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline"></td>
    <td class="lineNumber">1493</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">void MemorySSA::buildMemorySSA(BatchAAResults &BAA) {</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">void MemorySSA::buildMemorySSA(BatchAAResults &BAA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">  // We create an access to represent "live on entry", for things like</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">  // We create an access to represent "live on entry", for things like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">  // arguments or users of globals, where the memory they use is defined before</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">  // arguments or users of globals, where the memory they use is defined before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  // the beginning of the function. We do not actually insert it into the IR.</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  // the beginning of the function. We do not actually insert it into the IR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">  // We do not define a live on exit for the immediate uses, and thus our</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">  // We do not define a live on exit for the immediate uses, and thus our</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">  // semantics do *not* imply that something with no immediate uses can simply</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">  // semantics do *not* imply that something with no immediate uses can simply</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">  // be removed.</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">  // be removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">  BasicBlock &StartingPoint = F.getEntryBlock();</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">  BasicBlock &StartingPoint = F.getEntryBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">  LiveOnEntryDef.reset(new MemoryDef(F.getContext(), nullptr, nullptr,</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">  LiveOnEntryDef.reset(new MemoryDef(F.getContext(), nullptr, nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">                                     &StartingPoint, NextID++));</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">                                     &StartingPoint, NextID++));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline"></td>
    <td class="lineNumber">1504</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">  // We maintain lists of memory accesses per-block, trading memory for time. We</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">  // We maintain lists of memory accesses per-block, trading memory for time. We</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">  // could just look up the memory access for every possible instruction in the</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">  // could just look up the memory access for every possible instruction in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">  // stream.</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">  // stream.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">  SmallPtrSet<BasicBlock *, 32> DefiningBlocks;</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">  SmallPtrSet<BasicBlock *, 32> DefiningBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">  // Go through each block, figure out where defs occur, and chain together all</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">  // Go through each block, figure out where defs occur, and chain together all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">  // the accesses.</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">  // the accesses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">  for (BasicBlock &B : F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">    bool InsertIntoDef = false;</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">    bool InsertIntoDef = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">    AccessList *Accesses = nullptr;</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">    AccessList *Accesses = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">    DefsList *Defs = nullptr;</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">    DefsList *Defs = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">    for (Instruction &I : B) {</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">    for (Instruction &I : B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">      MemoryUseOrDef *MUD = createNewAccess(&I, &BAA);</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">      MemoryUseOrDef *MUD = createNewAccess(&I, &BAA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">      if (!MUD)</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">      if (!MUD)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline"></td>
    <td class="lineNumber">1519</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">      if (!Accesses)</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">      if (!Accesses)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">        Accesses = getOrCreateAccessList(&B);</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">        Accesses = getOrCreateAccessList(&B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">      Accesses->push_back(MUD);</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">      Accesses->push_back(MUD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">      if (isa<MemoryDef>(MUD)) {</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">      if (isa<MemoryDef>(MUD)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">        InsertIntoDef = true;</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">        InsertIntoDef = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">        if (!Defs)</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">        if (!Defs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">          Defs = getOrCreateDefsList(&B);</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">          Defs = getOrCreateDefsList(&B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">        Defs->push_back(*MUD);</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">        Defs->push_back(*MUD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">    if (InsertIntoDef)</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">    if (InsertIntoDef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">      DefiningBlocks.insert(&B);</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">      DefiningBlocks.insert(&B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">  placePHINodes(DefiningBlocks);</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">  placePHINodes(DefiningBlocks);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline"></td>
    <td class="lineNumber">1534</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">  // Now do regular SSA renaming on the MemoryDef/MemoryUse. Visited will get</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">  // Now do regular SSA renaming on the MemoryDef/MemoryUse. Visited will get</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">  // filled in with all blocks.</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">  // filled in with all blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">  SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">  SmallPtrSet<BasicBlock *, 16> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">  renamePass(DT->getRootNode(), LiveOnEntryDef.get(), Visited);</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">  renamePass(DT->getRootNode(), LiveOnEntryDef.get(), Visited);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline"></td>
    <td class="lineNumber">1539</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">  // Mark the uses in unreachable blocks as live on entry, so that they go</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">  // Mark the uses in unreachable blocks as live on entry, so that they go</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">  // somewhere.</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">  // somewhere.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">  for (auto &BB : F)</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">  for (auto &BB : F)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">    if (!Visited.count(&BB))</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">    if (!Visited.count(&BB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">      markUnreachableAsLiveOnEntry(&BB);</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">      markUnreachableAsLiveOnEntry(&BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline"></td>
    <td class="lineNumber">1546</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">MemorySSAWalker *MemorySSA::getWalker() { return getWalkerImpl(); }</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">MemorySSAWalker *MemorySSA::getWalker() { return getWalkerImpl(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">MemorySSA::CachingWalker *MemorySSA::getWalkerImpl() {</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">MemorySSA::CachingWalker *MemorySSA::getWalkerImpl() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">  if (Walker)</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">  if (Walker)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">    return Walker.get();</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">    return Walker.get();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">  if (!WalkerBase)</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">  if (!WalkerBase)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">    WalkerBase = std::make_unique<ClobberWalkerBase>(this, DT);</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">    WalkerBase = std::make_unique<ClobberWalkerBase>(this, DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline"></td>
    <td class="lineNumber">1555</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">  Walker = std::make_unique<CachingWalker>(this, WalkerBase.get());</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">  Walker = std::make_unique<CachingWalker>(this, WalkerBase.get());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">  return Walker.get();</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">  return Walker.get();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline"></td>
    <td class="lineNumber">1559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">MemorySSAWalker *MemorySSA::getSkipSelfWalker() {</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">MemorySSAWalker *MemorySSA::getSkipSelfWalker() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">  if (SkipWalker)</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">  if (SkipWalker)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">    return SkipWalker.get();</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">    return SkipWalker.get();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline"></td>
    <td class="lineNumber">1563</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">  if (!WalkerBase)</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">  if (!WalkerBase)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">    WalkerBase = std::make_unique<ClobberWalkerBase>(this, DT);</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">    WalkerBase = std::make_unique<ClobberWalkerBase>(this, DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline"></td>
    <td class="lineNumber">1566</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">  SkipWalker = std::make_unique<SkipSelfWalker>(this, WalkerBase.get());</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">  SkipWalker = std::make_unique<SkipSelfWalker>(this, WalkerBase.get());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">  return SkipWalker.get();</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">  return SkipWalker.get();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline"> }</td>
    <td class="lineNumber">1569</td>
    <td class="codeline"> }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline"></td>
    <td class="lineNumber">1570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">// This is a helper function used by the creation routines. It places NewAccess</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">// This is a helper function used by the creation routines. It places NewAccess</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">// into the access and defs lists for a given basic block, at the given</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">// into the access and defs lists for a given basic block, at the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">// insertion point.</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">// insertion point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">void MemorySSA::insertIntoListsForBlock(MemoryAccess *NewAccess,</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">void MemorySSA::insertIntoListsForBlock(MemoryAccess *NewAccess,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">                                        const BasicBlock *BB,</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">                                        const BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">                                        InsertionPlace Point) {</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">                                        InsertionPlace Point) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">  auto *Accesses = getOrCreateAccessList(BB);</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">  auto *Accesses = getOrCreateAccessList(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">  if (Point == Beginning) {</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">  if (Point == Beginning) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">    // If it's a phi node, it goes first, otherwise, it goes after any phi</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">    // If it's a phi node, it goes first, otherwise, it goes after any phi</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">    // nodes.</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">    // nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">    if (isa<MemoryPhi>(NewAccess)) {</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">    if (isa<MemoryPhi>(NewAccess)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">      Accesses->push_front(NewAccess);</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">      Accesses->push_front(NewAccess);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">      auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">      auto *Defs = getOrCreateDefsList(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">      Defs->push_front(*NewAccess);</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">      Defs->push_front(*NewAccess);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">      auto AI = find_if_not(</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">      auto AI = find_if_not(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">          *Accesses, [](const MemoryAccess &MA) { return isa<MemoryPhi>(MA); });</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">          *Accesses, [](const MemoryAccess &MA) { return isa<MemoryPhi>(MA); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">      Accesses->insert(AI, NewAccess);</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">      Accesses->insert(AI, NewAccess);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">      if (!isa<MemoryUse>(NewAccess)) {</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">      if (!isa<MemoryUse>(NewAccess)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">        auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">        auto *Defs = getOrCreateDefsList(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">        auto DI = find_if_not(</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">        auto DI = find_if_not(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">            *Defs, [](const MemoryAccess &MA) { return isa<MemoryPhi>(MA); });</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">            *Defs, [](const MemoryAccess &MA) { return isa<MemoryPhi>(MA); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">        Defs->insert(DI, *NewAccess);</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">        Defs->insert(DI, *NewAccess);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">    Accesses->push_back(NewAccess);</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">    Accesses->push_back(NewAccess);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">    if (!isa<MemoryUse>(NewAccess)) {</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">    if (!isa<MemoryUse>(NewAccess)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">      auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">      auto *Defs = getOrCreateDefsList(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">      Defs->push_back(*NewAccess);</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">      Defs->push_back(*NewAccess);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">  BlockNumberingValid.erase(BB);</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">  BlockNumberingValid.erase(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline"></td>
    <td class="lineNumber">1606</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">void MemorySSA::insertIntoListsBefore(MemoryAccess *What, const BasicBlock *BB,</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">void MemorySSA::insertIntoListsBefore(MemoryAccess *What, const BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">                                      AccessList::iterator InsertPt) {</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">                                      AccessList::iterator InsertPt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">  auto *Accesses = getWritableBlockAccesses(BB);</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">  auto *Accesses = getWritableBlockAccesses(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">  bool WasEnd = InsertPt == Accesses->end();</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">  bool WasEnd = InsertPt == Accesses->end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">  Accesses->insert(AccessList::iterator(InsertPt), What);</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">  Accesses->insert(AccessList::iterator(InsertPt), What);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">  if (!isa<MemoryUse>(What)) {</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">  if (!isa<MemoryUse>(What)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">    auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">    auto *Defs = getOrCreateDefsList(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">    // If we got asked to insert at the end, we have an easy job, just shove it</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">    // If we got asked to insert at the end, we have an easy job, just shove it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">    // at the end. If we got asked to insert before an existing def, we also get</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">    // at the end. If we got asked to insert before an existing def, we also get</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">    // an iterator. If we got asked to insert before a use, we have to hunt for</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">    // an iterator. If we got asked to insert before a use, we have to hunt for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">    // the next def.</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">    // the next def.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">    if (WasEnd) {</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">    if (WasEnd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">      Defs->push_back(*What);</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">      Defs->push_back(*What);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">    } else if (isa<MemoryDef>(InsertPt)) {</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">    } else if (isa<MemoryDef>(InsertPt)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">      Defs->insert(InsertPt->getDefsIterator(), *What);</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">      Defs->insert(InsertPt->getDefsIterator(), *What);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">      while (InsertPt != Accesses->end() && !isa<MemoryDef>(InsertPt))</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">      while (InsertPt != Accesses->end() && !isa<MemoryDef>(InsertPt))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">        ++InsertPt;</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">        ++InsertPt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">      // Either we found a def, or we are inserting at the end</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">      // Either we found a def, or we are inserting at the end</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">      if (InsertPt == Accesses->end())</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">      if (InsertPt == Accesses->end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">        Defs->push_back(*What);</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">        Defs->push_back(*What);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">        Defs->insert(InsertPt->getDefsIterator(), *What);</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">        Defs->insert(InsertPt->getDefsIterator(), *What);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">  BlockNumberingValid.erase(BB);</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">  BlockNumberingValid.erase(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline"></td>
    <td class="lineNumber">1634</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">void MemorySSA::prepareForMoveTo(MemoryAccess *What, BasicBlock *BB) {</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">void MemorySSA::prepareForMoveTo(MemoryAccess *What, BasicBlock *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">  // Keep it in the lookup tables, remove from the lists</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">  // Keep it in the lookup tables, remove from the lists</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">  removeFromLists(What, false);</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">  removeFromLists(What, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline"></td>
    <td class="lineNumber">1638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">  // Note that moving should implicitly invalidate the optimized state of a</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">  // Note that moving should implicitly invalidate the optimized state of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">  // MemoryUse (and Phis can't be optimized). However, it doesn't do so for a</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">  // MemoryUse (and Phis can't be optimized). However, it doesn't do so for a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">  // MemoryDef.</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">  // MemoryDef.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">  if (auto *MD = dyn_cast<MemoryDef>(What))</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">  if (auto *MD = dyn_cast<MemoryDef>(What))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">    MD->resetOptimized();</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">    MD->resetOptimized();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">  What->setBlock(BB);</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">  What->setBlock(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline"></td>
    <td class="lineNumber">1646</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">// Move What before Where in the IR.  The end result is that What will belong to</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">// Move What before Where in the IR.  The end result is that What will belong to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">// the right lists and have the right Block set, but will not otherwise be</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">// the right lists and have the right Block set, but will not otherwise be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">// correct. It will not have the right defining access, and if it is a def,</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">// correct. It will not have the right defining access, and if it is a def,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">// things below it will not properly be updated.</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">// things below it will not properly be updated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">void MemorySSA::moveTo(MemoryUseOrDef *What, BasicBlock *BB,</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">void MemorySSA::moveTo(MemoryUseOrDef *What, BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">                       AccessList::iterator Where) {</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">                       AccessList::iterator Where) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">  prepareForMoveTo(What, BB);</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">  prepareForMoveTo(What, BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">  insertIntoListsBefore(What, BB, Where);</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">  insertIntoListsBefore(What, BB, Where);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline"></td>
    <td class="lineNumber">1656</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">void MemorySSA::moveTo(MemoryAccess *What, BasicBlock *BB,</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">void MemorySSA::moveTo(MemoryAccess *What, BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">                       InsertionPlace Point) {</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">                       InsertionPlace Point) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">  if (isa<MemoryPhi>(What)) {</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">  if (isa<MemoryPhi>(What)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">    assert(Point == Beginning &&</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">    assert(Point == Beginning &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">           "Can only move a Phi at the beginning of the block");</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">           "Can only move a Phi at the beginning of the block");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">    // Update lookup table entry</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">    // Update lookup table entry</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">    ValueToMemoryAccess.erase(What->getBlock());</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">    ValueToMemoryAccess.erase(What->getBlock());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">    bool Inserted = ValueToMemoryAccess.insert({BB, What}).second;</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">    bool Inserted = ValueToMemoryAccess.insert({BB, What}).second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">    (void)Inserted;</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">    (void)Inserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">    assert(Inserted && "Cannot move a Phi to a block that already has one");</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">    assert(Inserted && "Cannot move a Phi to a block that already has one");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline"></td>
    <td class="lineNumber">1668</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">  prepareForMoveTo(What, BB);</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">  prepareForMoveTo(What, BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">  insertIntoListsForBlock(What, BB, Point);</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">  insertIntoListsForBlock(What, BB, Point);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline"></td>
    <td class="lineNumber">1672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">MemoryPhi *MemorySSA::createMemoryPhi(BasicBlock *BB) {</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">MemoryPhi *MemorySSA::createMemoryPhi(BasicBlock *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">  assert(!getMemoryAccess(BB) && "MemoryPhi already exists for this BB");</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">  assert(!getMemoryAccess(BB) && "MemoryPhi already exists for this BB");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">  MemoryPhi *Phi = new MemoryPhi(BB->getContext(), BB, NextID++);</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">  MemoryPhi *Phi = new MemoryPhi(BB->getContext(), BB, NextID++);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">  // Phi's always are placed at the front of the block.</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">  // Phi's always are placed at the front of the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">  insertIntoListsForBlock(Phi, BB, Beginning);</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">  insertIntoListsForBlock(Phi, BB, Beginning);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">  ValueToMemoryAccess[BB] = Phi;</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">  ValueToMemoryAccess[BB] = Phi;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">  return Phi;</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">  return Phi;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline"></td>
    <td class="lineNumber">1681</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">MemoryUseOrDef *MemorySSA::createDefinedAccess(Instruction *I,</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">MemoryUseOrDef *MemorySSA::createDefinedAccess(Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">                                               MemoryAccess *Definition,</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">                                               MemoryAccess *Definition,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">                                               const MemoryUseOrDef *Template,</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">                                               const MemoryUseOrDef *Template,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">                                               bool CreationMustSucceed) {</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">                                               bool CreationMustSucceed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">  assert(!isa<PHINode>(I) && "Cannot create a defined access for a PHI");</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">  assert(!isa<PHINode>(I) && "Cannot create a defined access for a PHI");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">  MemoryUseOrDef *NewAccess = createNewAccess(I, AA, Template);</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">  MemoryUseOrDef *NewAccess = createNewAccess(I, AA, Template);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">  if (CreationMustSucceed)</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">  if (CreationMustSucceed)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">    assert(NewAccess != nullptr && "Tried to create a memory access for a "</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">    assert(NewAccess != nullptr && "Tried to create a memory access for a "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">                                   "non-memory touching instruction");</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">                                   "non-memory touching instruction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">  if (NewAccess) {</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">  if (NewAccess) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">    assert((!Definition || !isa<MemoryUse>(Definition)) &&</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">    assert((!Definition || !isa<MemoryUse>(Definition)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">           "A use cannot be a defining access");</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">           "A use cannot be a defining access");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">    NewAccess->setDefiningAccess(Definition);</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">    NewAccess->setDefiningAccess(Definition);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">  return NewAccess;</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">  return NewAccess;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline"></td>
    <td class="lineNumber">1698</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">// Return true if the instruction has ordering constraints.</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">// Return true if the instruction has ordering constraints.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">// Note specifically that this only considers stores and loads</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">// Note specifically that this only considers stores and loads</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">// because others are still considered ModRef by getModRefInfo.</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">// because others are still considered ModRef by getModRefInfo.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">static inline bool isOrdered(const Instruction *I) {</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">static inline bool isOrdered(const Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">  if (auto *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">  if (auto *SI = dyn_cast<StoreInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">    if (!SI->isUnordered())</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">    if (!SI->isUnordered())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">  } else if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">  } else if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">    if (!LI->isUnordered())</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">    if (!LI->isUnordered())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline"></td>
    <td class="lineNumber">1712</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">/// Helper function to create new memory accesses</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">/// Helper function to create new memory accesses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">template <typename AliasAnalysisType></td>
    <td class="lineNumber">1714</td>
    <td class="codeline">template <typename AliasAnalysisType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">MemoryUseOrDef *MemorySSA::createNewAccess(Instruction *I,</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">MemoryUseOrDef *MemorySSA::createNewAccess(Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">                                           AliasAnalysisType *AAP,</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">                                           AliasAnalysisType *AAP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">                                           const MemoryUseOrDef *Template) {</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">                                           const MemoryUseOrDef *Template) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">  // The assume intrinsic has a control dependency which we model by claiming</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">  // The assume intrinsic has a control dependency which we model by claiming</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">  // that it writes arbitrarily. Debuginfo intrinsics may be considered</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">  // that it writes arbitrarily. Debuginfo intrinsics may be considered</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">  // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">  // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">  // dependencies here.</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">  // dependencies here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">  // FIXME: Replace this special casing with a more accurate modelling of</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">  // FIXME: Replace this special casing with a more accurate modelling of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">  // assume's control dependency.</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">  // assume's control dependency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">  if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(I)) {</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">  if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">    switch (II->getIntrinsicID()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">    case Intrinsic::assume:</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">    case Intrinsic::assume:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">    case Intrinsic::experimental_noalias_scope_decl:</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">    case Intrinsic::experimental_noalias_scope_decl:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">    case Intrinsic::pseudoprobe:</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">    case Intrinsic::pseudoprobe:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline"></td>
    <td class="lineNumber">1734</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">  // Using a nonstandard AA pipelines might leave us with unexpected modref</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">  // Using a nonstandard AA pipelines might leave us with unexpected modref</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">  // results for I, so add a check to not model instructions that may not read</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">  // results for I, so add a check to not model instructions that may not read</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">  // from or write to memory. This is necessary for correctness.</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">  // from or write to memory. This is necessary for correctness.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">  if (!I->mayReadFromMemory() && !I->mayWriteToMemory())</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">  if (!I->mayReadFromMemory() && !I->mayWriteToMemory())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline"></td>
    <td class="lineNumber">1740</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">  bool Def, Use;</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">  bool Def, Use;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">  if (Template) {</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">  if (Template) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">    Def = isa<MemoryDef>(Template);</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">    Def = isa<MemoryDef>(Template);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">    Use = isa<MemoryUse>(Template);</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">    Use = isa<MemoryUse>(Template);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">#if !defined(NDEBUG)</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">#if !defined(NDEBUG)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">    ModRefInfo ModRef = AAP->getModRefInfo(I, std::nullopt);</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">    ModRefInfo ModRef = AAP->getModRefInfo(I, std::nullopt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">    bool DefCheck, UseCheck;</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">    bool DefCheck, UseCheck;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">    DefCheck = isModSet(ModRef) || isOrdered(I);</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">    DefCheck = isModSet(ModRef) || isOrdered(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">    UseCheck = isRefSet(ModRef);</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">    UseCheck = isRefSet(ModRef);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">    // Memory accesses should only be reduced and can not be increased since AA</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">    // Memory accesses should only be reduced and can not be increased since AA</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">    // just might return better results as a result of some transformations.</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">    // just might return better results as a result of some transformations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">    assert((Def == DefCheck || !DefCheck) &&</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">    assert((Def == DefCheck || !DefCheck) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">           "Memory accesses should only be reduced");</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">           "Memory accesses should only be reduced");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">    if (!Def && Use != UseCheck) {</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">    if (!Def && Use != UseCheck) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">      // New Access should not have more power than template access</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">      // New Access should not have more power than template access</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">      assert(!UseCheck && "Invalid template");</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">      assert(!UseCheck && "Invalid template");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">    // Find out what affect this instruction has on memory.</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">    // Find out what affect this instruction has on memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">    ModRefInfo ModRef = AAP->getModRefInfo(I, std::nullopt);</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">    ModRefInfo ModRef = AAP->getModRefInfo(I, std::nullopt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">    // The isOrdered check is used to ensure that volatiles end up as defs</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">    // The isOrdered check is used to ensure that volatiles end up as defs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">    // (atomics end up as ModRef right now anyway).  Until we separate the</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">    // (atomics end up as ModRef right now anyway).  Until we separate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">    // ordering chain from the memory chain, this enables people to see at least</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">    // ordering chain from the memory chain, this enables people to see at least</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">    // some relative ordering to volatiles.  Note that getClobberingMemoryAccess</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">    // some relative ordering to volatiles.  Note that getClobberingMemoryAccess</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">    // will still give an answer that bypasses other volatile loads.  TODO:</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">    // will still give an answer that bypasses other volatile loads.  TODO:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">    // Separate memory aliasing and ordering into two different chains so that</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">    // Separate memory aliasing and ordering into two different chains so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">    // we can precisely represent both "what memory will this read/write/is</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">    // we can precisely represent both "what memory will this read/write/is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">    // clobbered by" and "what instructions can I move this past".</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">    // clobbered by" and "what instructions can I move this past".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">    Def = isModSet(ModRef) || isOrdered(I);</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">    Def = isModSet(ModRef) || isOrdered(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">    Use = isRefSet(ModRef);</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">    Use = isRefSet(ModRef);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline"></td>
    <td class="lineNumber">1773</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">  // It's possible for an instruction to not modify memory at all. During</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">  // It's possible for an instruction to not modify memory at all. During</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">  // construction, we ignore them.</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">  // construction, we ignore them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">  if (!Def && !Use)</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">  if (!Def && !Use)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline"></td>
    <td class="lineNumber">1778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">  MemoryUseOrDef *MUD;</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">  MemoryUseOrDef *MUD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">  if (Def) {</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">  if (Def) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">    MUD = new MemoryDef(I->getContext(), nullptr, I, I->getParent(), NextID++);</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">    MUD = new MemoryDef(I->getContext(), nullptr, I, I->getParent(), NextID++);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">    MUD = new MemoryUse(I->getContext(), nullptr, I, I->getParent());</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">    MUD = new MemoryUse(I->getContext(), nullptr, I, I->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">    if (isUseTriviallyOptimizableToLiveOnEntry(*AAP, I)) {</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">    if (isUseTriviallyOptimizableToLiveOnEntry(*AAP, I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">      MemoryAccess *LiveOnEntry = getLiveOnEntryDef();</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">      MemoryAccess *LiveOnEntry = getLiveOnEntryDef();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">      MUD->setOptimized(LiveOnEntry);</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">      MUD->setOptimized(LiveOnEntry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">  ValueToMemoryAccess[I] = MUD;</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">  ValueToMemoryAccess[I] = MUD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">  return MUD;</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">  return MUD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline"></td>
    <td class="lineNumber">1792</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">/// Properly remove \p MA from all of MemorySSA's lookup tables.</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">/// Properly remove \p MA from all of MemorySSA's lookup tables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">void MemorySSA::removeFromLookups(MemoryAccess *MA) {</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">void MemorySSA::removeFromLookups(MemoryAccess *MA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">  assert(MA->use_empty() &&</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">  assert(MA->use_empty() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">         "Trying to remove memory access that still has uses");</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">         "Trying to remove memory access that still has uses");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">  BlockNumbering.erase(MA);</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">  BlockNumbering.erase(MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">  if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">  if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">    MUD->setDefiningAccess(nullptr);</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">    MUD->setDefiningAccess(nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">  // Invalidate our walker's cache if necessary</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">  // Invalidate our walker's cache if necessary</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">  if (!isa<MemoryUse>(MA))</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">  if (!isa<MemoryUse>(MA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">    getWalker()->invalidateInfo(MA);</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">    getWalker()->invalidateInfo(MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline"></td>
    <td class="lineNumber">1803</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">  Value *MemoryInst;</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">  Value *MemoryInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">  if (const auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">  if (const auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">    MemoryInst = MUD->getMemoryInst();</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">    MemoryInst = MUD->getMemoryInst();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">    MemoryInst = MA->getBlock();</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">    MemoryInst = MA->getBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline"></td>
    <td class="lineNumber">1809</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">  auto VMA = ValueToMemoryAccess.find(MemoryInst);</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">  auto VMA = ValueToMemoryAccess.find(MemoryInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">  if (VMA->second == MA)</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">  if (VMA->second == MA)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">    ValueToMemoryAccess.erase(VMA);</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">    ValueToMemoryAccess.erase(VMA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline"></td>
    <td class="lineNumber">1814</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">/// Properly remove \p MA from all of MemorySSA's lists.</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">/// Properly remove \p MA from all of MemorySSA's lists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">/// Because of the way the intrusive list and use lists work, it is important to</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">/// Because of the way the intrusive list and use lists work, it is important to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">/// do removal in the right order.</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">/// do removal in the right order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">/// ShouldDelete defaults to true, and will cause the memory access to also be</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">/// ShouldDelete defaults to true, and will cause the memory access to also be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">/// deleted, not just removed.</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">/// deleted, not just removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">void MemorySSA::removeFromLists(MemoryAccess *MA, bool ShouldDelete) {</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">void MemorySSA::removeFromLists(MemoryAccess *MA, bool ShouldDelete) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">  BasicBlock *BB = MA->getBlock();</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">  BasicBlock *BB = MA->getBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">  // The access list owns the reference, so we erase it from the non-owning list</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">  // The access list owns the reference, so we erase it from the non-owning list</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">  // first.</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">  // first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">  if (!isa<MemoryUse>(MA)) {</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">  if (!isa<MemoryUse>(MA)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">    auto DefsIt = PerBlockDefs.find(BB);</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">    auto DefsIt = PerBlockDefs.find(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">    std::unique_ptr<DefsList> &Defs = DefsIt->second;</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">    std::unique_ptr<DefsList> &Defs = DefsIt->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">    Defs->remove(*MA);</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">    Defs->remove(*MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">    if (Defs->empty())</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">    if (Defs->empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">      PerBlockDefs.erase(DefsIt);</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">      PerBlockDefs.erase(DefsIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline"></td>
    <td class="lineNumber">1832</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">  // The erase call here will delete it. If we don't want it deleted, we call</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">  // The erase call here will delete it. If we don't want it deleted, we call</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">  // remove instead.</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">  // remove instead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">  auto AccessIt = PerBlockAccesses.find(BB);</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">  auto AccessIt = PerBlockAccesses.find(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">  std::unique_ptr<AccessList> &Accesses = AccessIt->second;</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">  std::unique_ptr<AccessList> &Accesses = AccessIt->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">  if (ShouldDelete)</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">  if (ShouldDelete)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">    Accesses->erase(MA);</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">    Accesses->erase(MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">    Accesses->remove(MA);</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">    Accesses->remove(MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline"></td>
    <td class="lineNumber">1841</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">  if (Accesses->empty()) {</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">  if (Accesses->empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">    PerBlockAccesses.erase(AccessIt);</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">    PerBlockAccesses.erase(AccessIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">    BlockNumberingValid.erase(BB);</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">    BlockNumberingValid.erase(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline"></td>
    <td class="lineNumber">1847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">void MemorySSA::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">void MemorySSA::print(raw_ostream &OS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">  MemorySSAAnnotatedWriter Writer(this);</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">  MemorySSAAnnotatedWriter Writer(this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">  F.print(OS, &Writer);</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">  F.print(OS, &Writer);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline"></td>
    <td class="lineNumber">1852</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">LLVM_DUMP_METHOD void MemorySSA::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">LLVM_DUMP_METHOD void MemorySSA::dump() const { print(dbgs()); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline"></td>
    <td class="lineNumber">1856</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">void MemorySSA::verifyMemorySSA(VerificationLevel VL) const {</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">void MemorySSA::verifyMemorySSA(VerificationLevel VL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">#if !defined(NDEBUG) && defined(EXPENSIVE_CHECKS)</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">#if !defined(NDEBUG) && defined(EXPENSIVE_CHECKS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">  VL = VerificationLevel::Full;</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">  VL = VerificationLevel::Full;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline"></td>
    <td class="lineNumber">1861</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">  verifyOrderingDominationAndDefUses(F, VL);</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">  verifyOrderingDominationAndDefUses(F, VL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">  verifyDominationNumbers(F);</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">  verifyDominationNumbers(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">  if (VL == VerificationLevel::Full)</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">  if (VL == VerificationLevel::Full)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">    verifyPrevDefInPhis(F);</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">    verifyPrevDefInPhis(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">  // Previously, the verification used to also verify that the clobberingAccess</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">  // Previously, the verification used to also verify that the clobberingAccess</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">  // cached by MemorySSA is the same as the clobberingAccess found at a later</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">  // cached by MemorySSA is the same as the clobberingAccess found at a later</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">  // query to AA. This does not hold true in general due to the current fragility</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">  // query to AA. This does not hold true in general due to the current fragility</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">  // of BasicAA which has arbitrary caps on the things it analyzes before giving</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">  // of BasicAA which has arbitrary caps on the things it analyzes before giving</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">  // up. As a result, transformations that are correct, will lead to BasicAA</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">  // up. As a result, transformations that are correct, will lead to BasicAA</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">  // returning different Alias answers before and after that transformation.</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">  // returning different Alias answers before and after that transformation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">  // Invalidating MemorySSA is not an option, as the results in BasicAA can be so</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">  // Invalidating MemorySSA is not an option, as the results in BasicAA can be so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">  // random, in the worst case we'd need to rebuild MemorySSA from scratch after</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">  // random, in the worst case we'd need to rebuild MemorySSA from scratch after</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">  // every transformation, which defeats the purpose of using it. For such an</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">  // every transformation, which defeats the purpose of using it. For such an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">  // example, see test4 added in D51960.</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">  // example, see test4 added in D51960.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline"></td>
    <td class="lineNumber">1879</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">void MemorySSA::verifyPrevDefInPhis(Function &F) const {</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">void MemorySSA::verifyPrevDefInPhis(Function &F) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">  for (const BasicBlock &BB : F) {</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">  for (const BasicBlock &BB : F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">    if (MemoryPhi *Phi = getMemoryAccess(&BB)) {</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">    if (MemoryPhi *Phi = getMemoryAccess(&BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">      for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I) {</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">      for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">        auto *Pred = Phi->getIncomingBlock(I);</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">        auto *Pred = Phi->getIncomingBlock(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">        auto *IncAcc = Phi->getIncomingValue(I);</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">        auto *IncAcc = Phi->getIncomingValue(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">        // If Pred has no unreachable predecessors, get last def looking at</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">        // If Pred has no unreachable predecessors, get last def looking at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">        // IDoms. If, while walkings IDoms, any of these has an unreachable</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">        // IDoms. If, while walkings IDoms, any of these has an unreachable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">        // predecessor, then the incoming def can be any access.</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">        // predecessor, then the incoming def can be any access.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">        if (auto *DTNode = DT->getNode(Pred)) {</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">        if (auto *DTNode = DT->getNode(Pred)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">          while (DTNode) {</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">          while (DTNode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">            if (auto *DefList = getBlockDefs(DTNode->getBlock())) {</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">            if (auto *DefList = getBlockDefs(DTNode->getBlock())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">              auto *LastAcc = &*(--DefList->end());</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">              auto *LastAcc = &*(--DefList->end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">              assert(LastAcc == IncAcc &&</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">              assert(LastAcc == IncAcc &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">                     "Incorrect incoming access into phi.");</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">                     "Incorrect incoming access into phi.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">              (void)IncAcc;</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">              (void)IncAcc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">              (void)LastAcc;</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">              (void)LastAcc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">              break;</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">              break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">            }</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">            }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">            DTNode = DTNode->getIDom();</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">            DTNode = DTNode->getIDom();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">          // If Pred has unreachable predecessors, but has at least a Def, the</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">          // If Pred has unreachable predecessors, but has at least a Def, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">          // incoming access can be the last Def in Pred, or it could have been</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">          // incoming access can be the last Def in Pred, or it could have been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">          // optimized to LoE. After an update, though, the LoE may have been</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">          // optimized to LoE. After an update, though, the LoE may have been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">          // replaced by another access, so IncAcc may be any access.</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">          // replaced by another access, so IncAcc may be any access.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">          // If Pred has unreachable predecessors and no Defs, incoming access</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">          // If Pred has unreachable predecessors and no Defs, incoming access</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">          // should be LoE; However, after an update, it may be any access.</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">          // should be LoE; However, after an update, it may be any access.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline"></td>
    <td class="lineNumber">1913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">/// Verify that all of the blocks we believe to have valid domination numbers</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">/// Verify that all of the blocks we believe to have valid domination numbers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">/// actually have valid domination numbers.</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">/// actually have valid domination numbers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">void MemorySSA::verifyDominationNumbers(const Function &F) const {</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">void MemorySSA::verifyDominationNumbers(const Function &F) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">  if (BlockNumberingValid.empty())</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">  if (BlockNumberingValid.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline"></td>
    <td class="lineNumber">1919</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">  SmallPtrSet<const BasicBlock *, 16> ValidBlocks = BlockNumberingValid;</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">  SmallPtrSet<const BasicBlock *, 16> ValidBlocks = BlockNumberingValid;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">  for (const BasicBlock &BB : F) {</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">  for (const BasicBlock &BB : F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">    if (!ValidBlocks.count(&BB))</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">    if (!ValidBlocks.count(&BB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline"></td>
    <td class="lineNumber">1924</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">    ValidBlocks.erase(&BB);</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">    ValidBlocks.erase(&BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">    const AccessList *Accesses = getBlockAccesses(&BB);</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">    const AccessList *Accesses = getBlockAccesses(&BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">    // It's correct to say an empty block has valid numbering.</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">    // It's correct to say an empty block has valid numbering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">    if (!Accesses)</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">    if (!Accesses)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline"></td>
    <td class="lineNumber">1931</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">    // Block numbering starts at 1.</td>
    <td class="lineNumber">1932</td>
    <td class="codeline">    // Block numbering starts at 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">    unsigned long LastNumber = 0;</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">    unsigned long LastNumber = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">    for (const MemoryAccess &MA : *Accesses) {</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">    for (const MemoryAccess &MA : *Accesses) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">      auto ThisNumberIter = BlockNumbering.find(&MA);</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">      auto ThisNumberIter = BlockNumbering.find(&MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">      assert(ThisNumberIter != BlockNumbering.end() &&</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">      assert(ThisNumberIter != BlockNumbering.end() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">             "MemoryAccess has no domination number in a valid block!");</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">             "MemoryAccess has no domination number in a valid block!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline"></td>
    <td class="lineNumber">1938</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">      unsigned long ThisNumber = ThisNumberIter->second;</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">      unsigned long ThisNumber = ThisNumberIter->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">      assert(ThisNumber > LastNumber &&</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">      assert(ThisNumber > LastNumber &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">             "Domination numbers should be strictly increasing!");</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">             "Domination numbers should be strictly increasing!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">      (void)LastNumber;</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">      (void)LastNumber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">      LastNumber = ThisNumber;</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">      LastNumber = ThisNumber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline"></td>
    <td class="lineNumber">1946</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">  assert(ValidBlocks.empty() &&</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">  assert(ValidBlocks.empty() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">         "All valid BasicBlocks should exist in F -- dangling pointers?");</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">         "All valid BasicBlocks should exist in F -- dangling pointers?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline"></td>
    <td class="lineNumber">1950</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">/// Verify ordering: the order and existence of MemoryAccesses matches the</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">/// Verify ordering: the order and existence of MemoryAccesses matches the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">/// order and existence of memory affecting instructions.</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">/// order and existence of memory affecting instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">/// Verify domination: each definition dominates all of its uses.</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">/// Verify domination: each definition dominates all of its uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">/// Verify def-uses: the immediate use information - walk all the memory</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">/// Verify def-uses: the immediate use information - walk all the memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">/// accesses and verifying that, for each use, it appears in the appropriate</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">/// accesses and verifying that, for each use, it appears in the appropriate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">/// def's use list</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">/// def's use list</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">void MemorySSA::verifyOrderingDominationAndDefUses(Function &F,</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">void MemorySSA::verifyOrderingDominationAndDefUses(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">                                                   VerificationLevel VL) const {</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">                                                   VerificationLevel VL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">  // Walk all the blocks, comparing what the lookups think and what the access</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">  // Walk all the blocks, comparing what the lookups think and what the access</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">  // lists think, as well as the order in the blocks vs the order in the access</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">  // lists think, as well as the order in the blocks vs the order in the access</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">  // lists.</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">  // lists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  SmallVector<MemoryAccess *, 32> ActualAccesses;</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  SmallVector<MemoryAccess *, 32> ActualAccesses;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  SmallVector<MemoryAccess *, 32> ActualDefs;</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  SmallVector<MemoryAccess *, 32> ActualDefs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">  for (BasicBlock &B : F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">    const AccessList *AL = getBlockAccesses(&B);</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">    const AccessList *AL = getBlockAccesses(&B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">    const auto *DL = getBlockDefs(&B);</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">    const auto *DL = getBlockDefs(&B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">    MemoryPhi *Phi = getMemoryAccess(&B);</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">    MemoryPhi *Phi = getMemoryAccess(&B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">    if (Phi) {</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">    if (Phi) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">      // Verify ordering.</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">      // Verify ordering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">      ActualAccesses.push_back(Phi);</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">      ActualAccesses.push_back(Phi);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">      ActualDefs.push_back(Phi);</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">      ActualDefs.push_back(Phi);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">      // Verify domination</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">      // Verify domination</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">      for (const Use &U : Phi->uses()) {</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">      for (const Use &U : Phi->uses()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">        assert(dominates(Phi, U) && "Memory PHI does not dominate it's uses");</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">        assert(dominates(Phi, U) && "Memory PHI does not dominate it's uses");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">        (void)U;</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">        (void)U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">      // Verify def-uses for full verify.</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">      // Verify def-uses for full verify.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">      if (VL == VerificationLevel::Full) {</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">      if (VL == VerificationLevel::Full) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">        assert(Phi->getNumOperands() == static_cast<unsigned>(std::distance(</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">        assert(Phi->getNumOperands() == static_cast<unsigned>(std::distance(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">                                            pred_begin(&B), pred_end(&B))) &&</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">                                            pred_begin(&B), pred_end(&B))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">               "Incomplete MemoryPhi Node");</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">               "Incomplete MemoryPhi Node");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">        for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I) {</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">        for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">          verifyUseInDefs(Phi->getIncomingValue(I), Phi);</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">          verifyUseInDefs(Phi->getIncomingValue(I), Phi);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">          assert(is_contained(predecessors(&B), Phi->getIncomingBlock(I)) &&</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">          assert(is_contained(predecessors(&B), Phi->getIncomingBlock(I)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">                 "Incoming phi block not a block predecessor");</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">                 "Incoming phi block not a block predecessor");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline"></td>
    <td class="lineNumber">1989</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">    for (Instruction &I : B) {</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">    for (Instruction &I : B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">      MemoryUseOrDef *MA = getMemoryAccess(&I);</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">      MemoryUseOrDef *MA = getMemoryAccess(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">      assert((!MA || (AL && (isa<MemoryUse>(MA) || DL))) &&</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">      assert((!MA || (AL && (isa<MemoryUse>(MA) || DL))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">             "We have memory affecting instructions "</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">             "We have memory affecting instructions "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">             "in this block but they are not in the "</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">             "in this block but they are not in the "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">             "access list or defs list");</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">             "access list or defs list");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">      if (MA) {</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">      if (MA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">        // Verify ordering.</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">        // Verify ordering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">        ActualAccesses.push_back(MA);</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">        ActualAccesses.push_back(MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">        if (MemoryAccess *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">        if (MemoryAccess *MD = dyn_cast<MemoryDef>(MA)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">          // Verify ordering.</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">          // Verify ordering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">          ActualDefs.push_back(MA);</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">          ActualDefs.push_back(MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">          // Verify domination.</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">          // Verify domination.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">          for (const Use &U : MD->uses()) {</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">          for (const Use &U : MD->uses()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">            assert(dominates(MD, U) &&</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">            assert(dominates(MD, U) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">                   "Memory Def does not dominate it's uses");</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">                   "Memory Def does not dominate it's uses");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">            (void)U;</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">            (void)U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">        // Verify def-uses for full verify.</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">        // Verify def-uses for full verify.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">        if (VL == VerificationLevel::Full)</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">        if (VL == VerificationLevel::Full)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">          verifyUseInDefs(MA->getDefiningAccess(), MA);</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">          verifyUseInDefs(MA->getDefiningAccess(), MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">    // Either we hit the assert, really have no accesses, or we have both</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">    // Either we hit the assert, really have no accesses, or we have both</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">    // accesses and an access list. Same with defs.</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">    // accesses and an access list. Same with defs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">    if (!AL && !DL)</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">    if (!AL && !DL)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">    // Verify ordering.</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">    // Verify ordering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">    assert(AL->size() == ActualAccesses.size() &&</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">    assert(AL->size() == ActualAccesses.size() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">           "We don't have the same number of accesses in the block as on the "</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">           "We don't have the same number of accesses in the block as on the "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">           "access list");</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">           "access list");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">    assert((DL || ActualDefs.size() == 0) &&</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">    assert((DL || ActualDefs.size() == 0) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">           "Either we should have a defs list, or we should have no defs");</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">           "Either we should have a defs list, or we should have no defs");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">    assert((!DL || DL->size() == ActualDefs.size()) &&</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">    assert((!DL || DL->size() == ActualDefs.size()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">           "We don't have the same number of defs in the block as on the "</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">           "We don't have the same number of defs in the block as on the "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">           "def list");</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">           "def list");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">    auto ALI = AL->begin();</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">    auto ALI = AL->begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">    auto AAI = ActualAccesses.begin();</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">    auto AAI = ActualAccesses.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">    while (ALI != AL->end() && AAI != ActualAccesses.end()) {</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">    while (ALI != AL->end() && AAI != ActualAccesses.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">      assert(&*ALI == *AAI && "Not the same accesses in the same order");</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">      assert(&*ALI == *AAI && "Not the same accesses in the same order");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">      ++ALI;</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">      ++ALI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">      ++AAI;</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">      ++AAI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">    ActualAccesses.clear();</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">    ActualAccesses.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">    if (DL) {</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">    if (DL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">      auto DLI = DL->begin();</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">      auto DLI = DL->begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">      auto ADI = ActualDefs.begin();</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">      auto ADI = ActualDefs.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">      while (DLI != DL->end() && ADI != ActualDefs.end()) {</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">      while (DLI != DL->end() && ADI != ActualDefs.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">        assert(&*DLI == *ADI && "Not the same defs in the same order");</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">        assert(&*DLI == *ADI && "Not the same defs in the same order");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">        ++DLI;</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">        ++DLI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">        ++ADI;</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">        ++ADI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">    ActualDefs.clear();</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">    ActualDefs.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline"></td>
    <td class="lineNumber">2047</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">/// Verify the def-use lists in MemorySSA, by verifying that \p Use</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">/// Verify the def-use lists in MemorySSA, by verifying that \p Use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">/// appears in the use list of \p Def.</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">/// appears in the use list of \p Def.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">void MemorySSA::verifyUseInDefs(MemoryAccess *Def, MemoryAccess *Use) const {</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">void MemorySSA::verifyUseInDefs(MemoryAccess *Def, MemoryAccess *Use) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">  // The live on entry use may cause us to get a NULL def here</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">  // The live on entry use may cause us to get a NULL def here</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">  if (!Def)</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">  if (!Def)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">    assert(isLiveOnEntryDef(Use) &&</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">    assert(isLiveOnEntryDef(Use) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">           "Null def but use not point to live on entry def");</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">           "Null def but use not point to live on entry def");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">    assert(is_contained(Def->users(), Use) &&</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">    assert(is_contained(Def->users(), Use) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">           "Did not find use in def's use list");</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">           "Did not find use in def's use list");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">/// Perform a local numbering on blocks so that instruction ordering can be</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">/// Perform a local numbering on blocks so that instruction ordering can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">/// determined in constant time.</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">/// determined in constant time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">/// TODO: We currently just number in order.  If we numbered by N, we could</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">/// TODO: We currently just number in order.  If we numbered by N, we could</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">/// allow at least N-1 sequences of insertBefore or insertAfter (and at least</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">/// allow at least N-1 sequences of insertBefore or insertAfter (and at least</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">/// log2(N) sequences of mixed before and after) without needing to invalidate</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">/// log2(N) sequences of mixed before and after) without needing to invalidate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">/// the numbering.</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">/// the numbering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">void MemorySSA::renumberBlock(const BasicBlock *B) const {</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">void MemorySSA::renumberBlock(const BasicBlock *B) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">  // The pre-increment ensures the numbers really start at 1.</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">  // The pre-increment ensures the numbers really start at 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">  unsigned long CurrentNumber = 0;</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">  unsigned long CurrentNumber = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">  const AccessList *AL = getBlockAccesses(B);</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">  const AccessList *AL = getBlockAccesses(B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">  assert(AL != nullptr && "Asking to renumber an empty block");</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">  assert(AL != nullptr && "Asking to renumber an empty block");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">  for (const auto &I : *AL)</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">  for (const auto &I : *AL)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">    BlockNumbering[&I] = ++CurrentNumber;</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">    BlockNumbering[&I] = ++CurrentNumber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">  BlockNumberingValid.insert(B);</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">  BlockNumberingValid.insert(B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">/// Determine, for two memory accesses in the same block,</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">/// Determine, for two memory accesses in the same block,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">/// whether \p Dominator dominates \p Dominatee.</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">/// whether \p Dominator dominates \p Dominatee.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">/// \returns True if \p Dominator dominates \p Dominatee.</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">/// \returns True if \p Dominator dominates \p Dominatee.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">bool MemorySSA::locallyDominates(const MemoryAccess *Dominator,</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">bool MemorySSA::locallyDominates(const MemoryAccess *Dominator,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">                                 const MemoryAccess *Dominatee) const {</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">                                 const MemoryAccess *Dominatee) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">  const BasicBlock *DominatorBlock = Dominator->getBlock();</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">  const BasicBlock *DominatorBlock = Dominator->getBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline"></td>
    <td class="lineNumber">2082</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">  assert((DominatorBlock == Dominatee->getBlock()) &&</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">  assert((DominatorBlock == Dominatee->getBlock()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">         "Asking for local domination when accesses are in different blocks!");</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">         "Asking for local domination when accesses are in different blocks!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">  // A node dominates itself.</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">  // A node dominates itself.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">  if (Dominatee == Dominator)</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">  if (Dominatee == Dominator)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline"></td>
    <td class="lineNumber">2088</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">  // When Dominatee is defined on function entry, it is not dominated by another</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">  // When Dominatee is defined on function entry, it is not dominated by another</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">  // memory access.</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">  // memory access.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">  if (isLiveOnEntryDef(Dominatee))</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">  if (isLiveOnEntryDef(Dominatee))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline"></td>
    <td class="lineNumber">2093</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">  // When Dominator is defined on function entry, it dominates the other memory</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">  // When Dominator is defined on function entry, it dominates the other memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">  // access.</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">  // access.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">  if (isLiveOnEntryDef(Dominator))</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">  if (isLiveOnEntryDef(Dominator))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">  if (!BlockNumberingValid.count(DominatorBlock))</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">  if (!BlockNumberingValid.count(DominatorBlock))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">    renumberBlock(DominatorBlock);</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">    renumberBlock(DominatorBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline"></td>
    <td class="lineNumber">2101</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">  unsigned long DominatorNum = BlockNumbering.lookup(Dominator);</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">  unsigned long DominatorNum = BlockNumbering.lookup(Dominator);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">  // All numbers start with 1</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">  // All numbers start with 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">  assert(DominatorNum != 0 && "Block was not numbered properly");</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">  assert(DominatorNum != 0 && "Block was not numbered properly");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">  unsigned long DominateeNum = BlockNumbering.lookup(Dominatee);</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">  unsigned long DominateeNum = BlockNumbering.lookup(Dominatee);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">  assert(DominateeNum != 0 && "Block was not numbered properly");</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">  assert(DominateeNum != 0 && "Block was not numbered properly");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">  return DominatorNum < DominateeNum;</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">  return DominatorNum < DominateeNum;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline"></td>
    <td class="lineNumber">2109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">bool MemorySSA::dominates(const MemoryAccess *Dominator,</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">bool MemorySSA::dominates(const MemoryAccess *Dominator,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">                          const MemoryAccess *Dominatee) const {</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">                          const MemoryAccess *Dominatee) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">  if (Dominator == Dominatee)</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">  if (Dominator == Dominatee)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline"></td>
    <td class="lineNumber">2114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">  if (isLiveOnEntryDef(Dominatee))</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">  if (isLiveOnEntryDef(Dominatee))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline"></td>
    <td class="lineNumber">2117</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">  if (Dominator->getBlock() != Dominatee->getBlock())</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">  if (Dominator->getBlock() != Dominatee->getBlock())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">    return DT->dominates(Dominator->getBlock(), Dominatee->getBlock());</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">    return DT->dominates(Dominator->getBlock(), Dominatee->getBlock());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">  return locallyDominates(Dominator, Dominatee);</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">  return locallyDominates(Dominator, Dominatee);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline"></td>
    <td class="lineNumber">2122</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">bool MemorySSA::dominates(const MemoryAccess *Dominator,</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">bool MemorySSA::dominates(const MemoryAccess *Dominator,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">                          const Use &Dominatee) const {</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">                          const Use &Dominatee) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">  if (MemoryPhi *MP = dyn_cast<MemoryPhi>(Dominatee.getUser())) {</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">  if (MemoryPhi *MP = dyn_cast<MemoryPhi>(Dominatee.getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">    BasicBlock *UseBB = MP->getIncomingBlock(Dominatee);</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">    BasicBlock *UseBB = MP->getIncomingBlock(Dominatee);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">    // The def must dominate the incoming block of the phi.</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">    // The def must dominate the incoming block of the phi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">    if (UseBB != Dominator->getBlock())</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">    if (UseBB != Dominator->getBlock())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">      return DT->dominates(Dominator->getBlock(), UseBB);</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">      return DT->dominates(Dominator->getBlock(), UseBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">    // If the UseBB and the DefBB are the same, compare locally.</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">    // If the UseBB and the DefBB are the same, compare locally.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">    return locallyDominates(Dominator, cast<MemoryAccess>(Dominatee));</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">    return locallyDominates(Dominator, cast<MemoryAccess>(Dominatee));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">  // If it's not a PHI node use, the normal dominates can already handle it.</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">  // If it's not a PHI node use, the normal dominates can already handle it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">  return dominates(Dominator, cast<MemoryAccess>(Dominatee.getUser()));</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">  return dominates(Dominator, cast<MemoryAccess>(Dominatee.getUser()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline"></td>
    <td class="lineNumber">2136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">void MemorySSA::ensureOptimizedUses() {</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">void MemorySSA::ensureOptimizedUses() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">  if (IsOptimized)</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">  if (IsOptimized)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline"></td>
    <td class="lineNumber">2140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">  BatchAAResults BatchAA(*AA);</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">  BatchAAResults BatchAA(*AA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">  ClobberWalkerBase WalkerBase(this, DT);</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">  ClobberWalkerBase WalkerBase(this, DT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">  CachingWalker WalkerLocal(this, &WalkerBase);</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">  CachingWalker WalkerLocal(this, &WalkerBase);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">  OptimizeUses(this, &WalkerLocal, &BatchAA, DT).optimizeUses();</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">  OptimizeUses(this, &WalkerLocal, &BatchAA, DT).optimizeUses();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">  IsOptimized = true;</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">  IsOptimized = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline"></td>
    <td class="lineNumber">2147</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">void MemoryAccess::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">void MemoryAccess::print(raw_ostream &OS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">  switch (getValueID()) {</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">  switch (getValueID()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">  case MemoryPhiVal: return static_cast<const MemoryPhi *>(this)->print(OS);</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">  case MemoryPhiVal: return static_cast<const MemoryPhi *>(this)->print(OS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">  case MemoryDefVal: return static_cast<const MemoryDef *>(this)->print(OS);</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">  case MemoryDefVal: return static_cast<const MemoryDef *>(this)->print(OS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">  case MemoryUseVal: return static_cast<const MemoryUse *>(this)->print(OS);</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">  case MemoryUseVal: return static_cast<const MemoryUse *>(this)->print(OS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">  llvm_unreachable("invalid value id");</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">  llvm_unreachable("invalid value id");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline"></td>
    <td class="lineNumber">2156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">void MemoryDef::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">void MemoryDef::print(raw_ostream &OS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">  MemoryAccess *UO = getDefiningAccess();</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">  MemoryAccess *UO = getDefiningAccess();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline"></td>
    <td class="lineNumber">2159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">  auto printID = [&OS](MemoryAccess *A) {</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">  auto printID = [&OS](MemoryAccess *A) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">    if (A && A->getID())</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">    if (A && A->getID())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">      OS << A->getID();</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">      OS << A->getID();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">      OS << LiveOnEntryStr;</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">      OS << LiveOnEntryStr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline"></td>
    <td class="lineNumber">2166</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">  OS << getID() << " = MemoryDef(";</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">  OS << getID() << " = MemoryDef(";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">  printID(UO);</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">  printID(UO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">  OS << ")";</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">  OS << ")";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline"></td>
    <td class="lineNumber">2170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">  if (isOptimized()) {</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">  if (isOptimized()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">    OS << "->";</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">    OS << "->";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">    printID(getOptimized());</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">    printID(getOptimized());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline"></td>
    <td class="lineNumber">2176</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">void MemoryPhi::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">void MemoryPhi::print(raw_ostream &OS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">  ListSeparator LS(",");</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">  ListSeparator LS(",");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">  OS << getID() << " = MemoryPhi(";</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">  OS << getID() << " = MemoryPhi(";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">  for (const auto &Op : operands()) {</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">  for (const auto &Op : operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">    BasicBlock *BB = getIncomingBlock(Op);</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">    BasicBlock *BB = getIncomingBlock(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">    MemoryAccess *MA = cast<MemoryAccess>(Op);</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">    MemoryAccess *MA = cast<MemoryAccess>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline"></td>
    <td class="lineNumber">2183</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">    OS << LS << '{';</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">    OS << LS << '{';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">    if (BB->hasName())</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">    if (BB->hasName())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">      OS << BB->getName();</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">      OS << BB->getName();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">      BB->printAsOperand(OS, false);</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">      BB->printAsOperand(OS, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">    OS << ',';</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">    OS << ',';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">    if (unsigned ID = MA->getID())</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">    if (unsigned ID = MA->getID())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">      OS << ID;</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">      OS << ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">      OS << LiveOnEntryStr;</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">      OS << LiveOnEntryStr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">    OS << '}';</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">    OS << '}';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">  OS << ')';</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">  OS << ')';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline"></td>
    <td class="lineNumber">2198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">void MemoryUse::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">void MemoryUse::print(raw_ostream &OS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">  MemoryAccess *UO = getDefiningAccess();</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">  MemoryAccess *UO = getDefiningAccess();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">  OS << "MemoryUse(";</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">  OS << "MemoryUse(";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">  if (UO && UO->getID())</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">  if (UO && UO->getID())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">    OS << UO->getID();</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">    OS << UO->getID();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">    OS << LiveOnEntryStr;</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">    OS << LiveOnEntryStr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">  OS << ')';</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">  OS << ')';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline"></td>
    <td class="lineNumber">2208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">void MemoryAccess::dump() const {</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">void MemoryAccess::dump() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">// Cannot completely remove virtual function even in release mode.</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">// Cannot completely remove virtual function even in release mode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">  print(dbgs());</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">  print(dbgs());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">  dbgs() << "\n";</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">  dbgs() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline"></td>
    <td class="lineNumber">2216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">class DOTFuncMSSAInfo {</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">class DOTFuncMSSAInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">  const Function &F;</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">  const Function &F;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">  MemorySSAAnnotatedWriter MSSAWriter;</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">  MemorySSAAnnotatedWriter MSSAWriter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline"></td>
    <td class="lineNumber">2221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">  DOTFuncMSSAInfo(const Function &F, MemorySSA &MSSA)</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">  DOTFuncMSSAInfo(const Function &F, MemorySSA &MSSA)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">      : F(F), MSSAWriter(&MSSA) {}</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">      : F(F), MSSAWriter(&MSSA) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline"></td>
    <td class="lineNumber">2225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">  const Function *getFunction() { return &F; }</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">  const Function *getFunction() { return &F; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">  MemorySSAAnnotatedWriter &getWriter() { return MSSAWriter; }</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">  MemorySSAAnnotatedWriter &getWriter() { return MSSAWriter; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline"></td>
    <td class="lineNumber">2229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline"></td>
    <td class="lineNumber">2231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">template <></td>
    <td class="lineNumber">2232</td>
    <td class="codeline">template <></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">struct GraphTraits<DOTFuncMSSAInfo *> : public GraphTraits<const BasicBlock *> {</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">struct GraphTraits<DOTFuncMSSAInfo *> : public GraphTraits<const BasicBlock *> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">  static NodeRef getEntryNode(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">  static NodeRef getEntryNode(DOTFuncMSSAInfo *CFGInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">    return &(CFGInfo->getFunction()->getEntryBlock());</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">    return &(CFGInfo->getFunction()->getEntryBlock());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline"></td>
    <td class="lineNumber">2237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline">  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph</td>
    <td class="lineNumber">2238</td>
    <td class="codeline">  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">  using nodes_iterator = pointer_iterator<Function::const_iterator>;</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">  using nodes_iterator = pointer_iterator<Function::const_iterator>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline"></td>
    <td class="lineNumber">2240</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">  static nodes_iterator nodes_begin(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">  static nodes_iterator nodes_begin(DOTFuncMSSAInfo *CFGInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">    return nodes_iterator(CFGInfo->getFunction()->begin());</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">    return nodes_iterator(CFGInfo->getFunction()->begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2243</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline"></td>
    <td class="lineNumber">2244</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">  static nodes_iterator nodes_end(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">  static nodes_iterator nodes_end(DOTFuncMSSAInfo *CFGInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">    return nodes_iterator(CFGInfo->getFunction()->end());</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">    return nodes_iterator(CFGInfo->getFunction()->end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline"></td>
    <td class="lineNumber">2248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">  static size_t size(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">  static size_t size(DOTFuncMSSAInfo *CFGInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">    return CFGInfo->getFunction()->size();</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">    return CFGInfo->getFunction()->size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline"></td>
    <td class="lineNumber">2253</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">template <></td>
    <td class="lineNumber">2254</td>
    <td class="codeline">template <></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">struct DOTGraphTraits<DOTFuncMSSAInfo *> : public DefaultDOTGraphTraits {</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">struct DOTGraphTraits<DOTFuncMSSAInfo *> : public DefaultDOTGraphTraits {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline"></td>
    <td class="lineNumber">2256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">  DOTGraphTraits(bool IsSimple = false) : DefaultDOTGraphTraits(IsSimple) {}</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">  DOTGraphTraits(bool IsSimple = false) : DefaultDOTGraphTraits(IsSimple) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline"></td>
    <td class="lineNumber">2258</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">  static std::string getGraphName(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">  static std::string getGraphName(DOTFuncMSSAInfo *CFGInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">    return "MSSA CFG for '" + CFGInfo->getFunction()->getName().str() +</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">    return "MSSA CFG for '" + CFGInfo->getFunction()->getName().str() +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">           "' function";</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">           "' function";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline"></td>
    <td class="lineNumber">2263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">  std::string getNodeLabel(const BasicBlock *Node, DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">  std::string getNodeLabel(const BasicBlock *Node, DOTFuncMSSAInfo *CFGInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">    return DOTGraphTraits<DOTFuncInfo *>::getCompleteNodeLabel(</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">    return DOTGraphTraits<DOTFuncInfo *>::getCompleteNodeLabel(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">        Node, nullptr,</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">        Node, nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">        [CFGInfo](raw_string_ostream &OS, const BasicBlock &BB) -> void {</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">        [CFGInfo](raw_string_ostream &OS, const BasicBlock &BB) -> void {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">          BB.print(OS, &CFGInfo->getWriter(), true, true);</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">          BB.print(OS, &CFGInfo->getWriter(), true, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">        },</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">        },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">        [](std::string &S, unsigned &I, unsigned Idx) -> void {</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">        [](std::string &S, unsigned &I, unsigned Idx) -> void {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">          std::string Str = S.substr(I, Idx - I);</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">          std::string Str = S.substr(I, Idx - I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">          StringRef SR = Str;</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">          StringRef SR = Str;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">          if (SR.count(" = MemoryDef(") || SR.count(" = MemoryPhi(") ||</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">          if (SR.count(" = MemoryDef(") || SR.count(" = MemoryPhi(") ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">              SR.count("MemoryUse("))</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">              SR.count("MemoryUse("))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">            return;</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">            return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">          DOTGraphTraits<DOTFuncInfo *>::eraseComment(S, I, Idx);</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">          DOTGraphTraits<DOTFuncInfo *>::eraseComment(S, I, Idx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline"></td>
    <td class="lineNumber">2279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">  static std::string getEdgeSourceLabel(const BasicBlock *Node,</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">  static std::string getEdgeSourceLabel(const BasicBlock *Node,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">                                        const_succ_iterator I) {</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">                                        const_succ_iterator I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">    return DOTGraphTraits<DOTFuncInfo *>::getEdgeSourceLabel(Node, I);</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">    return DOTGraphTraits<DOTFuncInfo *>::getEdgeSourceLabel(Node, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline"></td>
    <td class="lineNumber">2284</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">  /// Display the raw branch weights from PGO.</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">  /// Display the raw branch weights from PGO.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">  std::string getEdgeAttributes(const BasicBlock *Node, const_succ_iterator I,</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">  std::string getEdgeAttributes(const BasicBlock *Node, const_succ_iterator I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">                                DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">                                DOTFuncMSSAInfo *CFGInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">    return "";</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">    return "";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline"></td>
    <td class="lineNumber">2290</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">  std::string getNodeAttributes(const BasicBlock *Node,</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">  std::string getNodeAttributes(const BasicBlock *Node,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">                                DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">                                DOTFuncMSSAInfo *CFGInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">    return getNodeLabel(Node, CFGInfo).find(';') != std::string::npos</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">    return getNodeLabel(Node, CFGInfo).find(';') != std::string::npos</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">               ? "style=filled, fillcolor=lightpink"</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">               ? "style=filled, fillcolor=lightpink"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">               : "";</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">               : "";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline"></td>
    <td class="lineNumber">2298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">} // namespace llvm</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">} // namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline"></td>
    <td class="lineNumber">2300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">AnalysisKey MemorySSAAnalysis::Key;</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">AnalysisKey MemorySSAAnalysis::Key;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline"></td>
    <td class="lineNumber">2302</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">MemorySSAAnalysis::Result MemorySSAAnalysis::run(Function &F,</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">MemorySSAAnalysis::Result MemorySSAAnalysis::run(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline">                                                 FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">2304</td>
    <td class="codeline">                                                 FunctionAnalysisManager &AM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">  auto &AA = AM.getResult<AAManager>(F);</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">  auto &AA = AM.getResult<AAManager>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">  return MemorySSAAnalysis::Result(std::make_unique<MemorySSA>(F, &AA, &DT));</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">  return MemorySSAAnalysis::Result(std::make_unique<MemorySSA>(F, &AA, &DT));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline"></td>
    <td class="lineNumber">2309</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">bool MemorySSAAnalysis::Result::invalidate(</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">bool MemorySSAAnalysis::Result::invalidate(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">    Function &F, const PreservedAnalyses &PA,</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">    Function &F, const PreservedAnalyses &PA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">    FunctionAnalysisManager::Invalidator &Inv) {</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">    FunctionAnalysisManager::Invalidator &Inv) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">  auto PAC = PA.getChecker<MemorySSAAnalysis>();</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">  auto PAC = PA.getChecker<MemorySSAAnalysis>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">  return !(PAC.preserved() || PAC.preservedSet<AllAnalysesOn<Function>>()) ||</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">  return !(PAC.preserved() || PAC.preservedSet<AllAnalysesOn<Function>>()) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">         Inv.invalidate<AAManager>(F, PA) ||</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">         Inv.invalidate<AAManager>(F, PA) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">         Inv.invalidate<DominatorTreeAnalysis>(F, PA);</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">         Inv.invalidate<DominatorTreeAnalysis>(F, PA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">PreservedAnalyses MemorySSAPrinterPass::run(Function &F,</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">PreservedAnalyses MemorySSAPrinterPass::run(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">                                            FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">                                            FunctionAnalysisManager &AM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">  auto &MSSA = AM.getResult<MemorySSAAnalysis>(F).getMSSA();</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">  auto &MSSA = AM.getResult<MemorySSAAnalysis>(F).getMSSA();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">  if (EnsureOptimizedUses)</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">  if (EnsureOptimizedUses)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">    MSSA.ensureOptimizedUses();</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">    MSSA.ensureOptimizedUses();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">  if (DotCFGMSSA != "") {</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">  if (DotCFGMSSA != "") {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">    DOTFuncMSSAInfo CFGInfo(F, MSSA);</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">    DOTFuncMSSAInfo CFGInfo(F, MSSA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">    WriteGraph(&CFGInfo, "", false, "MSSA", DotCFGMSSA);</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">    WriteGraph(&CFGInfo, "", false, "MSSA", DotCFGMSSA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">    OS << "MemorySSA for function: " << F.getName() << "\n";</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">    OS << "MemorySSA for function: " << F.getName() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">    MSSA.print(OS);</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">    MSSA.print(OS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline"></td>
    <td class="lineNumber">2331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">  return PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline"></td>
    <td class="lineNumber">2334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">PreservedAnalyses MemorySSAWalkerPrinterPass::run(Function &F,</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">PreservedAnalyses MemorySSAWalkerPrinterPass::run(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">                                                  FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">                                                  FunctionAnalysisManager &AM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">  auto &MSSA = AM.getResult<MemorySSAAnalysis>(F).getMSSA();</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">  auto &MSSA = AM.getResult<MemorySSAAnalysis>(F).getMSSA();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">  OS << "MemorySSA (walker) for function: " << F.getName() << "\n";</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">  OS << "MemorySSA (walker) for function: " << F.getName() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">  MemorySSAWalkerAnnotatedWriter Writer(&MSSA);</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">  MemorySSAWalkerAnnotatedWriter Writer(&MSSA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">  F.print(OS, &Writer);</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">  F.print(OS, &Writer);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline"></td>
    <td class="lineNumber">2341</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">  return PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline"></td>
    <td class="lineNumber">2344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">PreservedAnalyses MemorySSAVerifierPass::run(Function &F,</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">PreservedAnalyses MemorySSAVerifierPass::run(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">                                             FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">                                             FunctionAnalysisManager &AM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">  AM.getResult<MemorySSAAnalysis>(F).getMSSA().verifyMemorySSA();</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">  AM.getResult<MemorySSAAnalysis>(F).getMSSA().verifyMemorySSA();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline"></td>
    <td class="lineNumber">2348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">  return PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline"></td>
    <td class="lineNumber">2351</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline">char MemorySSAWrapperPass::ID = 0;</td>
    <td class="lineNumber">2352</td>
    <td class="codeline">char MemorySSAWrapperPass::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline"></td>
    <td class="lineNumber">2353</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">MemorySSAWrapperPass::MemorySSAWrapperPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">MemorySSAWrapperPass::MemorySSAWrapperPass() : FunctionPass(ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">  initializeMemorySSAWrapperPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">  initializeMemorySSAWrapperPassPass(*PassRegistry::getPassRegistry());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline"></td>
    <td class="lineNumber">2357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">void MemorySSAWrapperPass::releaseMemory() { MSSA.reset(); }</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">void MemorySSAWrapperPass::releaseMemory() { MSSA.reset(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline"></td>
    <td class="lineNumber">2359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">void MemorySSAWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">void MemorySSAWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">  AU.setPreservesAll();</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">  AU.setPreservesAll();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline">  AU.addRequiredTransitive<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">2362</td>
    <td class="codeline">  AU.addRequiredTransitive<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">  AU.addRequiredTransitive<AAResultsWrapperPass>();</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">  AU.addRequiredTransitive<AAResultsWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline"></td>
    <td class="lineNumber">2365</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">bool MemorySSAWrapperPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">bool MemorySSAWrapperPass::runOnFunction(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">  MSSA.reset(new MemorySSA(F, &AA, &DT));</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">  MSSA.reset(new MemorySSA(F, &AA, &DT));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline"></td>
    <td class="lineNumber">2372</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">void MemorySSAWrapperPass::verifyAnalysis() const {</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">void MemorySSAWrapperPass::verifyAnalysis() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">  if (VerifyMemorySSA)</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">  if (VerifyMemorySSA)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">    MSSA->verifyMemorySSA();</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">    MSSA->verifyMemorySSA();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline"></td>
    <td class="lineNumber">2377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">void MemorySSAWrapperPass::print(raw_ostream &OS, const Module *M) const {</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">void MemorySSAWrapperPass::print(raw_ostream &OS, const Module *M) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">  MSSA->print(OS);</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">  MSSA->print(OS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline"></td>
    <td class="lineNumber">2381</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">MemorySSAWalker::MemorySSAWalker(MemorySSA *M) : MSSA(M) {}</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">MemorySSAWalker::MemorySSAWalker(MemorySSA *M) : MSSA(M) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline"></td>
    <td class="lineNumber">2383</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">/// Walk the use-def chains starting at \p StartingAccess and find</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">/// Walk the use-def chains starting at \p StartingAccess and find</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline">/// the MemoryAccess that actually clobbers Loc.</td>
    <td class="lineNumber">2385</td>
    <td class="codeline">/// the MemoryAccess that actually clobbers Loc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">/// \returns our clobbering memory access</td>
    <td class="lineNumber">2387</td>
    <td class="codeline">/// \returns our clobbering memory access</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">MemoryAccess *MemorySSA::ClobberWalkerBase::getClobberingMemoryAccessBase(</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">MemoryAccess *MemorySSA::ClobberWalkerBase::getClobberingMemoryAccessBase(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">    MemoryAccess *StartingAccess, const MemoryLocation &Loc,</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">    MemoryAccess *StartingAccess, const MemoryLocation &Loc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">    BatchAAResults &BAA, unsigned &UpwardWalkLimit) {</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">    BatchAAResults &BAA, unsigned &UpwardWalkLimit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">  assert(!isa<MemoryUse>(StartingAccess) && "Use cannot be defining access");</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">  assert(!isa<MemoryUse>(StartingAccess) && "Use cannot be defining access");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline"></td>
    <td class="lineNumber">2392</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">  Instruction *I = nullptr;</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">  Instruction *I = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">  if (auto *StartingUseOrDef = dyn_cast<MemoryUseOrDef>(StartingAccess)) {</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">  if (auto *StartingUseOrDef = dyn_cast<MemoryUseOrDef>(StartingAccess)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">    if (MSSA->isLiveOnEntryDef(StartingUseOrDef))</td>
    <td class="lineNumber">2395</td>
    <td class="codeline">    if (MSSA->isLiveOnEntryDef(StartingUseOrDef))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">      return StartingUseOrDef;</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">      return StartingUseOrDef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline"></td>
    <td class="lineNumber">2397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">    I = StartingUseOrDef->getMemoryInst();</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">    I = StartingUseOrDef->getMemoryInst();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline"></td>
    <td class="lineNumber">2399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">    // Conservatively, fences are always clobbers, so don't perform the walk if</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">    // Conservatively, fences are always clobbers, so don't perform the walk if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">    // we hit a fence.</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">    // we hit a fence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">    if (!isa<CallBase>(I) && I->isFenceLike())</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">    if (!isa<CallBase>(I) && I->isFenceLike())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline">      return StartingUseOrDef;</td>
    <td class="lineNumber">2403</td>
    <td class="codeline">      return StartingUseOrDef;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline"></td>
    <td class="lineNumber">2405</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline">  UpwardsMemoryQuery Q;</td>
    <td class="lineNumber">2406</td>
    <td class="codeline">  UpwardsMemoryQuery Q;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">  Q.OriginalAccess = StartingAccess;</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">  Q.OriginalAccess = StartingAccess;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">  Q.StartingLoc = Loc;</td>
    <td class="lineNumber">2408</td>
    <td class="codeline">  Q.StartingLoc = Loc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">  Q.Inst = nullptr;</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">  Q.Inst = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">  Q.IsCall = false;</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">  Q.IsCall = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline"></td>
    <td class="lineNumber">2411</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">  // Unlike the other function, do not walk to the def of a def, because we are</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">  // Unlike the other function, do not walk to the def of a def, because we are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">  // handed something we already believe is the clobbering access.</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">  // handed something we already believe is the clobbering access.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">  // We never set SkipSelf to true in Q in this method.</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">  // We never set SkipSelf to true in Q in this method.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">  MemoryAccess *Clobber =</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">  MemoryAccess *Clobber =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">      Walker.findClobber(BAA, StartingAccess, Q, UpwardWalkLimit);</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">      Walker.findClobber(BAA, StartingAccess, Q, UpwardWalkLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">    dbgs() << "Clobber starting at access " << *StartingAccess << "\n";</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">    dbgs() << "Clobber starting at access " << *StartingAccess << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">    if (I)</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">    if (I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">      dbgs() << "  for instruction " << *I << "\n";</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">      dbgs() << "  for instruction " << *I << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">    dbgs() << "  is " << *Clobber << "\n";</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">    dbgs() << "  is " << *Clobber << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">  return Clobber;</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">  return Clobber;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline"></td>
    <td class="lineNumber">2425</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">static const Instruction *</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">static const Instruction *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">getInvariantGroupClobberingInstruction(Instruction &I, DominatorTree &DT) {</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">getInvariantGroupClobberingInstruction(Instruction &I, DominatorTree &DT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">  if (!I.hasMetadata(LLVMContext::MD_invariant_group) || I.isVolatile())</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">  if (!I.hasMetadata(LLVMContext::MD_invariant_group) || I.isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline"></td>
    <td class="lineNumber">2430</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">  // We consider bitcasts and zero GEPs to be the same pointer value. Start by</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">  // We consider bitcasts and zero GEPs to be the same pointer value. Start by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">  // stripping bitcasts and zero GEPs, then we will recursively look at loads</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">  // stripping bitcasts and zero GEPs, then we will recursively look at loads</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">  // and stores through bitcasts and zero GEPs.</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">  // and stores through bitcasts and zero GEPs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">  Value *PointerOperand = getLoadStorePointerOperand(&I)->stripPointerCasts();</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">  Value *PointerOperand = getLoadStorePointerOperand(&I)->stripPointerCasts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline"></td>
    <td class="lineNumber">2435</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">  // It's not safe to walk the use list of a global value because function</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">  // It's not safe to walk the use list of a global value because function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">  // passes aren't allowed to look outside their functions.</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">  // passes aren't allowed to look outside their functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">  // FIXME: this could be fixed by filtering instructions from outside of</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">  // FIXME: this could be fixed by filtering instructions from outside of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">  // current function.</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">  // current function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">  if (isa<Constant>(PointerOperand))</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">  if (isa<Constant>(PointerOperand))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline"></td>
    <td class="lineNumber">2442</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">  // Queue to process all pointers that are equivalent to load operand.</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">  // Queue to process all pointers that are equivalent to load operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">  SmallVector<const Value *, 8> PointerUsesQueue;</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">  SmallVector<const Value *, 8> PointerUsesQueue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">  PointerUsesQueue.push_back(PointerOperand);</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">  PointerUsesQueue.push_back(PointerOperand);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline"></td>
    <td class="lineNumber">2446</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">  const Instruction *MostDominatingInstruction = &I;</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">  const Instruction *MostDominatingInstruction = &I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline"></td>
    <td class="lineNumber">2448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">  // FIXME: This loop is O(n^2) because dominates can be O(n) and in worst case</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">  // FIXME: This loop is O(n^2) because dominates can be O(n) and in worst case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">  // we will see all the instructions. It may not matter in practice. If it</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">  // we will see all the instructions. It may not matter in practice. If it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">  // does, we will have to support MemorySSA construction and updates.</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">  // does, we will have to support MemorySSA construction and updates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">  while (!PointerUsesQueue.empty()) {</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">  while (!PointerUsesQueue.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline">    const Value *Ptr = PointerUsesQueue.pop_back_val();</td>
    <td class="lineNumber">2453</td>
    <td class="codeline">    const Value *Ptr = PointerUsesQueue.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">    assert(Ptr && !isa<GlobalValue>(Ptr) &&</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">    assert(Ptr && !isa<GlobalValue>(Ptr) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">           "Null or GlobalValue should not be inserted");</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">           "Null or GlobalValue should not be inserted");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline"></td>
    <td class="lineNumber">2456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">    for (const User *Us : Ptr->users()) {</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">    for (const User *Us : Ptr->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">      auto *U = dyn_cast<Instruction>(Us);</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">      auto *U = dyn_cast<Instruction>(Us);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">      if (!U || U == &I || !DT.dominates(U, MostDominatingInstruction))</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">      if (!U || U == &I || !DT.dominates(U, MostDominatingInstruction))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2460</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline"></td>
    <td class="lineNumber">2461</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">      // Add bitcasts and zero GEPs to queue.</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">      // Add bitcasts and zero GEPs to queue.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline">      if (isa<BitCastInst>(U)) {</td>
    <td class="lineNumber">2463</td>
    <td class="codeline">      if (isa<BitCastInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">        PointerUsesQueue.push_back(U);</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">        PointerUsesQueue.push_back(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U)) {</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">        if (GEP->hasAllZeroIndices())</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">        if (GEP->hasAllZeroIndices())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">          PointerUsesQueue.push_back(U);</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">          PointerUsesQueue.push_back(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">      // If we hit a load/store with an invariant.group metadata and the same</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">      // If we hit a load/store with an invariant.group metadata and the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">      // pointer operand, we can assume that value pointed to by the pointer</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">      // pointer operand, we can assume that value pointed to by the pointer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline">      // operand didn't change.</td>
    <td class="lineNumber">2475</td>
    <td class="codeline">      // operand didn't change.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline">      if (U->hasMetadata(LLVMContext::MD_invariant_group) &&</td>
    <td class="lineNumber">2476</td>
    <td class="codeline">      if (U->hasMetadata(LLVMContext::MD_invariant_group) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline">          getLoadStorePointerOperand(U) == Ptr && !U->isVolatile()) {</td>
    <td class="lineNumber">2477</td>
    <td class="codeline">          getLoadStorePointerOperand(U) == Ptr && !U->isVolatile()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline">        MostDominatingInstruction = U;</td>
    <td class="lineNumber">2478</td>
    <td class="codeline">        MostDominatingInstruction = U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2480</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2481</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">  return MostDominatingInstruction == &I ? nullptr : MostDominatingInstruction;</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">  return MostDominatingInstruction == &I ? nullptr : MostDominatingInstruction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline"></td>
    <td class="lineNumber">2484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">MemoryAccess *MemorySSA::ClobberWalkerBase::getClobberingMemoryAccessBase(</td>
    <td class="lineNumber">2485</td>
    <td class="codeline">MemoryAccess *MemorySSA::ClobberWalkerBase::getClobberingMemoryAccessBase(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">    MemoryAccess *MA, BatchAAResults &BAA, unsigned &UpwardWalkLimit,</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">    MemoryAccess *MA, BatchAAResults &BAA, unsigned &UpwardWalkLimit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline">    bool SkipSelf, bool UseInvariantGroup) {</td>
    <td class="lineNumber">2487</td>
    <td class="codeline">    bool SkipSelf, bool UseInvariantGroup) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">  auto *StartingAccess = dyn_cast<MemoryUseOrDef>(MA);</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">  auto *StartingAccess = dyn_cast<MemoryUseOrDef>(MA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">  // If this is a MemoryPhi, we can't do anything.</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">  // If this is a MemoryPhi, we can't do anything.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline">  if (!StartingAccess)</td>
    <td class="lineNumber">2490</td>
    <td class="codeline">  if (!StartingAccess)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">    return MA;</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">    return MA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline"></td>
    <td class="lineNumber">2492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline">  if (UseInvariantGroup) {</td>
    <td class="lineNumber">2493</td>
    <td class="codeline">  if (UseInvariantGroup) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">    if (auto *I = getInvariantGroupClobberingInstruction(</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">    if (auto *I = getInvariantGroupClobberingInstruction(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline">            *StartingAccess->getMemoryInst(), MSSA->getDomTree())) {</td>
    <td class="lineNumber">2495</td>
    <td class="codeline">            *StartingAccess->getMemoryInst(), MSSA->getDomTree())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">      assert(isa<LoadInst>(I) || isa<StoreInst>(I));</td>
    <td class="lineNumber">2496</td>
    <td class="codeline">      assert(isa<LoadInst>(I) || isa<StoreInst>(I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline"></td>
    <td class="lineNumber">2497</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">      auto *ClobberMA = MSSA->getMemoryAccess(I);</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">      auto *ClobberMA = MSSA->getMemoryAccess(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">      assert(ClobberMA);</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">      assert(ClobberMA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">      if (isa<MemoryUse>(ClobberMA))</td>
    <td class="lineNumber">2500</td>
    <td class="codeline">      if (isa<MemoryUse>(ClobberMA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">        return ClobberMA->getDefiningAccess();</td>
    <td class="lineNumber">2501</td>
    <td class="codeline">        return ClobberMA->getDefiningAccess();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">      return ClobberMA;</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">      return ClobberMA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2503</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline"></td>
    <td class="lineNumber">2505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">  bool IsOptimized = false;</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">  bool IsOptimized = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline"></td>
    <td class="lineNumber">2507</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">  // If this is an already optimized use or def, return the optimized result.</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">  // If this is an already optimized use or def, return the optimized result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">  // Note: Currently, we store the optimized def result in a separate field,</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">  // Note: Currently, we store the optimized def result in a separate field,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline">  // since we can't use the defining access.</td>
    <td class="lineNumber">2510</td>
    <td class="codeline">  // since we can't use the defining access.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">  if (StartingAccess->isOptimized()) {</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">  if (StartingAccess->isOptimized()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline">    if (!SkipSelf || !isa<MemoryDef>(StartingAccess))</td>
    <td class="lineNumber">2512</td>
    <td class="codeline">    if (!SkipSelf || !isa<MemoryDef>(StartingAccess))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline">      return StartingAccess->getOptimized();</td>
    <td class="lineNumber">2513</td>
    <td class="codeline">      return StartingAccess->getOptimized();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">    IsOptimized = true;</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">    IsOptimized = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2515</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline"></td>
    <td class="lineNumber">2516</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">  const Instruction *I = StartingAccess->getMemoryInst();</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">  const Instruction *I = StartingAccess->getMemoryInst();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline">  // We can't sanely do anything with a fence, since they conservatively clobber</td>
    <td class="lineNumber">2518</td>
    <td class="codeline">  // We can't sanely do anything with a fence, since they conservatively clobber</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">  // all memory, and have no locations to get pointers from to try to</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">  // all memory, and have no locations to get pointers from to try to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline">  // disambiguate.</td>
    <td class="lineNumber">2520</td>
    <td class="codeline">  // disambiguate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline">  if (!isa<CallBase>(I) && I->isFenceLike())</td>
    <td class="lineNumber">2521</td>
    <td class="codeline">  if (!isa<CallBase>(I) && I->isFenceLike())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline">    return StartingAccess;</td>
    <td class="lineNumber">2522</td>
    <td class="codeline">    return StartingAccess;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline"></td>
    <td class="lineNumber">2523</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline">  UpwardsMemoryQuery Q(I, StartingAccess);</td>
    <td class="lineNumber">2524</td>
    <td class="codeline">  UpwardsMemoryQuery Q(I, StartingAccess);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline"></td>
    <td class="lineNumber">2525</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">  if (isUseTriviallyOptimizableToLiveOnEntry(BAA, I)) {</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">  if (isUseTriviallyOptimizableToLiveOnEntry(BAA, I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline">    MemoryAccess *LiveOnEntry = MSSA->getLiveOnEntryDef();</td>
    <td class="lineNumber">2527</td>
    <td class="codeline">    MemoryAccess *LiveOnEntry = MSSA->getLiveOnEntryDef();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">    StartingAccess->setOptimized(LiveOnEntry);</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">    StartingAccess->setOptimized(LiveOnEntry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">    return LiveOnEntry;</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">    return LiveOnEntry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline"></td>
    <td class="lineNumber">2531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">  MemoryAccess *OptimizedAccess;</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">  MemoryAccess *OptimizedAccess;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">  if (!IsOptimized) {</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">  if (!IsOptimized) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline">    // Start with the thing we already think clobbers this location</td>
    <td class="lineNumber">2534</td>
    <td class="codeline">    // Start with the thing we already think clobbers this location</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline">    MemoryAccess *DefiningAccess = StartingAccess->getDefiningAccess();</td>
    <td class="lineNumber">2535</td>
    <td class="codeline">    MemoryAccess *DefiningAccess = StartingAccess->getDefiningAccess();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline"></td>
    <td class="lineNumber">2536</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline">    // At this point, DefiningAccess may be the live on entry def.</td>
    <td class="lineNumber">2537</td>
    <td class="codeline">    // At this point, DefiningAccess may be the live on entry def.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline">    // If it is, we will not get a better result.</td>
    <td class="lineNumber">2538</td>
    <td class="codeline">    // If it is, we will not get a better result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline">    if (MSSA->isLiveOnEntryDef(DefiningAccess)) {</td>
    <td class="lineNumber">2539</td>
    <td class="codeline">    if (MSSA->isLiveOnEntryDef(DefiningAccess)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">      StartingAccess->setOptimized(DefiningAccess);</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">      StartingAccess->setOptimized(DefiningAccess);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline">      return DefiningAccess;</td>
    <td class="lineNumber">2541</td>
    <td class="codeline">      return DefiningAccess;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2542</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline"></td>
    <td class="lineNumber">2543</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline">    OptimizedAccess =</td>
    <td class="lineNumber">2544</td>
    <td class="codeline">    OptimizedAccess =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline">        Walker.findClobber(BAA, DefiningAccess, Q, UpwardWalkLimit);</td>
    <td class="lineNumber">2545</td>
    <td class="codeline">        Walker.findClobber(BAA, DefiningAccess, Q, UpwardWalkLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline">    StartingAccess->setOptimized(OptimizedAccess);</td>
    <td class="lineNumber">2546</td>
    <td class="codeline">    StartingAccess->setOptimized(OptimizedAccess);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline">  } else</td>
    <td class="lineNumber">2547</td>
    <td class="codeline">  } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">    OptimizedAccess = StartingAccess->getOptimized();</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">    OptimizedAccess = StartingAccess->getOptimized();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline"></td>
    <td class="lineNumber">2549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Starting Memory SSA clobber for " << *I << " is ");</td>
    <td class="lineNumber">2550</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Starting Memory SSA clobber for " << *I << " is ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << *StartingAccess << "\n");</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << *StartingAccess << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Optimized Memory SSA clobber for " << *I << " is ");</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Optimized Memory SSA clobber for " << *I << " is ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << *OptimizedAccess << "\n");</td>
    <td class="lineNumber">2553</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << *OptimizedAccess << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline"></td>
    <td class="lineNumber">2554</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline">  MemoryAccess *Result;</td>
    <td class="lineNumber">2555</td>
    <td class="codeline">  MemoryAccess *Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline">  if (SkipSelf && isa<MemoryPhi>(OptimizedAccess) &&</td>
    <td class="lineNumber">2556</td>
    <td class="codeline">  if (SkipSelf && isa<MemoryPhi>(OptimizedAccess) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline">      isa<MemoryDef>(StartingAccess) && UpwardWalkLimit) {</td>
    <td class="lineNumber">2557</td>
    <td class="codeline">      isa<MemoryDef>(StartingAccess) && UpwardWalkLimit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">    assert(isa<MemoryDef>(Q.OriginalAccess));</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">    assert(isa<MemoryDef>(Q.OriginalAccess));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline">    Q.SkipSelfAccess = true;</td>
    <td class="lineNumber">2559</td>
    <td class="codeline">    Q.SkipSelfAccess = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline">    Result = Walker.findClobber(BAA, OptimizedAccess, Q, UpwardWalkLimit);</td>
    <td class="lineNumber">2560</td>
    <td class="codeline">    Result = Walker.findClobber(BAA, OptimizedAccess, Q, UpwardWalkLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline">  } else</td>
    <td class="lineNumber">2561</td>
    <td class="codeline">  } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline">    Result = OptimizedAccess;</td>
    <td class="lineNumber">2562</td>
    <td class="codeline">    Result = OptimizedAccess;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline"></td>
    <td class="lineNumber">2563</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Result Memory SSA clobber [SkipSelf = " << SkipSelf);</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Result Memory SSA clobber [SkipSelf = " << SkipSelf);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "] for " << *I << " is " << *Result << "\n");</td>
    <td class="lineNumber">2565</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "] for " << *I << " is " << *Result << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline"></td>
    <td class="lineNumber">2566</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">2567</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline"></td>
    <td class="lineNumber">2569</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline">MemoryAccess *</td>
    <td class="lineNumber">2570</td>
    <td class="codeline">MemoryAccess *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline">DoNothingMemorySSAWalker::getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">2571</td>
    <td class="codeline">DoNothingMemorySSAWalker::getClobberingMemoryAccess(MemoryAccess *MA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline">                                                    BatchAAResults &) {</td>
    <td class="lineNumber">2572</td>
    <td class="codeline">                                                    BatchAAResults &) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline">  if (auto *Use = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">2573</td>
    <td class="codeline">  if (auto *Use = dyn_cast<MemoryUseOrDef>(MA))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline">    return Use->getDefiningAccess();</td>
    <td class="lineNumber">2574</td>
    <td class="codeline">    return Use->getDefiningAccess();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">  return MA;</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">  return MA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2576</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline"></td>
    <td class="lineNumber">2577</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeline">MemoryAccess *DoNothingMemorySSAWalker::getClobberingMemoryAccess(</td>
    <td class="lineNumber">2578</td>
    <td class="codeline">MemoryAccess *DoNothingMemorySSAWalker::getClobberingMemoryAccess(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeline">    MemoryAccess *StartingAccess, const MemoryLocation &, BatchAAResults &) {</td>
    <td class="lineNumber">2579</td>
    <td class="codeline">    MemoryAccess *StartingAccess, const MemoryLocation &, BatchAAResults &) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeline">  if (auto *Use = dyn_cast<MemoryUseOrDef>(StartingAccess))</td>
    <td class="lineNumber">2580</td>
    <td class="codeline">  if (auto *Use = dyn_cast<MemoryUseOrDef>(StartingAccess))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeline">    return Use->getDefiningAccess();</td>
    <td class="lineNumber">2581</td>
    <td class="codeline">    return Use->getDefiningAccess();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeline">  return StartingAccess;</td>
    <td class="lineNumber">2582</td>
    <td class="codeline">  return StartingAccess;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2583</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeline"></td>
    <td class="lineNumber">2584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeline">void MemoryPhi::deleteMe(DerivedUser *Self) {</td>
    <td class="lineNumber">2585</td>
    <td class="codeline">void MemoryPhi::deleteMe(DerivedUser *Self) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeline">  delete static_cast<MemoryPhi *>(Self);</td>
    <td class="lineNumber">2586</td>
    <td class="codeline">  delete static_cast<MemoryPhi *>(Self);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2587</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeline"></td>
    <td class="lineNumber">2588</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeline">void MemoryDef::deleteMe(DerivedUser *Self) {</td>
    <td class="lineNumber">2589</td>
    <td class="codeline">void MemoryDef::deleteMe(DerivedUser *Self) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeline">  delete static_cast<MemoryDef *>(Self);</td>
    <td class="lineNumber">2590</td>
    <td class="codeline">  delete static_cast<MemoryDef *>(Self);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2591</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeline"></td>
    <td class="lineNumber">2592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeline">void MemoryUse::deleteMe(DerivedUser *Self) {</td>
    <td class="lineNumber">2593</td>
    <td class="codeline">void MemoryUse::deleteMe(DerivedUser *Self) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeline">  delete static_cast<MemoryUse *>(Self);</td>
    <td class="lineNumber">2594</td>
    <td class="codeline">  delete static_cast<MemoryUse *>(Self);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2595</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeline"></td>
    <td class="lineNumber">2596</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeline">bool upward_defs_iterator::IsGuaranteedLoopInvariant(const Value *Ptr) const {</td>
    <td class="lineNumber">2597</td>
    <td class="codeline">bool upward_defs_iterator::IsGuaranteedLoopInvariant(const Value *Ptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeline">  auto IsGuaranteedLoopInvariantBase = [](const Value *Ptr) {</td>
    <td class="lineNumber">2598</td>
    <td class="codeline">  auto IsGuaranteedLoopInvariantBase = [](const Value *Ptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeline">    Ptr = Ptr->stripPointerCasts();</td>
    <td class="lineNumber">2599</td>
    <td class="codeline">    Ptr = Ptr->stripPointerCasts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeline">    if (!isa<Instruction>(Ptr))</td>
    <td class="lineNumber">2600</td>
    <td class="codeline">    if (!isa<Instruction>(Ptr))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">2601</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeline">    return isa<AllocaInst>(Ptr);</td>
    <td class="lineNumber">2602</td>
    <td class="codeline">    return isa<AllocaInst>(Ptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2603</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeline"></td>
    <td class="lineNumber">2604</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeline">  Ptr = Ptr->stripPointerCasts();</td>
    <td class="lineNumber">2605</td>
    <td class="codeline">  Ptr = Ptr->stripPointerCasts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeline">  if (auto *I = dyn_cast<Instruction>(Ptr)) {</td>
    <td class="lineNumber">2606</td>
    <td class="codeline">  if (auto *I = dyn_cast<Instruction>(Ptr)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeline">    if (I->getParent()->isEntryBlock())</td>
    <td class="lineNumber">2607</td>
    <td class="codeline">    if (I->getParent()->isEntryBlock())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">2608</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2609</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeline">  if (auto *GEP = dyn_cast<GEPOperator>(Ptr)) {</td>
    <td class="lineNumber">2610</td>
    <td class="codeline">  if (auto *GEP = dyn_cast<GEPOperator>(Ptr)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeline">    return IsGuaranteedLoopInvariantBase(GEP->getPointerOperand()) &&</td>
    <td class="lineNumber">2611</td>
    <td class="codeline">    return IsGuaranteedLoopInvariantBase(GEP->getPointerOperand()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeline">           GEP->hasAllConstantIndices();</td>
    <td class="lineNumber">2612</td>
    <td class="codeline">           GEP->hasAllConstantIndices();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2613</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeline">  return IsGuaranteedLoopInvariantBase(Ptr);</td>
    <td class="lineNumber">2614</td>
    <td class="codeline">  return IsGuaranteedLoopInvariantBase(Ptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2615</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeline"></td>
    <td class="lineNumber">2616</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- MemorySSA.cpp - Memory SSA Builder ---------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- MemorySSA.cpp - Memory SSA Builder ---------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file implements the MemorySSA class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file implements the MemorySSA class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/Analysis/MemorySSA.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/Analysis/MemorySSA.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/DenseSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/DenseSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/DepthFirstIterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/DepthFirstIterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/ADT/StringExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/ADT/StringExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/CFGPrinter.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/CFGPrinter.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Analysis/IteratedDominanceFrontier.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Analysis/IteratedDominanceFrontier.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/AssemblyAnnotationWriter.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/AssemblyAnnotationWriter.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/Use.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/Use.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/Support/FormattedStream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/Support/FormattedStream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/Support/GraphWriter.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/Support/GraphWriter.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">#include <memory></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">#include <memory></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">#define DEBUG_TYPE "memoryssa"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">#define DEBUG_TYPE "memoryssa"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">static cl::opt<std::string></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">static cl::opt<std::string></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">    DotCFGMSSA("dot-cfg-mssa",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">    DotCFGMSSA("dot-cfg-mssa",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">               cl::value_desc("file name for generated dot file"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">               cl::value_desc("file name for generated dot file"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">               cl::desc("file name for generated dot file"), cl::init(""));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">               cl::desc("file name for generated dot file"), cl::init(""));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(MemorySSAWrapperPass, "memoryssa", "Memory SSA", false,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">67</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(MemorySSAWrapperPass, "memoryssa", "Memory SSA", false,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">                      true)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">                      true)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">69</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">70</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(MemorySSAWrapperPass, "memoryssa", "Memory SSA", false,</td>
    <td class="lineNumber">19</td>
    <td class="lineNumber">71</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(MemorySSAWrapperPass, "memoryssa", "Memory SSA", false,</td>
    <td class="lineNumber">19</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">                    true)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">                    true)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">static cl::opt<unsigned> MaxCheckLimit(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">static cl::opt<unsigned> MaxCheckLimit(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">    "memssa-check-limit", cl::Hidden, cl::init(100),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">    "memssa-check-limit", cl::Hidden, cl::init(100),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">    cl::desc("The maximum number of stores/phis MemorySSA"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">    cl::desc("The maximum number of stores/phis MemorySSA"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">             "will consider trying to walk past (default = 100)"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">             "will consider trying to walk past (default = 100)"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">// Always verify MemorySSA if expensive checking is enabled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">// Always verify MemorySSA if expensive checking is enabled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">bool llvm::VerifyMemorySSA = true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">bool llvm::VerifyMemorySSA = true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">#else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">#else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">bool llvm::VerifyMemorySSA = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">bool llvm::VerifyMemorySSA = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">static cl::opt<bool, true></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">static cl::opt<bool, true></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">    VerifyMemorySSAX("verify-memoryssa", cl::location(VerifyMemorySSA),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">    VerifyMemorySSAX("verify-memoryssa", cl::location(VerifyMemorySSA),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">                     cl::Hidden, cl::desc("Enable verification of MemorySSA."));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">                     cl::Hidden, cl::desc("Enable verification of MemorySSA."));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">const static char LiveOnEntryStr[] = "liveOnEntry";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">const static char LiveOnEntryStr[] = "liveOnEntry";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">/// An assembly annotator class to print Memory SSA information in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">/// An assembly annotator class to print Memory SSA information in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">/// comments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">/// comments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">class MemorySSAAnnotatedWriter : public AssemblyAnnotationWriter {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">class MemorySSAAnnotatedWriter : public AssemblyAnnotationWriter {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">  const MemorySSA *MSSA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">  const MemorySSA *MSSA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  MemorySSAAnnotatedWriter(const MemorySSA *M) : MSSA(M) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  MemorySSAAnnotatedWriter(const MemorySSA *M) : MSSA(M) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  void emitBasicBlockStartAnnot(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  void emitBasicBlockStartAnnot(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">                                formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">                                formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(BB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(BB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">      OS << "; " << *MA << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">      OS << "; " << *MA << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">  void emitInstructionAnnot(const Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">  void emitInstructionAnnot(const Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">                            formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">                            formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">      OS << "; " << *MA << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">      OS << "; " << *MA << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">/// An assembly annotator class to print Memory SSA information in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">/// An assembly annotator class to print Memory SSA information in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">/// comments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">/// comments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">class MemorySSAWalkerAnnotatedWriter : public AssemblyAnnotationWriter {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">class MemorySSAWalkerAnnotatedWriter : public AssemblyAnnotationWriter {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  MemorySSA *MSSA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  MemorySSA *MSSA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">  MemorySSAWalker *Walker;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">  MemorySSAWalker *Walker;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">  BatchAAResults BAA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">  BatchAAResults BAA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  MemorySSAWalkerAnnotatedWriter(MemorySSA *M)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  MemorySSAWalkerAnnotatedWriter(MemorySSA *M)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">      : MSSA(M), Walker(M->getWalker()), BAA(M->getAA()) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">      : MSSA(M), Walker(M->getWalker()), BAA(M->getAA()) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  void emitBasicBlockStartAnnot(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  void emitBasicBlockStartAnnot(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">                                formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">                                formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(BB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(BB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">      OS << "; " << *MA << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">      OS << "; " << *MA << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">  void emitInstructionAnnot(const Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">  void emitInstructionAnnot(const Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">                            formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">                            formatted_raw_ostream &OS) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">    if (MemoryAccess *MA = MSSA->getMemoryAccess(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">      MemoryAccess *Clobber = Walker->getClobberingMemoryAccess(MA, BAA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">      MemoryAccess *Clobber = Walker->getClobberingMemoryAccess(MA, BAA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">      OS << "; " << *MA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">      OS << "; " << *MA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">      if (Clobber) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">      if (Clobber) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">        OS << " - clobbered by ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">        OS << " - clobbered by ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">        if (MSSA->isLiveOnEntryDef(Clobber))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">        if (MSSA->isLiveOnEntryDef(Clobber))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">          OS << LiveOnEntryStr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">          OS << LiveOnEntryStr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">          OS << *Clobber;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">          OS << *Clobber;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">      OS << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">      OS << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">/// Our current alias analysis API differentiates heavily between calls and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">/// Our current alias analysis API differentiates heavily between calls and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">/// non-calls, and functions called on one usually assert on the other.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">/// non-calls, and functions called on one usually assert on the other.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">/// This class encapsulates the distinction to simplify other code that wants</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">/// This class encapsulates the distinction to simplify other code that wants</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">/// "Memory affecting instructions and related data" to use as a key.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">/// "Memory affecting instructions and related data" to use as a key.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">/// For example, this class is used as a densemap key in the use optimizer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">/// For example, this class is used as a densemap key in the use optimizer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">class MemoryLocOrCall {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">class MemoryLocOrCall {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">  bool IsCall = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">  bool IsCall = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">  MemoryLocOrCall(MemoryUseOrDef *MUD)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">  MemoryLocOrCall(MemoryUseOrDef *MUD)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">      : MemoryLocOrCall(MUD->getMemoryInst()) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">      : MemoryLocOrCall(MUD->getMemoryInst()) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  MemoryLocOrCall(const MemoryUseOrDef *MUD)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  MemoryLocOrCall(const MemoryUseOrDef *MUD)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">      : MemoryLocOrCall(MUD->getMemoryInst()) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">      : MemoryLocOrCall(MUD->getMemoryInst()) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">  MemoryLocOrCall(Instruction *Inst) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">  MemoryLocOrCall(Instruction *Inst) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">    if (auto *C = dyn_cast<CallBase>(Inst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">    if (auto *C = dyn_cast<CallBase>(Inst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">      IsCall = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">      IsCall = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">      Call = C;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">      Call = C;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">      IsCall = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">      IsCall = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">      // There is no such thing as a memorylocation for a fence inst, and it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">      // There is no such thing as a memorylocation for a fence inst, and it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">      // unique in that regard.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">      // unique in that regard.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">      if (!isa<FenceInst>(Inst))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">      if (!isa<FenceInst>(Inst))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">        Loc = MemoryLocation::get(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">        Loc = MemoryLocation::get(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">  explicit MemoryLocOrCall(const MemoryLocation &Loc) : Loc(Loc) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">  explicit MemoryLocOrCall(const MemoryLocation &Loc) : Loc(Loc) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  const CallBase *getCall() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  const CallBase *getCall() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">    assert(IsCall);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">    assert(IsCall);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">    return Call;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">    return Call;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  MemoryLocation getLoc() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  MemoryLocation getLoc() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">    assert(!IsCall);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">    assert(!IsCall);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">    return Loc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">    return Loc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">  bool operator==(const MemoryLocOrCall &Other) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">  bool operator==(const MemoryLocOrCall &Other) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">    if (IsCall != Other.IsCall)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">    if (IsCall != Other.IsCall)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">    if (!IsCall)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">    if (!IsCall)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">      return Loc == Other.Loc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">      return Loc == Other.Loc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">    if (Call->getCalledOperand() != Other.Call->getCalledOperand())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">    if (Call->getCalledOperand() != Other.Call->getCalledOperand())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">    return Call->arg_size() == Other.Call->arg_size() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">    return Call->arg_size() == Other.Call->arg_size() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">           std::equal(Call->arg_begin(), Call->arg_end(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">           std::equal(Call->arg_begin(), Call->arg_end(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">                      Other.Call->arg_begin());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">                      Other.Call->arg_begin());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  union {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  union {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    const CallBase *Call;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    const CallBase *Call;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">    MemoryLocation Loc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">    MemoryLocation Loc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">template <> struct DenseMapInfo<MemoryLocOrCall> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">template <> struct DenseMapInfo<MemoryLocOrCall> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  static inline MemoryLocOrCall getEmptyKey() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  static inline MemoryLocOrCall getEmptyKey() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">    return MemoryLocOrCall(DenseMapInfo<MemoryLocation>::getEmptyKey());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">    return MemoryLocOrCall(DenseMapInfo<MemoryLocation>::getEmptyKey());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  static inline MemoryLocOrCall getTombstoneKey() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  static inline MemoryLocOrCall getTombstoneKey() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">    return MemoryLocOrCall(DenseMapInfo<MemoryLocation>::getTombstoneKey());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">    return MemoryLocOrCall(DenseMapInfo<MemoryLocation>::getTombstoneKey());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">  static unsigned getHashValue(const MemoryLocOrCall &MLOC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">  static unsigned getHashValue(const MemoryLocOrCall &MLOC) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">    if (!MLOC.IsCall)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">    if (!MLOC.IsCall)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">      return hash_combine(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">      return hash_combine(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">          MLOC.IsCall,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">          MLOC.IsCall,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">          DenseMapInfo<MemoryLocation>::getHashValue(MLOC.getLoc()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">          DenseMapInfo<MemoryLocation>::getHashValue(MLOC.getLoc()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">    hash_code hash =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">    hash_code hash =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">        hash_combine(MLOC.IsCall, DenseMapInfo<const Value *>::getHashValue(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">        hash_combine(MLOC.IsCall, DenseMapInfo<const Value *>::getHashValue(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">                                      MLOC.getCall()->getCalledOperand()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">                                      MLOC.getCall()->getCalledOperand()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">    for (const Value *Arg : MLOC.getCall()->args())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">    for (const Value *Arg : MLOC.getCall()->args())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">      hash = hash_combine(hash, DenseMapInfo<const Value *>::getHashValue(Arg));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">      hash = hash_combine(hash, DenseMapInfo<const Value *>::getHashValue(Arg));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    return hash;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    return hash;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  static bool isEqual(const MemoryLocOrCall &LHS, const MemoryLocOrCall &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  static bool isEqual(const MemoryLocOrCall &LHS, const MemoryLocOrCall &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">    return LHS == RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">    return LHS == RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">/// This does one-way checks to see if Use could theoretically be hoisted above</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">/// This does one-way checks to see if Use could theoretically be hoisted above</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">/// MayClobber. This will not check the other way around.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">/// MayClobber. This will not check the other way around.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">/// This assumes that, for the purposes of MemorySSA, Use comes directly after</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">/// This assumes that, for the purposes of MemorySSA, Use comes directly after</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">/// MayClobber, with no potentially clobbering operations in between them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">/// MayClobber, with no potentially clobbering operations in between them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">/// (Where potentially clobbering ops are memory barriers, aliased stores, etc.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">/// (Where potentially clobbering ops are memory barriers, aliased stores, etc.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">static bool areLoadsReorderable(const LoadInst *Use,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">static bool areLoadsReorderable(const LoadInst *Use,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">                                const LoadInst *MayClobber) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">                                const LoadInst *MayClobber) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  bool VolatileUse = Use->isVolatile();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  bool VolatileUse = Use->isVolatile();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">  bool VolatileClobber = MayClobber->isVolatile();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">  bool VolatileClobber = MayClobber->isVolatile();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">  // Volatile operations may never be reordered with other volatile operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  // Volatile operations may never be reordered with other volatile operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  if (VolatileUse && VolatileClobber)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  if (VolatileUse && VolatileClobber)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  // Otherwise, volatile doesn't matter here. From the language reference:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  // Otherwise, volatile doesn't matter here. From the language reference:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">  // 'optimizers may change the order of volatile operations relative to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">  // 'optimizers may change the order of volatile operations relative to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  // non-volatile operations.'"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  // non-volatile operations.'"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  // If a load is seq_cst, it cannot be moved above other loads. If its ordering</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  // If a load is seq_cst, it cannot be moved above other loads. If its ordering</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  // is weaker, it can be moved above other loads. We just need to be sure that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  // is weaker, it can be moved above other loads. We just need to be sure that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">  // MayClobber isn't an acquire load, because loads can't be moved above</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">  // MayClobber isn't an acquire load, because loads can't be moved above</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  // acquire loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  // acquire loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  // Note that this explicitly *does* allow the free reordering of monotonic (or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  // Note that this explicitly *does* allow the free reordering of monotonic (or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  // weaker) loads of the same address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  // weaker) loads of the same address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  bool SeqCstUse = Use->getOrdering() == AtomicOrdering::SequentiallyConsistent;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  bool SeqCstUse = Use->getOrdering() == AtomicOrdering::SequentiallyConsistent;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  bool MayClobberIsAcquire = isAtLeastOrStrongerThan(MayClobber->getOrdering(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  bool MayClobberIsAcquire = isAtLeastOrStrongerThan(MayClobber->getOrdering(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">                                                     AtomicOrdering::Acquire);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">                                                     AtomicOrdering::Acquire);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  return !(SeqCstUse || MayClobberIsAcquire);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  return !(SeqCstUse || MayClobberIsAcquire);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">template <typename AliasAnalysisType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">template <typename AliasAnalysisType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">static bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">static bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">instructionClobbersQuery(const MemoryDef *MD, const MemoryLocation &UseLoc,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">instructionClobbersQuery(const MemoryDef *MD, const MemoryLocation &UseLoc,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">                         const Instruction *UseInst, AliasAnalysisType &AA) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">                         const Instruction *UseInst, AliasAnalysisType &AA) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  Instruction *DefInst = MD->getMemoryInst();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  Instruction *DefInst = MD->getMemoryInst();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  assert(DefInst && "Defining instruction not actually an instruction");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  assert(DefInst && "Defining instruction not actually an instruction");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(DefInst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(DefInst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">    // These intrinsics will show up as affecting memory, but they are just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">    // These intrinsics will show up as affecting memory, but they are just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">    // markers, mostly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">    // markers, mostly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">    // FIXME: We probably don't actually want MemorySSA to model these at all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">    // FIXME: We probably don't actually want MemorySSA to model these at all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">    // (including creating MemoryAccesses for them): we just end up inventing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">    // (including creating MemoryAccesses for them): we just end up inventing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">    // clobbers where they don't really exist at all. Please see D43269 for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">    // clobbers where they don't really exist at all. Please see D43269 for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">    // context.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">    // context.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">    case Intrinsic::invariant_start:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">    case Intrinsic::invariant_start:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">    case Intrinsic::invariant_end:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">    case Intrinsic::invariant_end:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">    case Intrinsic::assume:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">    case Intrinsic::assume:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">    case Intrinsic::experimental_noalias_scope_decl:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">    case Intrinsic::experimental_noalias_scope_decl:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">    case Intrinsic::pseudoprobe:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">    case Intrinsic::pseudoprobe:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">    case Intrinsic::dbg_declare:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">    case Intrinsic::dbg_declare:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">    case Intrinsic::dbg_label:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">    case Intrinsic::dbg_label:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">    case Intrinsic::dbg_value:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">    case Intrinsic::dbg_value:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">      llvm_unreachable("debuginfo shouldn't have associated defs!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">      llvm_unreachable("debuginfo shouldn't have associated defs!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">  if (auto *CB = dyn_cast_or_null<CallBase>(UseInst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">  if (auto *CB = dyn_cast_or_null<CallBase>(UseInst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">    ModRefInfo I = AA.getModRefInfo(DefInst, CB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">    ModRefInfo I = AA.getModRefInfo(DefInst, CB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    return isModOrRefSet(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    return isModOrRefSet(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">  if (auto *DefLoad = dyn_cast<LoadInst>(DefInst))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">  if (auto *DefLoad = dyn_cast<LoadInst>(DefInst))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">    if (auto *UseLoad = dyn_cast_or_null<LoadInst>(UseInst))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">    if (auto *UseLoad = dyn_cast_or_null<LoadInst>(UseInst))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">      return !areLoadsReorderable(UseLoad, DefLoad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">      return !areLoadsReorderable(UseLoad, DefLoad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">  ModRefInfo I = AA.getModRefInfo(DefInst, UseLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">  ModRefInfo I = AA.getModRefInfo(DefInst, UseLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">  return isModSet(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">  return isModSet(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">template <typename AliasAnalysisType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">template <typename AliasAnalysisType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">static bool instructionClobbersQuery(MemoryDef *MD, const MemoryUseOrDef *MU,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">static bool instructionClobbersQuery(MemoryDef *MD, const MemoryUseOrDef *MU,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">                                     const MemoryLocOrCall &UseMLOC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">                                     const MemoryLocOrCall &UseMLOC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">                                     AliasAnalysisType &AA) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">                                     AliasAnalysisType &AA) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">  // FIXME: This is a temporary hack to allow a single instructionClobbersQuery</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">  // FIXME: This is a temporary hack to allow a single instructionClobbersQuery</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">  // to exist while MemoryLocOrCall is pushed through places.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">  // to exist while MemoryLocOrCall is pushed through places.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">  if (UseMLOC.IsCall)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">  if (UseMLOC.IsCall)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">    return instructionClobbersQuery(MD, MemoryLocation(), MU->getMemoryInst(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">    return instructionClobbersQuery(MD, MemoryLocation(), MU->getMemoryInst(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">                                    AA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">                                    AA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  return instructionClobbersQuery(MD, UseMLOC.getLoc(), MU->getMemoryInst(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  return instructionClobbersQuery(MD, UseMLOC.getLoc(), MU->getMemoryInst(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">                                  AA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">                                  AA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">// Return true when MD may alias MU, return false otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">// Return true when MD may alias MU, return false otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">bool MemorySSAUtil::defClobbersUseOrDef(MemoryDef *MD, const MemoryUseOrDef *MU,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">bool MemorySSAUtil::defClobbersUseOrDef(MemoryDef *MD, const MemoryUseOrDef *MU,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">                                        AliasAnalysis &AA) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">                                        AliasAnalysis &AA) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">  return instructionClobbersQuery(MD, MU, MemoryLocOrCall(MU), AA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">  return instructionClobbersQuery(MD, MU, MemoryLocOrCall(MU), AA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">struct UpwardsMemoryQuery {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">struct UpwardsMemoryQuery {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  // True if our original query started off as a call</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  // True if our original query started off as a call</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">  bool IsCall = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">  bool IsCall = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">  // The pointer location we started the query with. This will be empty if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">  // The pointer location we started the query with. This will be empty if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">  // IsCall is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">  // IsCall is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  MemoryLocation StartingLoc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  MemoryLocation StartingLoc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">  // This is the instruction we were querying about.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">  // This is the instruction we were querying about.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">  const Instruction *Inst = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">  const Instruction *Inst = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">  // The MemoryAccess we actually got called with, used to test local domination</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">  // The MemoryAccess we actually got called with, used to test local domination</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">  const MemoryAccess *OriginalAccess = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">  const MemoryAccess *OriginalAccess = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  bool SkipSelfAccess = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  bool SkipSelfAccess = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  UpwardsMemoryQuery() = default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  UpwardsMemoryQuery() = default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">  UpwardsMemoryQuery(const Instruction *Inst, const MemoryAccess *Access)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">  UpwardsMemoryQuery(const Instruction *Inst, const MemoryAccess *Access)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">      : IsCall(isa<CallBase>(Inst)), Inst(Inst), OriginalAccess(Access) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">      : IsCall(isa<CallBase>(Inst)), Inst(Inst), OriginalAccess(Access) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">    if (!IsCall)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">    if (!IsCall)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">      StartingLoc = MemoryLocation::get(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">      StartingLoc = MemoryLocation::get(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">template <typename AliasAnalysisType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">template <typename AliasAnalysisType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">static bool isUseTriviallyOptimizableToLiveOnEntry(AliasAnalysisType &AA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">static bool isUseTriviallyOptimizableToLiveOnEntry(AliasAnalysisType &AA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">                                                   const Instruction *I) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">                                                   const Instruction *I) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  // If the memory can't be changed, then loads of the memory can't be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  // If the memory can't be changed, then loads of the memory can't be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  // clobbered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  // clobbered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">    return I->hasMetadata(LLVMContext::MD_invariant_load) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">    return I->hasMetadata(LLVMContext::MD_invariant_load) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">           !isModSet(AA.getModRefInfoMask(MemoryLocation::get(LI)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">           !isModSet(AA.getModRefInfoMask(MemoryLocation::get(LI)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">/// Verifies that `Start` is clobbered by `ClobberAt`, and that nothing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">/// Verifies that `Start` is clobbered by `ClobberAt`, and that nothing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">/// inbetween `Start` and `ClobberAt` can clobbers `Start`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">/// inbetween `Start` and `ClobberAt` can clobbers `Start`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">/// This is meant to be as simple and self-contained as possible. Because it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">/// This is meant to be as simple and self-contained as possible. Because it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">/// uses no cache, etc., it can be relatively expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">/// uses no cache, etc., it can be relatively expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">/// \param Start     The MemoryAccess that we want to walk from.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">/// \param Start     The MemoryAccess that we want to walk from.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">/// \param ClobberAt A clobber for Start.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">/// \param ClobberAt A clobber for Start.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">/// \param StartLoc  The MemoryLocation for Start.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">/// \param StartLoc  The MemoryLocation for Start.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">/// \param MSSA      The MemorySSA instance that Start and ClobberAt belong to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">/// \param MSSA      The MemorySSA instance that Start and ClobberAt belong to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">/// \param Query     The UpwardsMemoryQuery we used for our search.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">/// \param Query     The UpwardsMemoryQuery we used for our search.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">/// \param AA        The AliasAnalysis we used for our search.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">/// \param AA        The AliasAnalysis we used for our search.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">/// \param AllowImpreciseClobber Always false, unless we do relaxed verify.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">/// \param AllowImpreciseClobber Always false, unless we do relaxed verify.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">LLVM_ATTRIBUTE_UNUSED static void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">LLVM_ATTRIBUTE_UNUSED static void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">checkClobberSanity(const MemoryAccess *Start, MemoryAccess *ClobberAt,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">checkClobberSanity(const MemoryAccess *Start, MemoryAccess *ClobberAt,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">                   const MemoryLocation &StartLoc, const MemorySSA &MSSA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">                   const MemoryLocation &StartLoc, const MemorySSA &MSSA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">                   const UpwardsMemoryQuery &Query, BatchAAResults &AA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">                   const UpwardsMemoryQuery &Query, BatchAAResults &AA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">                   bool AllowImpreciseClobber = false) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">                   bool AllowImpreciseClobber = false) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">  assert(MSSA.dominates(ClobberAt, Start) && "Clobber doesn't dominate start?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">  assert(MSSA.dominates(ClobberAt, Start) && "Clobber doesn't dominate start?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  if (MSSA.isLiveOnEntryDef(Start)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  if (MSSA.isLiveOnEntryDef(Start)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">    assert(MSSA.isLiveOnEntryDef(ClobberAt) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">    assert(MSSA.isLiveOnEntryDef(ClobberAt) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">           "liveOnEntry must clobber itself");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">           "liveOnEntry must clobber itself");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">  bool FoundClobber = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">  bool FoundClobber = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">  DenseSet<ConstMemoryAccessPair> VisitedPhis;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">  DenseSet<ConstMemoryAccessPair> VisitedPhis;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">  SmallVector<ConstMemoryAccessPair, 8> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">  SmallVector<ConstMemoryAccessPair, 8> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  Worklist.emplace_back(Start, StartLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  Worklist.emplace_back(Start, StartLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">  // Walk all paths from Start to ClobberAt, while looking for clobbers. If one</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">  // Walk all paths from Start to ClobberAt, while looking for clobbers. If one</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  // is found, complain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  // is found, complain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">    auto MAP = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">    auto MAP = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">    // All we care about is that nothing from Start to ClobberAt clobbers Start.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">    // All we care about is that nothing from Start to ClobberAt clobbers Start.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">    // We learn nothing from revisiting nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">    // We learn nothing from revisiting nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">    if (!VisitedPhis.insert(MAP).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">    if (!VisitedPhis.insert(MAP).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">    for (const auto *MA : def_chain(MAP.first)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">    for (const auto *MA : def_chain(MAP.first)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">      if (MA == ClobberAt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">      if (MA == ClobberAt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">        if (const auto *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">        if (const auto *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">          // instructionClobbersQuery isn't essentially free, so don't use `|=`,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">          // instructionClobbersQuery isn't essentially free, so don't use `|=`,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">          // since it won't let us short-circuit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">          // since it won't let us short-circuit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">          //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">          //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">          // Also, note that this can't be hoisted out of the `Worklist` loop,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">          // Also, note that this can't be hoisted out of the `Worklist` loop,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">          // since MD may only act as a clobber for 1 of N MemoryLocations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">          // since MD may only act as a clobber for 1 of N MemoryLocations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">          FoundClobber = FoundClobber || MSSA.isLiveOnEntryDef(MD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">          FoundClobber = FoundClobber || MSSA.isLiveOnEntryDef(MD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">          if (!FoundClobber) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">          if (!FoundClobber) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">            if (instructionClobbersQuery(MD, MAP.second, Query.Inst, AA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">            if (instructionClobbersQuery(MD, MAP.second, Query.Inst, AA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">              FoundClobber = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">              FoundClobber = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">      // We should never hit liveOnEntry, unless it's the clobber.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">      // We should never hit liveOnEntry, unless it's the clobber.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">      assert(!MSSA.isLiveOnEntryDef(MA) && "Hit liveOnEntry before clobber?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">      assert(!MSSA.isLiveOnEntryDef(MA) && "Hit liveOnEntry before clobber?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">      if (const auto *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">      if (const auto *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">        // If Start is a Def, skip self.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">        // If Start is a Def, skip self.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">        if (MD == Start)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">        if (MD == Start)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">        assert(!instructionClobbersQuery(MD, MAP.second, Query.Inst, AA) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">        assert(!instructionClobbersQuery(MD, MAP.second, Query.Inst, AA) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">               "Found clobber before reaching ClobberAt!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">               "Found clobber before reaching ClobberAt!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">      if (const auto *MU = dyn_cast<MemoryUse>(MA)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">      if (const auto *MU = dyn_cast<MemoryUse>(MA)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">        (void)MU;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">        (void)MU;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">        assert (MU == Start &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">        assert (MU == Start &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">                "Can only find use in def chain if Start is a use");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">                "Can only find use in def chain if Start is a use");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">      assert(isa<MemoryPhi>(MA));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">      assert(isa<MemoryPhi>(MA));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">      // Add reachable phi predecessors</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">      // Add reachable phi predecessors</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">      for (auto ItB = upward_defs_begin(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">      for (auto ItB = upward_defs_begin(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">                    {const_cast<MemoryAccess *>(MA), MAP.second},</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">                    {const_cast<MemoryAccess *>(MA), MAP.second},</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">                    MSSA.getDomTree()),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">                    MSSA.getDomTree()),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">                ItE = upward_defs_end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">                ItE = upward_defs_end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">           ItB != ItE; ++ItB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">           ItB != ItE; ++ItB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">        if (MSSA.getDomTree().isReachableFromEntry(ItB.getPhiArgBlock()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">        if (MSSA.getDomTree().isReachableFromEntry(ItB.getPhiArgBlock()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">          Worklist.emplace_back(*ItB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">          Worklist.emplace_back(*ItB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">  // If the verify is done following an optimization, it's possible that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">  // If the verify is done following an optimization, it's possible that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">  // ClobberAt was a conservative clobbering, that we can now infer is not a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  // ClobberAt was a conservative clobbering, that we can now infer is not a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">  // true clobbering access. Don't fail the verify if that's the case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">  // true clobbering access. Don't fail the verify if that's the case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  // We do have accesses that claim they're optimized, but could be optimized</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  // We do have accesses that claim they're optimized, but could be optimized</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  // further. Updating all these can be expensive, so allow it for now (FIXME).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  // further. Updating all these can be expensive, so allow it for now (FIXME).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  if (AllowImpreciseClobber)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  if (AllowImpreciseClobber)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  // If ClobberAt is a MemoryPhi, we can assume something above it acted as a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  // If ClobberAt is a MemoryPhi, we can assume something above it acted as a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  // clobber. Otherwise, `ClobberAt` should've acted as a clobber at some point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  // clobber. Otherwise, `ClobberAt` should've acted as a clobber at some point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  assert((isa<MemoryPhi>(ClobberAt) || FoundClobber) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  assert((isa<MemoryPhi>(ClobberAt) || FoundClobber) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">         "ClobberAt never acted as a clobber");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">         "ClobberAt never acted as a clobber");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">/// Our algorithm for walking (and trying to optimize) clobbers, all wrapped up</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">/// Our algorithm for walking (and trying to optimize) clobbers, all wrapped up</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">/// in one class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">/// in one class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">class ClobberWalker {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">class ClobberWalker {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">  /// Save a few bytes by using unsigned instead of size_t.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">  /// Save a few bytes by using unsigned instead of size_t.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  using ListIndex = unsigned;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  using ListIndex = unsigned;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  /// Represents a span of contiguous MemoryDefs, potentially ending in a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  /// Represents a span of contiguous MemoryDefs, potentially ending in a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">  /// MemoryPhi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">  /// MemoryPhi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  struct DefPath {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  struct DefPath {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">    MemoryLocation Loc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">    MemoryLocation Loc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">    // Note that, because we always walk in reverse, Last will always dominate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">    // Note that, because we always walk in reverse, Last will always dominate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">    // First. Also note that First and Last are inclusive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">    // First. Also note that First and Last are inclusive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">    MemoryAccess *First;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">    MemoryAccess *First;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">    MemoryAccess *Last;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">    MemoryAccess *Last;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">    std::optional<ListIndex> Previous;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">    std::optional<ListIndex> Previous;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">    DefPath(const MemoryLocation &Loc, MemoryAccess *First, MemoryAccess *Last,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">    DefPath(const MemoryLocation &Loc, MemoryAccess *First, MemoryAccess *Last,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">            std::optional<ListIndex> Previous)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">            std::optional<ListIndex> Previous)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">        : Loc(Loc), First(First), Last(Last), Previous(Previous) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">        : Loc(Loc), First(First), Last(Last), Previous(Previous) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">    DefPath(const MemoryLocation &Loc, MemoryAccess *Init,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">    DefPath(const MemoryLocation &Loc, MemoryAccess *Init,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">            std::optional<ListIndex> Previous)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">            std::optional<ListIndex> Previous)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">        : DefPath(Loc, Init, Init, Previous) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">        : DefPath(Loc, Init, Init, Previous) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  const MemorySSA &MSSA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  const MemorySSA &MSSA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  DominatorTree &DT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  DominatorTree &DT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  BatchAAResults *AA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  BatchAAResults *AA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">  UpwardsMemoryQuery *Query;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">  UpwardsMemoryQuery *Query;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  unsigned *UpwardWalkLimit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  unsigned *UpwardWalkLimit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  // Phi optimization bookkeeping:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  // Phi optimization bookkeeping:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">  // List of DefPath to process during the current phi optimization walk.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">  // List of DefPath to process during the current phi optimization walk.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">  SmallVector<DefPath, 32> Paths;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">  SmallVector<DefPath, 32> Paths;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  // List of visited <Access, Location> pairs; we can skip paths already</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  // List of visited <Access, Location> pairs; we can skip paths already</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">  // visited with the same memory location.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">  // visited with the same memory location.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  DenseSet<ConstMemoryAccessPair> VisitedPhis;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  DenseSet<ConstMemoryAccessPair> VisitedPhis;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  /// Find the nearest def or phi that `From` can legally be optimized to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  /// Find the nearest def or phi that `From` can legally be optimized to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">  const MemoryAccess *getWalkTarget(const MemoryPhi *From) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">  const MemoryAccess *getWalkTarget(const MemoryPhi *From) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">    assert(From->getNumOperands() && "Phi with no operands?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">    assert(From->getNumOperands() && "Phi with no operands?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">    BasicBlock *BB = From->getBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">    BasicBlock *BB = From->getBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">    MemoryAccess *Result = MSSA.getLiveOnEntryDef();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">    MemoryAccess *Result = MSSA.getLiveOnEntryDef();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">    DomTreeNode *Node = DT.getNode(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">    DomTreeNode *Node = DT.getNode(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">    while ((Node = Node->getIDom())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">    while ((Node = Node->getIDom())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">      auto *Defs = MSSA.getBlockDefs(Node->getBlock());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">      auto *Defs = MSSA.getBlockDefs(Node->getBlock());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">      if (Defs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">      if (Defs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">        return &*Defs->rbegin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">        return &*Defs->rbegin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">    return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">    return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">  /// Result of calling walkToPhiOrClobber.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">  /// Result of calling walkToPhiOrClobber.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  struct UpwardsWalkResult {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  struct UpwardsWalkResult {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">    /// The "Result" of the walk. Either a clobber, the last thing we walked, or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">    /// The "Result" of the walk. Either a clobber, the last thing we walked, or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">    /// both. Include alias info when clobber found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">    /// both. Include alias info when clobber found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">    MemoryAccess *Result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">    MemoryAccess *Result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">    bool IsKnownClobber;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">    bool IsKnownClobber;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  /// Walk to the next Phi or Clobber in the def chain starting at Desc.Last.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  /// Walk to the next Phi or Clobber in the def chain starting at Desc.Last.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  /// This will update Desc.Last as it walks. It will (optionally) also stop at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  /// This will update Desc.Last as it walks. It will (optionally) also stop at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  /// StopAt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  /// StopAt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// This does not test for whether StopAt is a clobber</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// This does not test for whether StopAt is a clobber</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">  UpwardsWalkResult</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">  UpwardsWalkResult</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  walkToPhiOrClobber(DefPath &Desc, const MemoryAccess *StopAt = nullptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  walkToPhiOrClobber(DefPath &Desc, const MemoryAccess *StopAt = nullptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">                     const MemoryAccess *SkipStopAt = nullptr) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">                     const MemoryAccess *SkipStopAt = nullptr) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">    assert(!isa<MemoryUse>(Desc.Last) && "Uses don't exist in my world");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">    assert(!isa<MemoryUse>(Desc.Last) && "Uses don't exist in my world");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">    assert(UpwardWalkLimit && "Need a valid walk limit");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">    assert(UpwardWalkLimit && "Need a valid walk limit");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">    bool LimitAlreadyReached = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">    bool LimitAlreadyReached = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">    // (*UpwardWalkLimit) may be 0 here, due to the loop in tryOptimizePhi. Set</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">    // (*UpwardWalkLimit) may be 0 here, due to the loop in tryOptimizePhi. Set</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">    // it to 1. This will not do any alias() calls. It either returns in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">    // it to 1. This will not do any alias() calls. It either returns in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">    // first iteration in the loop below, or is set back to 0 if all def chains</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">    // first iteration in the loop below, or is set back to 0 if all def chains</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">    // are free of MemoryDefs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">    // are free of MemoryDefs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">    if (!*UpwardWalkLimit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">    if (!*UpwardWalkLimit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">      *UpwardWalkLimit = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">      *UpwardWalkLimit = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">      LimitAlreadyReached = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">      LimitAlreadyReached = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">    for (MemoryAccess *Current : def_chain(Desc.Last)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">    for (MemoryAccess *Current : def_chain(Desc.Last)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">      Desc.Last = Current;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">      Desc.Last = Current;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">      if (Current == StopAt || Current == SkipStopAt)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">      if (Current == StopAt || Current == SkipStopAt)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">        return {Current, false};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">        return {Current, false};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">      if (auto *MD = dyn_cast<MemoryDef>(Current)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">      if (auto *MD = dyn_cast<MemoryDef>(Current)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">        if (MSSA.isLiveOnEntryDef(MD))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">        if (MSSA.isLiveOnEntryDef(MD))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">          return {MD, true};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">          return {MD, true};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">        if (!--*UpwardWalkLimit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">        if (!--*UpwardWalkLimit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">          return {Current, true};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">          return {Current, true};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">        if (instructionClobbersQuery(MD, Desc.Loc, Query->Inst, *AA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">        if (instructionClobbersQuery(MD, Desc.Loc, Query->Inst, *AA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">          return {MD, true};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">          return {MD, true};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">    if (LimitAlreadyReached)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">    if (LimitAlreadyReached)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">      *UpwardWalkLimit = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">      *UpwardWalkLimit = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">    assert(isa<MemoryPhi>(Desc.Last) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">    assert(isa<MemoryPhi>(Desc.Last) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">           "Ended at a non-clobber that's not a phi?");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">           "Ended at a non-clobber that's not a phi?");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">    return {Desc.Last, false};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">    return {Desc.Last, false};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">  void addSearches(MemoryPhi *Phi, SmallVectorImpl<ListIndex> &PausedSearches,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">  void addSearches(MemoryPhi *Phi, SmallVectorImpl<ListIndex> &PausedSearches,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">                   ListIndex PriorNode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">                   ListIndex PriorNode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    auto UpwardDefsBegin = upward_defs_begin({Phi, Paths[PriorNode].Loc}, DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    auto UpwardDefsBegin = upward_defs_begin({Phi, Paths[PriorNode].Loc}, DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">    auto UpwardDefs = make_range(UpwardDefsBegin, upward_defs_end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">    auto UpwardDefs = make_range(UpwardDefsBegin, upward_defs_end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">    for (const MemoryAccessPair &P : UpwardDefs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">    for (const MemoryAccessPair &P : UpwardDefs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">      PausedSearches.push_back(Paths.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">      PausedSearches.push_back(Paths.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">      Paths.emplace_back(P.second, P.first, PriorNode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">      Paths.emplace_back(P.second, P.first, PriorNode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">  /// Represents a search that terminated after finding a clobber. This clobber</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">  /// Represents a search that terminated after finding a clobber. This clobber</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">  /// may or may not be present in the path of defs from LastNode..SearchStart,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">  /// may or may not be present in the path of defs from LastNode..SearchStart,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// since it may have been retrieved from cache.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// since it may have been retrieved from cache.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  struct TerminatedPath {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  struct TerminatedPath {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    MemoryAccess *Clobber;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    MemoryAccess *Clobber;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">    ListIndex LastNode;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">    ListIndex LastNode;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">  /// Get an access that keeps us from optimizing to the given phi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">  /// Get an access that keeps us from optimizing to the given phi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">  /// PausedSearches is an array of indices into the Paths array. Its incoming</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">  /// PausedSearches is an array of indices into the Paths array. Its incoming</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">  /// value is the indices of searches that stopped at the last phi optimization</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">  /// value is the indices of searches that stopped at the last phi optimization</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">  /// target. It's left in an unspecified state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">  /// target. It's left in an unspecified state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  /// If this returns std::nullopt, NewPaused is a vector of searches that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  /// If this returns std::nullopt, NewPaused is a vector of searches that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  /// state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  /// state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">  std::optional<TerminatedPath></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">  std::optional<TerminatedPath></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  getBlockingAccess(const MemoryAccess *StopWhere,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  getBlockingAccess(const MemoryAccess *StopWhere,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">                    SmallVectorImpl<ListIndex> &PausedSearches,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">                    SmallVectorImpl<ListIndex> &PausedSearches,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">                    SmallVectorImpl<ListIndex> &NewPaused,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">                    SmallVectorImpl<ListIndex> &NewPaused,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">                    SmallVectorImpl<TerminatedPath> &Terminated) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">                    SmallVectorImpl<TerminatedPath> &Terminated) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">    assert(!PausedSearches.empty() && "No searches to continue?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">    assert(!PausedSearches.empty() && "No searches to continue?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">    // BFS vs DFS really doesn't make a difference here, so just do a DFS with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">    // BFS vs DFS really doesn't make a difference here, so just do a DFS with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">    // PausedSearches as our stack.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">    // PausedSearches as our stack.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">    while (!PausedSearches.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">    while (!PausedSearches.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">      ListIndex PathIndex = PausedSearches.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">      ListIndex PathIndex = PausedSearches.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">      DefPath &Node = Paths[PathIndex];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">      DefPath &Node = Paths[PathIndex];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">      // If we've already visited this path with this MemoryLocation, we don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">      // If we've already visited this path with this MemoryLocation, we don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">      // need to do so again.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">      // need to do so again.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">      // NOTE: That we just drop these paths on the ground makes caching</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">      // NOTE: That we just drop these paths on the ground makes caching</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">      // behavior sporadic. e.g. given a diamond:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">      // behavior sporadic. e.g. given a diamond:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">      //  A</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">      //  A</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">      // B C</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">      // B C</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">      //  D</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">      //  D</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">      // ...If we walk D, B, A, C, we'll only cache the result of phi</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">      // ...If we walk D, B, A, C, we'll only cache the result of phi</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">      // optimization for A, B, and D; C will be skipped because it dies here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">      // optimization for A, B, and D; C will be skipped because it dies here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">      // This arguably isn't the worst thing ever, since:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">      // This arguably isn't the worst thing ever, since:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">      //   - We generally query things in a top-down order, so if we got below D</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">      //   - We generally query things in a top-down order, so if we got below D</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">      //     without needing cache entries for {C, MemLoc}, then chances are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">      //     without needing cache entries for {C, MemLoc}, then chances are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">      //     that those cache entries would end up ultimately unused.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">      //     that those cache entries would end up ultimately unused.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">      //   - We still cache things for A, so C only needs to walk up a bit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">      //   - We still cache things for A, so C only needs to walk up a bit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">      // If this behavior becomes problematic, we can fix without a ton of extra</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">      // If this behavior becomes problematic, we can fix without a ton of extra</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">      // work.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">      // work.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">      if (!VisitedPhis.insert({Node.Last, Node.Loc}).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">      if (!VisitedPhis.insert({Node.Last, Node.Loc}).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">      const MemoryAccess *SkipStopWhere = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">      const MemoryAccess *SkipStopWhere = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">      if (Query->SkipSelfAccess && Node.Loc == Query->StartingLoc) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">      if (Query->SkipSelfAccess && Node.Loc == Query->StartingLoc) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">        assert(isa<MemoryDef>(Query->OriginalAccess));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">        assert(isa<MemoryDef>(Query->OriginalAccess));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">        SkipStopWhere = Query->OriginalAccess;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">        SkipStopWhere = Query->OriginalAccess;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">      UpwardsWalkResult Res = walkToPhiOrClobber(Node,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">      UpwardsWalkResult Res = walkToPhiOrClobber(Node,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">                                                 /*StopAt=*/StopWhere,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">                                                 /*StopAt=*/StopWhere,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">                                                 /*SkipStopAt=*/SkipStopWhere);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">                                                 /*SkipStopAt=*/SkipStopWhere);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">      if (Res.IsKnownClobber) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">      if (Res.IsKnownClobber) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">        assert(Res.Result != StopWhere && Res.Result != SkipStopWhere);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">        assert(Res.Result != StopWhere && Res.Result != SkipStopWhere);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">        // If this wasn't a cache hit, we hit a clobber when walking. That's a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">        // If this wasn't a cache hit, we hit a clobber when walking. That's a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">        // failure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">        // failure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">        TerminatedPath Term{Res.Result, PathIndex};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">        TerminatedPath Term{Res.Result, PathIndex};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">        if (!MSSA.dominates(Res.Result, StopWhere))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">        if (!MSSA.dominates(Res.Result, StopWhere))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">          return Term;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">          return Term;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">        // Otherwise, it's a valid thing to potentially optimize to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">        // Otherwise, it's a valid thing to potentially optimize to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">        Terminated.push_back(Term);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">        Terminated.push_back(Term);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">      if (Res.Result == StopWhere || Res.Result == SkipStopWhere) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">      if (Res.Result == StopWhere || Res.Result == SkipStopWhere) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">        // We've hit our target. Save this path off for if we want to continue</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">        // We've hit our target. Save this path off for if we want to continue</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">        // walking. If we are in the mode of skipping the OriginalAccess, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">        // walking. If we are in the mode of skipping the OriginalAccess, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">        // we've reached back to the OriginalAccess, do not save path, we've</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">        // we've reached back to the OriginalAccess, do not save path, we've</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">        // just looped back to self.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">        // just looped back to self.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">        if (Res.Result != SkipStopWhere)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">        if (Res.Result != SkipStopWhere)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">          NewPaused.push_back(PathIndex);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">          NewPaused.push_back(PathIndex);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">      assert(!MSSA.isLiveOnEntryDef(Res.Result) && "liveOnEntry is a clobber");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">      assert(!MSSA.isLiveOnEntryDef(Res.Result) && "liveOnEntry is a clobber");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">      addSearches(cast<MemoryPhi>(Res.Result), PausedSearches, PathIndex);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">      addSearches(cast<MemoryPhi>(Res.Result), PausedSearches, PathIndex);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  template <typename T, typename Walker></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  template <typename T, typename Walker></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  struct generic_def_path_iterator</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  struct generic_def_path_iterator</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">      : public iterator_facade_base<generic_def_path_iterator<T, Walker>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">      : public iterator_facade_base<generic_def_path_iterator<T, Walker>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">                                    std::forward_iterator_tag, T *> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">                                    std::forward_iterator_tag, T *> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">    generic_def_path_iterator() = default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">    generic_def_path_iterator() = default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">    generic_def_path_iterator(Walker *W, ListIndex N) : W(W), N(N) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">    generic_def_path_iterator(Walker *W, ListIndex N) : W(W), N(N) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">    T &operator*() const { return curNode(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">    T &operator*() const { return curNode(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">    generic_def_path_iterator &operator++() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">    generic_def_path_iterator &operator++() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">      N = curNode().Previous;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">      N = curNode().Previous;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">      return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">    bool operator==(const generic_def_path_iterator &O) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">    bool operator==(const generic_def_path_iterator &O) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">      if (N.has_value() != O.N.has_value())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">      if (N.has_value() != O.N.has_value())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">      return !N || *N == *O.N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">      return !N || *N == *O.N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">    T &curNode() const { return W->Paths[*N]; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">    T &curNode() const { return W->Paths[*N]; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">    Walker *W = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">    Walker *W = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">    std::optional<ListIndex> N;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">    std::optional<ListIndex> N;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">  using def_path_iterator = generic_def_path_iterator<DefPath, ClobberWalker>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">  using def_path_iterator = generic_def_path_iterator<DefPath, ClobberWalker>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">  using const_def_path_iterator =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">  using const_def_path_iterator =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">      generic_def_path_iterator<const DefPath, const ClobberWalker>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">      generic_def_path_iterator<const DefPath, const ClobberWalker>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">  iterator_range<def_path_iterator> def_path(ListIndex From) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">  iterator_range<def_path_iterator> def_path(ListIndex From) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">    return make_range(def_path_iterator(this, From), def_path_iterator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">    return make_range(def_path_iterator(this, From), def_path_iterator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">  iterator_range<const_def_path_iterator> const_def_path(ListIndex From) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">  iterator_range<const_def_path_iterator> const_def_path(ListIndex From) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">    return make_range(const_def_path_iterator(this, From),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">    return make_range(const_def_path_iterator(this, From),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">                      const_def_path_iterator());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">                      const_def_path_iterator());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">  struct OptznResult {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">  struct OptznResult {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">    /// The path that contains our result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">    /// The path that contains our result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">    TerminatedPath PrimaryClobber;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">    TerminatedPath PrimaryClobber;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">    /// The paths that we can legally cache back from, but that aren't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">    /// The paths that we can legally cache back from, but that aren't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">    /// necessarily the result of the Phi optimization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">    /// necessarily the result of the Phi optimization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">    SmallVector<TerminatedPath, 4> OtherClobbers;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">    SmallVector<TerminatedPath, 4> OtherClobbers;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">  ListIndex defPathIndex(const DefPath &N) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">  ListIndex defPathIndex(const DefPath &N) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">    // The assert looks nicer if we don't need to do &N</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">    // The assert looks nicer if we don't need to do &N</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    const DefPath *NP = &N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    const DefPath *NP = &N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">    assert(!Paths.empty() && NP >= &Paths.front() && NP <= &Paths.back() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">    assert(!Paths.empty() && NP >= &Paths.front() && NP <= &Paths.back() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">           "Out of bounds DefPath!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">           "Out of bounds DefPath!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">    return NP - &Paths.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">    return NP - &Paths.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  /// Try to optimize a phi as best as we can. Returns a SmallVector of Paths</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  /// Try to optimize a phi as best as we can. Returns a SmallVector of Paths</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">  /// that act as legal clobbers. Note that this won't return *all* clobbers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">  /// that act as legal clobbers. Note that this won't return *all* clobbers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">  /// Phi optimization algorithm tl;dr:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">  /// Phi optimization algorithm tl;dr:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">  ///   - Find the earliest def/phi, A, we can optimize to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">  ///   - Find the earliest def/phi, A, we can optimize to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">  ///   - Find if all paths from the starting memory access ultimately reach A</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">  ///   - Find if all paths from the starting memory access ultimately reach A</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">  ///     - If not, optimization isn't possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">  ///     - If not, optimization isn't possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">  ///     - Otherwise, walk from A to another clobber or phi, A'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">  ///     - Otherwise, walk from A to another clobber or phi, A'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">  ///       - If A' is a def, we're done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">  ///       - If A' is a def, we're done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">  ///       - If A' is a phi, try to optimize it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">  ///       - If A' is a phi, try to optimize it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">  /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">  /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">  /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">  /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">  OptznResult tryOptimizePhi(MemoryPhi *Phi, MemoryAccess *Start,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">  OptznResult tryOptimizePhi(MemoryPhi *Phi, MemoryAccess *Start,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">                             const MemoryLocation &Loc) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">                             const MemoryLocation &Loc) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">    assert(Paths.empty() && VisitedPhis.empty() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">    assert(Paths.empty() && VisitedPhis.empty() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">           "Reset the optimization state.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">           "Reset the optimization state.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">    Paths.emplace_back(Loc, Start, Phi, std::nullopt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">    Paths.emplace_back(Loc, Start, Phi, std::nullopt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">    // Stores how many "valid" optimization nodes we had prior to calling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">    // Stores how many "valid" optimization nodes we had prior to calling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">    // addSearches/getBlockingAccess. Necessary for caching if we had a blocker.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">    // addSearches/getBlockingAccess. Necessary for caching if we had a blocker.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">    auto PriorPathsSize = Paths.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">    auto PriorPathsSize = Paths.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">    SmallVector<ListIndex, 16> PausedSearches;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">    SmallVector<ListIndex, 16> PausedSearches;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">    SmallVector<ListIndex, 8> NewPaused;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">    SmallVector<ListIndex, 8> NewPaused;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">    SmallVector<TerminatedPath, 4> TerminatedPaths;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">    SmallVector<TerminatedPath, 4> TerminatedPaths;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">    addSearches(Phi, PausedSearches, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">    addSearches(Phi, PausedSearches, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">    // Moves the TerminatedPath with the "most dominated" Clobber to the end of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">    // Moves the TerminatedPath with the "most dominated" Clobber to the end of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">    // Paths.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">    // Paths.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">    auto MoveDominatedPathToEnd = [&](SmallVectorImpl<TerminatedPath> &Paths) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">    auto MoveDominatedPathToEnd = [&](SmallVectorImpl<TerminatedPath> &Paths) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">      assert(!Paths.empty() && "Need a path to move");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">      assert(!Paths.empty() && "Need a path to move");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">      auto Dom = Paths.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">      auto Dom = Paths.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">      for (auto I = std::next(Dom), E = Paths.end(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">      for (auto I = std::next(Dom), E = Paths.end(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">        if (!MSSA.dominates(I->Clobber, Dom->Clobber))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">        if (!MSSA.dominates(I->Clobber, Dom->Clobber))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">          Dom = I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">          Dom = I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">      auto Last = Paths.end() - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">      auto Last = Paths.end() - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">      if (Last != Dom)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">      if (Last != Dom)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">        std::iter_swap(Last, Dom);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">        std::iter_swap(Last, Dom);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">    MemoryPhi *Current = Phi;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">    MemoryPhi *Current = Phi;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">      assert(!MSSA.isLiveOnEntryDef(Current) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">      assert(!MSSA.isLiveOnEntryDef(Current) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">             "liveOnEntry wasn't treated as a clobber?");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">             "liveOnEntry wasn't treated as a clobber?");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">      const auto *Target = getWalkTarget(Current);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">      const auto *Target = getWalkTarget(Current);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">      // If a TerminatedPath doesn't dominate Target, then it wasn't a legal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">      // If a TerminatedPath doesn't dominate Target, then it wasn't a legal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">      // optimization for the prior phi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">      // optimization for the prior phi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">      assert(all_of(TerminatedPaths, [&](const TerminatedPath &P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">      assert(all_of(TerminatedPaths, [&](const TerminatedPath &P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">        return MSSA.dominates(P.Clobber, Target);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">        return MSSA.dominates(P.Clobber, Target);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">      }));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">      }));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">      // FIXME: This is broken, because the Blocker may be reported to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">      // FIXME: This is broken, because the Blocker may be reported to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">      // liveOnEntry, and we'll happily wait for that to disappear (read: never)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">      // liveOnEntry, and we'll happily wait for that to disappear (read: never)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">      // For the moment, this is fine, since we do nothing with blocker info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">      // For the moment, this is fine, since we do nothing with blocker info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">      if (std::optional<TerminatedPath> Blocker = getBlockingAccess(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">      if (std::optional<TerminatedPath> Blocker = getBlockingAccess(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">              Target, PausedSearches, NewPaused, TerminatedPaths)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">              Target, PausedSearches, NewPaused, TerminatedPaths)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">        // Find the node we started at. We can't search based on N->Last, since</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">        // Find the node we started at. We can't search based on N->Last, since</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">        // we may have gone around a loop with a different MemoryLocation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">        // we may have gone around a loop with a different MemoryLocation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">        auto Iter = find_if(def_path(Blocker->LastNode), [&](const DefPath &N) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">        auto Iter = find_if(def_path(Blocker->LastNode), [&](const DefPath &N) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">          return defPathIndex(N) < PriorPathsSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">          return defPathIndex(N) < PriorPathsSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">        assert(Iter != def_path_iterator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">        assert(Iter != def_path_iterator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">        DefPath &CurNode = *Iter;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">        DefPath &CurNode = *Iter;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">        assert(CurNode.Last == Current);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">        assert(CurNode.Last == Current);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">        // Two things:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">        // Two things:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">        // A. We can't reliably cache all of NewPaused back. Consider a case</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">        // A. We can't reliably cache all of NewPaused back. Consider a case</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">        //    where we have two paths in NewPaused; one of which can't optimize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">        //    where we have two paths in NewPaused; one of which can't optimize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">        //    above this phi, whereas the other can. If we cache the second path</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">        //    above this phi, whereas the other can. If we cache the second path</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">        //    back, we'll end up with suboptimal cache entries. We can handle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">        //    back, we'll end up with suboptimal cache entries. We can handle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">        //    cases like this a bit better when we either try to find all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">        //    cases like this a bit better when we either try to find all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">        //    clobbers that block phi optimization, or when our cache starts</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">        //    clobbers that block phi optimization, or when our cache starts</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">        //    supporting unfinished searches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">        //    supporting unfinished searches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">        // B. We can't reliably cache TerminatedPaths back here without doing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">        // B. We can't reliably cache TerminatedPaths back here without doing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">        //    extra checks; consider a case like:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">        //    extra checks; consider a case like:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">        //       T</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">        //       T</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">        //      / \</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">        //      / \</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">        //     D   C</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">        //     D   C</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">        //      \ /</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">        //      \ /</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">        //       S</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">        //       S</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">        //    Where T is our target, C is a node with a clobber on it, D is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">        //    Where T is our target, C is a node with a clobber on it, D is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">        //    diamond (with a clobber *only* on the left or right node, N), and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">        //    diamond (with a clobber *only* on the left or right node, N), and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">        //    S is our start. Say we walk to D, through the node opposite N</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">        //    S is our start. Say we walk to D, through the node opposite N</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">        //    (read: ignoring the clobber), and see a cache entry in the top</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">        //    (read: ignoring the clobber), and see a cache entry in the top</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">        //    node of D. That cache entry gets put into TerminatedPaths. We then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">        //    node of D. That cache entry gets put into TerminatedPaths. We then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">        //    walk up to C (N is later in our worklist), find the clobber, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">        //    walk up to C (N is later in our worklist), find the clobber, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">        //    quit. If we append TerminatedPaths to OtherClobbers, we'll cache</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">        //    quit. If we append TerminatedPaths to OtherClobbers, we'll cache</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">        //    the bottom part of D to the cached clobber, ignoring the clobber</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">        //    the bottom part of D to the cached clobber, ignoring the clobber</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">        //    in N. Again, this problem goes away if we start tracking all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">        //    in N. Again, this problem goes away if we start tracking all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">        //    blockers for a given phi optimization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">        //    blockers for a given phi optimization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">        TerminatedPath Result{CurNode.Last, defPathIndex(CurNode)};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">        TerminatedPath Result{CurNode.Last, defPathIndex(CurNode)};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">        return {Result, {}};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">        return {Result, {}};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">      // If there's nothing left to search, then all paths led to valid clobbers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">      // If there's nothing left to search, then all paths led to valid clobbers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">      // that we got from our cache; pick the nearest to the start, and allow</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">      // that we got from our cache; pick the nearest to the start, and allow</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">      // the rest to be cached back.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">      // the rest to be cached back.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">      if (NewPaused.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">      if (NewPaused.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">        MoveDominatedPathToEnd(TerminatedPaths);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">        MoveDominatedPathToEnd(TerminatedPaths);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">        TerminatedPath Result = TerminatedPaths.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">        TerminatedPath Result = TerminatedPaths.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">        return {Result, std::move(TerminatedPaths)};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">        return {Result, std::move(TerminatedPaths)};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">      MemoryAccess *DefChainEnd = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">      MemoryAccess *DefChainEnd = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">      SmallVector<TerminatedPath, 4> Clobbers;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">      SmallVector<TerminatedPath, 4> Clobbers;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">      for (ListIndex Paused : NewPaused) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">      for (ListIndex Paused : NewPaused) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">        UpwardsWalkResult WR = walkToPhiOrClobber(Paths[Paused]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">        UpwardsWalkResult WR = walkToPhiOrClobber(Paths[Paused]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">        if (WR.IsKnownClobber)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">        if (WR.IsKnownClobber)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">          Clobbers.push_back({WR.Result, Paused});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">          Clobbers.push_back({WR.Result, Paused});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">          // Micro-opt: If we hit the end of the chain, save it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">          // Micro-opt: If we hit the end of the chain, save it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">          DefChainEnd = WR.Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">          DefChainEnd = WR.Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">      if (!TerminatedPaths.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">      if (!TerminatedPaths.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">        // If we couldn't find the dominating phi/liveOnEntry in the above loop,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">        // If we couldn't find the dominating phi/liveOnEntry in the above loop,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">        // do it now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">        // do it now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">        if (!DefChainEnd)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">        if (!DefChainEnd)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">          for (auto *MA : def_chain(const_cast<MemoryAccess *>(Target)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">          for (auto *MA : def_chain(const_cast<MemoryAccess *>(Target)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">            DefChainEnd = MA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">            DefChainEnd = MA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">        assert(DefChainEnd && "Failed to find dominating phi/liveOnEntry");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">        assert(DefChainEnd && "Failed to find dominating phi/liveOnEntry");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">        // If any of the terminated paths don't dominate the phi we'll try to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">        // If any of the terminated paths don't dominate the phi we'll try to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">        // optimize, we need to figure out what they are and quit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">        // optimize, we need to figure out what they are and quit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">        const BasicBlock *ChainBB = DefChainEnd->getBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">        const BasicBlock *ChainBB = DefChainEnd->getBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">        for (const TerminatedPath &TP : TerminatedPaths) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">        for (const TerminatedPath &TP : TerminatedPaths) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">          // Because we know that DefChainEnd is as "high" as we can go, we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">          // Because we know that DefChainEnd is as "high" as we can go, we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">          // don't need local dominance checks; BB dominance is sufficient.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">          // don't need local dominance checks; BB dominance is sufficient.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">          if (DT.dominates(ChainBB, TP.Clobber->getBlock()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">          if (DT.dominates(ChainBB, TP.Clobber->getBlock()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">            Clobbers.push_back(TP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">            Clobbers.push_back(TP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">      // If we have clobbers in the def chain, find the one closest to Current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">      // If we have clobbers in the def chain, find the one closest to Current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">      // and quit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">      // and quit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">      if (!Clobbers.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">      if (!Clobbers.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">        MoveDominatedPathToEnd(Clobbers);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">        MoveDominatedPathToEnd(Clobbers);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">        TerminatedPath Result = Clobbers.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">        TerminatedPath Result = Clobbers.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">        return {Result, std::move(Clobbers)};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">        return {Result, std::move(Clobbers)};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">      assert(all_of(NewPaused,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">      assert(all_of(NewPaused,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">                    [&](ListIndex I) { return Paths[I].Last == DefChainEnd; }));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">                    [&](ListIndex I) { return Paths[I].Last == DefChainEnd; }));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">      // Because liveOnEntry is a clobber, this must be a phi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">      // Because liveOnEntry is a clobber, this must be a phi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">      auto *DefChainPhi = cast<MemoryPhi>(DefChainEnd);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">      auto *DefChainPhi = cast<MemoryPhi>(DefChainEnd);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">      PriorPathsSize = Paths.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">      PriorPathsSize = Paths.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">      PausedSearches.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">      PausedSearches.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">      for (ListIndex I : NewPaused)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">      for (ListIndex I : NewPaused)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">        addSearches(DefChainPhi, PausedSearches, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">        addSearches(DefChainPhi, PausedSearches, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">      NewPaused.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">      NewPaused.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">      Current = DefChainPhi;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">      Current = DefChainPhi;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">  void verifyOptResult(const OptznResult &R) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">  void verifyOptResult(const OptznResult &R) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">    assert(all_of(R.OtherClobbers, [&](const TerminatedPath &P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">    assert(all_of(R.OtherClobbers, [&](const TerminatedPath &P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">      return MSSA.dominates(P.Clobber, R.PrimaryClobber.Clobber);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">      return MSSA.dominates(P.Clobber, R.PrimaryClobber.Clobber);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">    }));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">    }));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">  void resetPhiOptznState() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">  void resetPhiOptznState() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">    Paths.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">    Paths.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">    VisitedPhis.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">    VisitedPhis.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">  ClobberWalker(const MemorySSA &MSSA, DominatorTree &DT)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">  ClobberWalker(const MemorySSA &MSSA, DominatorTree &DT)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">      : MSSA(MSSA), DT(DT) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">      : MSSA(MSSA), DT(DT) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">  /// Finds the nearest clobber for the given query, optimizing phis if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">  /// Finds the nearest clobber for the given query, optimizing phis if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">  /// possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">  /// possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">  MemoryAccess *findClobber(BatchAAResults &BAA, MemoryAccess *Start,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">  MemoryAccess *findClobber(BatchAAResults &BAA, MemoryAccess *Start,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">                            UpwardsMemoryQuery &Q, unsigned &UpWalkLimit) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">                            UpwardsMemoryQuery &Q, unsigned &UpWalkLimit) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">    AA = &BAA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">    AA = &BAA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">    Query = &Q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">    Query = &Q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">    UpwardWalkLimit = &UpWalkLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">    UpwardWalkLimit = &UpWalkLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">    // Starting limit must be > 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">    // Starting limit must be > 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">    if (!UpWalkLimit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">    if (!UpWalkLimit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">      UpWalkLimit++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">      UpWalkLimit++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">    MemoryAccess *Current = Start;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">    MemoryAccess *Current = Start;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">    // This walker pretends uses don't exist. If we're handed one, silently grab</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">    // This walker pretends uses don't exist. If we're handed one, silently grab</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">    // its def. (This has the nice side-effect of ensuring we never cache uses)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">    // its def. (This has the nice side-effect of ensuring we never cache uses)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">    if (auto *MU = dyn_cast<MemoryUse>(Start))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">    if (auto *MU = dyn_cast<MemoryUse>(Start))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">      Current = MU->getDefiningAccess();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">      Current = MU->getDefiningAccess();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">    DefPath FirstDesc(Q.StartingLoc, Current, Current, std::nullopt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">    DefPath FirstDesc(Q.StartingLoc, Current, Current, std::nullopt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">    // Fast path for the overly-common case (no crazy phi optimization</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">    // Fast path for the overly-common case (no crazy phi optimization</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">    // necessary)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">    // necessary)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">    UpwardsWalkResult WalkResult = walkToPhiOrClobber(FirstDesc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">    UpwardsWalkResult WalkResult = walkToPhiOrClobber(FirstDesc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">    MemoryAccess *Result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">    MemoryAccess *Result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">    if (WalkResult.IsKnownClobber) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">    if (WalkResult.IsKnownClobber) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">      Result = WalkResult.Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">      Result = WalkResult.Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">      OptznResult OptRes = tryOptimizePhi(cast<MemoryPhi>(FirstDesc.Last),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">      OptznResult OptRes = tryOptimizePhi(cast<MemoryPhi>(FirstDesc.Last),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">                                          Current, Q.StartingLoc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">                                          Current, Q.StartingLoc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">      verifyOptResult(OptRes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">      verifyOptResult(OptRes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">      resetPhiOptznState();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">      resetPhiOptznState();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">      Result = OptRes.PrimaryClobber.Clobber;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">      Result = OptRes.PrimaryClobber.Clobber;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">    if (!Q.SkipSelfAccess && *UpwardWalkLimit > 0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">    if (!Q.SkipSelfAccess && *UpwardWalkLimit > 0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">      checkClobberSanity(Current, Result, Q.StartingLoc, MSSA, Q, BAA);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">      checkClobberSanity(Current, Result, Q.StartingLoc, MSSA, Q, BAA);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">    return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">    return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">struct RenamePassData {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">struct RenamePassData {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  DomTreeNode *DTN;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  DomTreeNode *DTN;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">  DomTreeNode::const_iterator ChildIt;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">  DomTreeNode::const_iterator ChildIt;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  MemoryAccess *IncomingVal;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  MemoryAccess *IncomingVal;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">  RenamePassData(DomTreeNode *D, DomTreeNode::const_iterator It,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">  RenamePassData(DomTreeNode *D, DomTreeNode::const_iterator It,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">                 MemoryAccess *M)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">                 MemoryAccess *M)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">      : DTN(D), ChildIt(It), IncomingVal(M) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">      : DTN(D), ChildIt(It), IncomingVal(M) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">  void swap(RenamePassData &RHS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">  void swap(RenamePassData &RHS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">    std::swap(DTN, RHS.DTN);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">    std::swap(DTN, RHS.DTN);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">    std::swap(ChildIt, RHS.ChildIt);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">    std::swap(ChildIt, RHS.ChildIt);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">    std::swap(IncomingVal, RHS.IncomingVal);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">    std::swap(IncomingVal, RHS.IncomingVal);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">class MemorySSA::ClobberWalkerBase {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">class MemorySSA::ClobberWalkerBase {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">  ClobberWalker Walker;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">  ClobberWalker Walker;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">  MemorySSA *MSSA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">  MemorySSA *MSSA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">  ClobberWalkerBase(MemorySSA *M, DominatorTree *D) : Walker(*M, *D), MSSA(M) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">  ClobberWalkerBase(MemorySSA *M, DominatorTree *D) : Walker(*M, *D), MSSA(M) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccessBase(MemoryAccess *,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccessBase(MemoryAccess *,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">                                              const MemoryLocation &,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">                                              const MemoryLocation &,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">                                              BatchAAResults &, unsigned &);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">                                              BatchAAResults &, unsigned &);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">  // Third argument (bool), defines whether the clobber search should skip the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">  // Third argument (bool), defines whether the clobber search should skip the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">  // original queried access. If true, there will be a follow-up query searching</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">  // original queried access. If true, there will be a follow-up query searching</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">  // for a clobber access past "self". Note that the Optimized access is not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">  // for a clobber access past "self". Note that the Optimized access is not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  // updated if a new clobber is found by this SkipSelf search. If this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  // updated if a new clobber is found by this SkipSelf search. If this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">  // additional query becomes heavily used we may decide to cache the result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">  // additional query becomes heavily used we may decide to cache the result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">  // Walker instantiations will decide how to set the SkipSelf bool.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">  // Walker instantiations will decide how to set the SkipSelf bool.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccessBase(MemoryAccess *, BatchAAResults &,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccessBase(MemoryAccess *, BatchAAResults &,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">                                              unsigned &, bool,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">                                              unsigned &, bool,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">                                              bool UseInvariantGroup = true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">                                              bool UseInvariantGroup = true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">/// A MemorySSAWalker that does AA walks to disambiguate accesses. It no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">/// A MemorySSAWalker that does AA walks to disambiguate accesses. It no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">/// longer does caching on its own, but the name has been retained for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">/// longer does caching on its own, but the name has been retained for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">/// moment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">/// moment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">class MemorySSA::CachingWalker final : public MemorySSAWalker {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">class MemorySSA::CachingWalker final : public MemorySSAWalker {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">  ClobberWalkerBase *Walker;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">  ClobberWalkerBase *Walker;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">  CachingWalker(MemorySSA *M, ClobberWalkerBase *W)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">  CachingWalker(MemorySSA *M, ClobberWalkerBase *W)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">      : MemorySSAWalker(M), Walker(W) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">      : MemorySSAWalker(M), Walker(W) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">  ~CachingWalker() override = default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">  ~CachingWalker() override = default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">  using MemorySSAWalker::getClobberingMemoryAccess;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">  using MemorySSAWalker::getClobberingMemoryAccess;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, BatchAAResults &BAA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, BatchAAResults &BAA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">                                          unsigned &UWL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">                                          unsigned &UWL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">                                          BatchAAResults &BAA, unsigned &UWL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">                                          BatchAAResults &BAA, unsigned &UWL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">    return Walker->getClobberingMemoryAccessBase(MA, Loc, BAA, UWL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">    return Walker->getClobberingMemoryAccessBase(MA, Loc, BAA, UWL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">  // This method is not accessible outside of this file.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">  // This method is not accessible outside of this file.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccessWithoutInvariantGroup(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccessWithoutInvariantGroup(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">      MemoryAccess *MA, BatchAAResults &BAA, unsigned &UWL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">      MemoryAccess *MA, BatchAAResults &BAA, unsigned &UWL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, false, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, false, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">    return getClobberingMemoryAccess(MA, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">    return getClobberingMemoryAccess(MA, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">    return getClobberingMemoryAccess(MA, Loc, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">    return getClobberingMemoryAccess(MA, Loc, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">  void invalidateInfo(MemoryAccess *MA) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">  void invalidateInfo(MemoryAccess *MA) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">      MUD->resetOptimized();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">      MUD->resetOptimized();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">class MemorySSA::SkipSelfWalker final : public MemorySSAWalker {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">class MemorySSA::SkipSelfWalker final : public MemorySSAWalker {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">  ClobberWalkerBase *Walker;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">  ClobberWalkerBase *Walker;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">  SkipSelfWalker(MemorySSA *M, ClobberWalkerBase *W)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">  SkipSelfWalker(MemorySSA *M, ClobberWalkerBase *W)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">      : MemorySSAWalker(M), Walker(W) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">      : MemorySSAWalker(M), Walker(W) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">  ~SkipSelfWalker() override = default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">  ~SkipSelfWalker() override = default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  using MemorySSAWalker::getClobberingMemoryAccess;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  using MemorySSAWalker::getClobberingMemoryAccess;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, BatchAAResults &BAA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, BatchAAResults &BAA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">                                          unsigned &UWL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">                                          unsigned &UWL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">    return Walker->getClobberingMemoryAccessBase(MA, BAA, UWL, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">                                          BatchAAResults &BAA, unsigned &UWL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">                                          BatchAAResults &BAA, unsigned &UWL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">    return Walker->getClobberingMemoryAccessBase(MA, Loc, BAA, UWL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">    return Walker->getClobberingMemoryAccessBase(MA, Loc, BAA, UWL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">    return getClobberingMemoryAccess(MA, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">    return getClobberingMemoryAccess(MA, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">                                          const MemoryLocation &Loc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">                                          BatchAAResults &BAA) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">    return getClobberingMemoryAccess(MA, Loc, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">    return getClobberingMemoryAccess(MA, Loc, BAA, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">  void invalidateInfo(MemoryAccess *MA) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">  void invalidateInfo(MemoryAccess *MA) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">      MUD->resetOptimized();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">      MUD->resetOptimized();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">void MemorySSA::renameSuccessorPhis(BasicBlock *BB, MemoryAccess *IncomingVal,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">void MemorySSA::renameSuccessorPhis(BasicBlock *BB, MemoryAccess *IncomingVal,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">                                    bool RenameAllUses) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">                                    bool RenameAllUses) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">  // Pass through values to our successors</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">  // Pass through values to our successors</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">  for (const BasicBlock *S : successors(BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">  for (const BasicBlock *S : successors(BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">    auto It = PerBlockAccesses.find(S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">    auto It = PerBlockAccesses.find(S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">    // Rename the phi nodes in our successor block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">    // Rename the phi nodes in our successor block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">    if (It == PerBlockAccesses.end() || !isa<MemoryPhi>(It->second->front()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">    if (It == PerBlockAccesses.end() || !isa<MemoryPhi>(It->second->front()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">    AccessList *Accesses = It->second.get();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">    AccessList *Accesses = It->second.get();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">    auto *Phi = cast<MemoryPhi>(&Accesses->front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">    auto *Phi = cast<MemoryPhi>(&Accesses->front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">    if (RenameAllUses) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">    if (RenameAllUses) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">      bool ReplacementDone = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">      bool ReplacementDone = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">      for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">      for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">        if (Phi->getIncomingBlock(I) == BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">        if (Phi->getIncomingBlock(I) == BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">          Phi->setIncomingValue(I, IncomingVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">          Phi->setIncomingValue(I, IncomingVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">          ReplacementDone = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">          ReplacementDone = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">      (void) ReplacementDone;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">      (void) ReplacementDone;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">      assert(ReplacementDone && "Incomplete phi during partial rename");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">      assert(ReplacementDone && "Incomplete phi during partial rename");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">      Phi->addIncoming(IncomingVal, BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">      Phi->addIncoming(IncomingVal, BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">/// Rename a single basic block into MemorySSA form.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">/// Rename a single basic block into MemorySSA form.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">/// Uses the standard SSA renaming algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">/// Uses the standard SSA renaming algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">/// \returns The new incoming value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">/// \returns The new incoming value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">MemoryAccess *MemorySSA::renameBlock(BasicBlock *BB, MemoryAccess *IncomingVal,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">MemoryAccess *MemorySSA::renameBlock(BasicBlock *BB, MemoryAccess *IncomingVal,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">                                     bool RenameAllUses) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">                                     bool RenameAllUses) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">  auto It = PerBlockAccesses.find(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">  auto It = PerBlockAccesses.find(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">  // Skip most processing if the list is empty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">  // Skip most processing if the list is empty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">  if (It != PerBlockAccesses.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">  if (It != PerBlockAccesses.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">    AccessList *Accesses = It->second.get();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">    AccessList *Accesses = It->second.get();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">    for (MemoryAccess &L : *Accesses) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">    for (MemoryAccess &L : *Accesses) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">      if (MemoryUseOrDef *MUD = dyn_cast<MemoryUseOrDef>(&L)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">      if (MemoryUseOrDef *MUD = dyn_cast<MemoryUseOrDef>(&L)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">        if (MUD->getDefiningAccess() == nullptr || RenameAllUses)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">        if (MUD->getDefiningAccess() == nullptr || RenameAllUses)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">          MUD->setDefiningAccess(IncomingVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">          MUD->setDefiningAccess(IncomingVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">        if (isa<MemoryDef>(&L))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">        if (isa<MemoryDef>(&L))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">          IncomingVal = &L;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">          IncomingVal = &L;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">        IncomingVal = &L;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">        IncomingVal = &L;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">  return IncomingVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">  return IncomingVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">/// This is the standard SSA renaming algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">/// This is the standard SSA renaming algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">/// We walk the dominator tree in preorder, renaming accesses, and then filling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">/// We walk the dominator tree in preorder, renaming accesses, and then filling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">/// in phi nodes in our successors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">/// in phi nodes in our successors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">void MemorySSA::renamePass(DomTreeNode *Root, MemoryAccess *IncomingVal,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">void MemorySSA::renamePass(DomTreeNode *Root, MemoryAccess *IncomingVal,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">                           SmallPtrSetImpl<BasicBlock *> &Visited,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">                           SmallPtrSetImpl<BasicBlock *> &Visited,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">                           bool SkipVisited, bool RenameAllUses) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">                           bool SkipVisited, bool RenameAllUses) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">  assert(Root && "Trying to rename accesses in an unreachable block");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">  assert(Root && "Trying to rename accesses in an unreachable block");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">  SmallVector<RenamePassData, 32> WorkStack;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">  SmallVector<RenamePassData, 32> WorkStack;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">  // Skip everything if we already renamed this block and we are skipping.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">  // Skip everything if we already renamed this block and we are skipping.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">  // Note: You can't sink this into the if, because we need it to occur</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">  // Note: You can't sink this into the if, because we need it to occur</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">  // regardless of whether we skip blocks or not.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">  // regardless of whether we skip blocks or not.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">  bool AlreadyVisited = !Visited.insert(Root->getBlock()).second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">  bool AlreadyVisited = !Visited.insert(Root->getBlock()).second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">  if (SkipVisited && AlreadyVisited)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">  if (SkipVisited && AlreadyVisited)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">  IncomingVal = renameBlock(Root->getBlock(), IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">  IncomingVal = renameBlock(Root->getBlock(), IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">  renameSuccessorPhis(Root->getBlock(), IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">  renameSuccessorPhis(Root->getBlock(), IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">  WorkStack.push_back({Root, Root->begin(), IncomingVal});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">  WorkStack.push_back({Root, Root->begin(), IncomingVal});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  while (!WorkStack.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  while (!WorkStack.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">    DomTreeNode *Node = WorkStack.back().DTN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">    DomTreeNode *Node = WorkStack.back().DTN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">    DomTreeNode::const_iterator ChildIt = WorkStack.back().ChildIt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">    DomTreeNode::const_iterator ChildIt = WorkStack.back().ChildIt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">    IncomingVal = WorkStack.back().IncomingVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">    IncomingVal = WorkStack.back().IncomingVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">    if (ChildIt == Node->end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">    if (ChildIt == Node->end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">      WorkStack.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">      WorkStack.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">      DomTreeNode *Child = *ChildIt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">      DomTreeNode *Child = *ChildIt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">      ++WorkStack.back().ChildIt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">      ++WorkStack.back().ChildIt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">      BasicBlock *BB = Child->getBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">      BasicBlock *BB = Child->getBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">      // Note: You can't sink this into the if, because we need it to occur</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">      // Note: You can't sink this into the if, because we need it to occur</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">      // regardless of whether we skip blocks or not.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">      // regardless of whether we skip blocks or not.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">      AlreadyVisited = !Visited.insert(BB).second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">      AlreadyVisited = !Visited.insert(BB).second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">      if (SkipVisited && AlreadyVisited) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">      if (SkipVisited && AlreadyVisited) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">        // We already visited this during our renaming, which can happen when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">        // We already visited this during our renaming, which can happen when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">        // being asked to rename multiple blocks. Figure out the incoming val,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">        // being asked to rename multiple blocks. Figure out the incoming val,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">        // which is the last def.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">        // which is the last def.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">        // Incoming value can only change if there is a block def, and in that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">        // Incoming value can only change if there is a block def, and in that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">        // case, it's the last block def in the list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">        // case, it's the last block def in the list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">        if (auto *BlockDefs = getWritableBlockDefs(BB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">        if (auto *BlockDefs = getWritableBlockDefs(BB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">          IncomingVal = &*BlockDefs->rbegin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">          IncomingVal = &*BlockDefs->rbegin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">      } else</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">      } else</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">        IncomingVal = renameBlock(BB, IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">        IncomingVal = renameBlock(BB, IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">      renameSuccessorPhis(BB, IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">      renameSuccessorPhis(BB, IncomingVal, RenameAllUses);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">      WorkStack.push_back({Child, Child->begin(), IncomingVal});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">      WorkStack.push_back({Child, Child->begin(), IncomingVal});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">/// This handles unreachable block accesses by deleting phi nodes in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">/// This handles unreachable block accesses by deleting phi nodes in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">/// unreachable blocks, and marking all other unreachable MemoryAccess's as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">/// unreachable blocks, and marking all other unreachable MemoryAccess's as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">/// being uses of the live on entry definition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">/// being uses of the live on entry definition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">void MemorySSA::markUnreachableAsLiveOnEntry(BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">void MemorySSA::markUnreachableAsLiveOnEntry(BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">  assert(!DT->isReachableFromEntry(BB) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">  assert(!DT->isReachableFromEntry(BB) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">         "Reachable block found while handling unreachable blocks");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">         "Reachable block found while handling unreachable blocks");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">  // Make sure phi nodes in our reachable successors end up with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">  // Make sure phi nodes in our reachable successors end up with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">  // LiveOnEntryDef for our incoming edge, even though our block is forward</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">  // LiveOnEntryDef for our incoming edge, even though our block is forward</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">  // unreachable.  We could just disconnect these blocks from the CFG fully,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">  // unreachable.  We could just disconnect these blocks from the CFG fully,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">  // but we do not right now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">  // but we do not right now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">  for (const BasicBlock *S : successors(BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">  for (const BasicBlock *S : successors(BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">    if (!DT->isReachableFromEntry(S))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">    if (!DT->isReachableFromEntry(S))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">    auto It = PerBlockAccesses.find(S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">    auto It = PerBlockAccesses.find(S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">    // Rename the phi nodes in our successor block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">    // Rename the phi nodes in our successor block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">    if (It == PerBlockAccesses.end() || !isa<MemoryPhi>(It->second->front()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">    if (It == PerBlockAccesses.end() || !isa<MemoryPhi>(It->second->front()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">    AccessList *Accesses = It->second.get();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">    AccessList *Accesses = It->second.get();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">    auto *Phi = cast<MemoryPhi>(&Accesses->front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">    auto *Phi = cast<MemoryPhi>(&Accesses->front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">    Phi->addIncoming(LiveOnEntryDef.get(), BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">    Phi->addIncoming(LiveOnEntryDef.get(), BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">  auto It = PerBlockAccesses.find(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">  auto It = PerBlockAccesses.find(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  if (It == PerBlockAccesses.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  if (It == PerBlockAccesses.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">  auto &Accesses = It->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">  auto &Accesses = It->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  for (auto AI = Accesses->begin(), AE = Accesses->end(); AI != AE;) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  for (auto AI = Accesses->begin(), AE = Accesses->end(); AI != AE;) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">    auto Next = std::next(AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">    auto Next = std::next(AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">    // If we have a phi, just remove it. We are going to replace all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">    // If we have a phi, just remove it. We are going to replace all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">    // users with live on entry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">    // users with live on entry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">    if (auto *UseOrDef = dyn_cast<MemoryUseOrDef>(AI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">    if (auto *UseOrDef = dyn_cast<MemoryUseOrDef>(AI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">      UseOrDef->setDefiningAccess(LiveOnEntryDef.get());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">      UseOrDef->setDefiningAccess(LiveOnEntryDef.get());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">      Accesses->erase(AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">      Accesses->erase(AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">    AI = Next;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">    AI = Next;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">MemorySSA::MemorySSA(Function &Func, AliasAnalysis *AA, DominatorTree *DT)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">MemorySSA::MemorySSA(Function &Func, AliasAnalysis *AA, DominatorTree *DT)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">    : DT(DT), F(Func), LiveOnEntryDef(nullptr), Walker(nullptr),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">    : DT(DT), F(Func), LiveOnEntryDef(nullptr), Walker(nullptr),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">      SkipWalker(nullptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">      SkipWalker(nullptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">  // Build MemorySSA using a batch alias analysis. This reuses the internal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">  // Build MemorySSA using a batch alias analysis. This reuses the internal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">  // state that AA collects during an alias()/getModRefInfo() call. This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">  // state that AA collects during an alias()/getModRefInfo() call. This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  // safe because there are no CFG changes while building MemorySSA and can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  // safe because there are no CFG changes while building MemorySSA and can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">  // significantly reduce the time spent by the compiler in AA, because we will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">  // significantly reduce the time spent by the compiler in AA, because we will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  // make queries about all the instructions in the Function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  // make queries about all the instructions in the Function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">  assert(AA && "No alias analysis?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">  assert(AA && "No alias analysis?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">  BatchAAResults BatchAA(*AA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">  BatchAAResults BatchAA(*AA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">  buildMemorySSA(BatchAA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">  buildMemorySSA(BatchAA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  // Intentionally leave AA to nullptr while building so we don't accidently</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  // Intentionally leave AA to nullptr while building so we don't accidently</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">  // use non-batch AliasAnalysis.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">  // use non-batch AliasAnalysis.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">  this->AA = AA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">  this->AA = AA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">  // Also create the walker here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">  // Also create the walker here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">  getWalker();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">  getWalker();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">MemorySSA::~MemorySSA() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">MemorySSA::~MemorySSA() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">  // Drop all our references</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">  // Drop all our references</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">  for (const auto &Pair : PerBlockAccesses)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">  for (const auto &Pair : PerBlockAccesses)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">    for (MemoryAccess &MA : *Pair.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">    for (MemoryAccess &MA : *Pair.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">      MA.dropAllReferences();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">      MA.dropAllReferences();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">MemorySSA::AccessList *MemorySSA::getOrCreateAccessList(const BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">MemorySSA::AccessList *MemorySSA::getOrCreateAccessList(const BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  auto Res = PerBlockAccesses.insert(std::make_pair(BB, nullptr));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  auto Res = PerBlockAccesses.insert(std::make_pair(BB, nullptr));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  if (Res.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  if (Res.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">    Res.first->second = std::make_unique<AccessList>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">    Res.first->second = std::make_unique<AccessList>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  return Res.first->second.get();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  return Res.first->second.get();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">MemorySSA::DefsList *MemorySSA::getOrCreateDefsList(const BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">MemorySSA::DefsList *MemorySSA::getOrCreateDefsList(const BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">  auto Res = PerBlockDefs.insert(std::make_pair(BB, nullptr));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">  auto Res = PerBlockDefs.insert(std::make_pair(BB, nullptr));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">  if (Res.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">  if (Res.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">    Res.first->second = std::make_unique<DefsList>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">    Res.first->second = std::make_unique<DefsList>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">  return Res.first->second.get();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">  return Res.first->second.get();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">/// This class is a batch walker of all MemoryUse's in the program, and points</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">/// This class is a batch walker of all MemoryUse's in the program, and points</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">/// their defining access at the thing that actually clobbers them.  Because it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">/// their defining access at the thing that actually clobbers them.  Because it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">/// is a batch walker that touches everything, it does not operate like the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">/// is a batch walker that touches everything, it does not operate like the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">/// other walkers.  This walker is basically performing a top-down SSA renaming</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">/// other walkers.  This walker is basically performing a top-down SSA renaming</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">/// pass, where the version stack is used as the cache.  This enables it to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">/// pass, where the version stack is used as the cache.  This enables it to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">/// significantly more time and memory efficient than using the regular walker,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">/// significantly more time and memory efficient than using the regular walker,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">/// which is walking bottom-up.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">/// which is walking bottom-up.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">class MemorySSA::OptimizeUses {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">class MemorySSA::OptimizeUses {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">  OptimizeUses(MemorySSA *MSSA, CachingWalker *Walker, BatchAAResults *BAA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">  OptimizeUses(MemorySSA *MSSA, CachingWalker *Walker, BatchAAResults *BAA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">               DominatorTree *DT)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">               DominatorTree *DT)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">      : MSSA(MSSA), Walker(Walker), AA(BAA), DT(DT) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">      : MSSA(MSSA), Walker(Walker), AA(BAA), DT(DT) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">  void optimizeUses();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">  void optimizeUses();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">  /// This represents where a given memorylocation is in the stack.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">  /// This represents where a given memorylocation is in the stack.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">  struct MemlocStackInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">  struct MemlocStackInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">    // This essentially is keeping track of versions of the stack. Whenever</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">    // This essentially is keeping track of versions of the stack. Whenever</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">    // the stack changes due to pushes or pops, these versions increase.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">    // the stack changes due to pushes or pops, these versions increase.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">    unsigned long StackEpoch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">    unsigned long StackEpoch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">    unsigned long PopEpoch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">    unsigned long PopEpoch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">    // This is the lower bound of places on the stack to check. It is equal to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">    // This is the lower bound of places on the stack to check. It is equal to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">    // the place the last stack walk ended.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">    // the place the last stack walk ended.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">    // Note: Correctness depends on this being initialized to 0, which densemap</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">    // Note: Correctness depends on this being initialized to 0, which densemap</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">    // does</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">    // does</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">    unsigned long LowerBound;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">    unsigned long LowerBound;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">    const BasicBlock *LowerBoundBlock;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">    const BasicBlock *LowerBoundBlock;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">    // This is where the last walk for this memory location ended.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">    // This is where the last walk for this memory location ended.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">    unsigned long LastKill;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">    unsigned long LastKill;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">    bool LastKillValid;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">    bool LastKillValid;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">  void optimizeUsesInBlock(const BasicBlock *, unsigned long &, unsigned long &,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">  void optimizeUsesInBlock(const BasicBlock *, unsigned long &, unsigned long &,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">                           SmallVectorImpl<MemoryAccess *> &,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">                           SmallVectorImpl<MemoryAccess *> &,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">                           DenseMap<MemoryLocOrCall, MemlocStackInfo> &);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">                           DenseMap<MemoryLocOrCall, MemlocStackInfo> &);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">  MemorySSA *MSSA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">  MemorySSA *MSSA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">  CachingWalker *Walker;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">  CachingWalker *Walker;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">  BatchAAResults *AA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">  BatchAAResults *AA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  DominatorTree *DT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  DominatorTree *DT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">/// Optimize the uses in a given block This is basically the SSA renaming</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">/// Optimize the uses in a given block This is basically the SSA renaming</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">/// algorithm, with one caveat: We are able to use a single stack for all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">/// algorithm, with one caveat: We are able to use a single stack for all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">/// MemoryUses.  This is because the set of *possible* reaching MemoryDefs is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">/// MemoryUses.  This is because the set of *possible* reaching MemoryDefs is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">/// the same for every MemoryUse.  The *actual* clobbering MemoryDef is just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">/// the same for every MemoryUse.  The *actual* clobbering MemoryDef is just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">/// going to be some position in that stack of possible ones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">/// going to be some position in that stack of possible ones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">/// We track the stack positions that each MemoryLocation needs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">/// We track the stack positions that each MemoryLocation needs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">/// to check, and last ended at.  This is because we only want to check the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">/// to check, and last ended at.  This is because we only want to check the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">/// things that changed since last time.  The same MemoryLocation should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">/// things that changed since last time.  The same MemoryLocation should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">/// get clobbered by the same store (getModRefInfo does not use invariantness or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">/// get clobbered by the same store (getModRefInfo does not use invariantness or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">/// things like this, and if they start, we can modify MemoryLocOrCall to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">/// things like this, and if they start, we can modify MemoryLocOrCall to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">/// include relevant data)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">/// include relevant data)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">void MemorySSA::OptimizeUses::optimizeUsesInBlock(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">void MemorySSA::OptimizeUses::optimizeUsesInBlock(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">    const BasicBlock *BB, unsigned long &StackEpoch, unsigned long &PopEpoch,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">    const BasicBlock *BB, unsigned long &StackEpoch, unsigned long &PopEpoch,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">    SmallVectorImpl<MemoryAccess *> &VersionStack,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">    SmallVectorImpl<MemoryAccess *> &VersionStack,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">    DenseMap<MemoryLocOrCall, MemlocStackInfo> &LocStackInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">    DenseMap<MemoryLocOrCall, MemlocStackInfo> &LocStackInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">  /// If no accesses, nothing to do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">  /// If no accesses, nothing to do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">  MemorySSA::AccessList *Accesses = MSSA->getWritableBlockAccesses(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">  MemorySSA::AccessList *Accesses = MSSA->getWritableBlockAccesses(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">  if (Accesses == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">  if (Accesses == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">  // Pop everything that doesn't dominate the current block off the stack,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">  // Pop everything that doesn't dominate the current block off the stack,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">  // increment the PopEpoch to account for this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">  // increment the PopEpoch to account for this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">  while (true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">  while (true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">    assert(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">    assert(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">        !VersionStack.empty() &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">        !VersionStack.empty() &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">        "Version stack should have liveOnEntry sentinel dominating everything");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">        "Version stack should have liveOnEntry sentinel dominating everything");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">    BasicBlock *BackBlock = VersionStack.back()->getBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">    BasicBlock *BackBlock = VersionStack.back()->getBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">    if (DT->dominates(BackBlock, BB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">    if (DT->dominates(BackBlock, BB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">    while (VersionStack.back()->getBlock() == BackBlock)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">    while (VersionStack.back()->getBlock() == BackBlock)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">      VersionStack.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">      VersionStack.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">    ++PopEpoch;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">    ++PopEpoch;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">  for (MemoryAccess &MA : *Accesses) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">  for (MemoryAccess &MA : *Accesses) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">    auto *MU = dyn_cast<MemoryUse>(&MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">    auto *MU = dyn_cast<MemoryUse>(&MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">    if (!MU) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">    if (!MU) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">      VersionStack.push_back(&MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">      VersionStack.push_back(&MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">      ++StackEpoch;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">      ++StackEpoch;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">    if (MU->isOptimized())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">    if (MU->isOptimized())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">    MemoryLocOrCall UseMLOC(MU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">    MemoryLocOrCall UseMLOC(MU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">    auto &LocInfo = LocStackInfo[UseMLOC];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">    auto &LocInfo = LocStackInfo[UseMLOC];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">    // If the pop epoch changed, it means we've removed stuff from top of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">    // If the pop epoch changed, it means we've removed stuff from top of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">    // stack due to changing blocks. We may have to reset the lower bound or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">    // stack due to changing blocks. We may have to reset the lower bound or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">    // last kill info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">    // last kill info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">    if (LocInfo.PopEpoch != PopEpoch) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">    if (LocInfo.PopEpoch != PopEpoch) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">      LocInfo.PopEpoch = PopEpoch;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">      LocInfo.PopEpoch = PopEpoch;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">      LocInfo.StackEpoch = StackEpoch;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">      LocInfo.StackEpoch = StackEpoch;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">      // If the lower bound was in something that no longer dominates us, we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">      // If the lower bound was in something that no longer dominates us, we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">      // have to reset it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">      // have to reset it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">      // We can't simply track stack size, because the stack may have had</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">      // We can't simply track stack size, because the stack may have had</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">      // pushes/pops in the meantime.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">      // pushes/pops in the meantime.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">      // XXX: This is non-optimal, but only is slower cases with heavily</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">      // XXX: This is non-optimal, but only is slower cases with heavily</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">      // branching dominator trees.  To get the optimal number of queries would</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">      // branching dominator trees.  To get the optimal number of queries would</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">      // be to make lowerbound and lastkill a per-loc stack, and pop it until</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">      // be to make lowerbound and lastkill a per-loc stack, and pop it until</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">      // the top of that stack dominates us.  This does not seem worth it ATM.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">      // the top of that stack dominates us.  This does not seem worth it ATM.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">      // A much cheaper optimization would be to always explore the deepest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">      // A much cheaper optimization would be to always explore the deepest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">      // branch of the dominator tree first. This will guarantee this resets on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">      // branch of the dominator tree first. This will guarantee this resets on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">      // the smallest set of blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">      // the smallest set of blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">      if (LocInfo.LowerBoundBlock && LocInfo.LowerBoundBlock != BB &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">      if (LocInfo.LowerBoundBlock && LocInfo.LowerBoundBlock != BB &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">          !DT->dominates(LocInfo.LowerBoundBlock, BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">          !DT->dominates(LocInfo.LowerBoundBlock, BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">        // Reset the lower bound of things to check.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">        // Reset the lower bound of things to check.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">        // TODO: Some day we should be able to reset to last kill, rather than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">        // TODO: Some day we should be able to reset to last kill, rather than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">        // 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">        // 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">        LocInfo.LowerBound = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">        LocInfo.LowerBound = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">        LocInfo.LowerBoundBlock = VersionStack[0]->getBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">        LocInfo.LowerBoundBlock = VersionStack[0]->getBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">        LocInfo.LastKillValid = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">        LocInfo.LastKillValid = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">    } else if (LocInfo.StackEpoch != StackEpoch) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">    } else if (LocInfo.StackEpoch != StackEpoch) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">      // If all that has changed is the StackEpoch, we only have to check the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">      // If all that has changed is the StackEpoch, we only have to check the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">      // new things on the stack, because we've checked everything before.  In</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">      // new things on the stack, because we've checked everything before.  In</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">      // this case, the lower bound of things to check remains the same.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">      // this case, the lower bound of things to check remains the same.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">      LocInfo.PopEpoch = PopEpoch;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">      LocInfo.PopEpoch = PopEpoch;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">      LocInfo.StackEpoch = StackEpoch;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">      LocInfo.StackEpoch = StackEpoch;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">    if (!LocInfo.LastKillValid) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">    if (!LocInfo.LastKillValid) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">      LocInfo.LastKill = VersionStack.size() - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">      LocInfo.LastKill = VersionStack.size() - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">      LocInfo.LastKillValid = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">      LocInfo.LastKillValid = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">    // At this point, we should have corrected last kill and LowerBound to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">    // At this point, we should have corrected last kill and LowerBound to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">    // in bounds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">    // in bounds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">    assert(LocInfo.LowerBound < VersionStack.size() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">    assert(LocInfo.LowerBound < VersionStack.size() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">           "Lower bound out of range");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">           "Lower bound out of range");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">    assert(LocInfo.LastKill < VersionStack.size() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">    assert(LocInfo.LastKill < VersionStack.size() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">           "Last kill info out of range");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">           "Last kill info out of range");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">    // In any case, the new upper bound is the top of the stack.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">    // In any case, the new upper bound is the top of the stack.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">    unsigned long UpperBound = VersionStack.size() - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">    unsigned long UpperBound = VersionStack.size() - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">    if (UpperBound - LocInfo.LowerBound > MaxCheckLimit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">    if (UpperBound - LocInfo.LowerBound > MaxCheckLimit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "MemorySSA skipping optimization of " << *MU << " ("</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "MemorySSA skipping optimization of " << *MU << " ("</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">                        << *(MU->getMemoryInst()) << ")"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">                        << *(MU->getMemoryInst()) << ")"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">                        << " because there are "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">                        << " because there are "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">                        << UpperBound - LocInfo.LowerBound</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">                        << UpperBound - LocInfo.LowerBound</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">                        << " stores to disambiguate\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">                        << " stores to disambiguate\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">      // Because we did not walk, LastKill is no longer valid, as this may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">      // Because we did not walk, LastKill is no longer valid, as this may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">      // have been a kill.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">      // have been a kill.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">      LocInfo.LastKillValid = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">      LocInfo.LastKillValid = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">    bool FoundClobberResult = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">    bool FoundClobberResult = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">    unsigned UpwardWalkLimit = MaxCheckLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">    while (UpperBound > LocInfo.LowerBound) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">    while (UpperBound > LocInfo.LowerBound) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">      if (isa<MemoryPhi>(VersionStack[UpperBound])) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">      if (isa<MemoryPhi>(VersionStack[UpperBound])) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">        // For phis, use the walker, see where we ended up, go there.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">        // For phis, use the walker, see where we ended up, go there.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">        // The invariant.group handling in MemorySSA is ad-hoc and doesn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">        // The invariant.group handling in MemorySSA is ad-hoc and doesn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">        // support updates, so don't use it to optimize uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">        // support updates, so don't use it to optimize uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">        MemoryAccess *Result =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">        MemoryAccess *Result =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">            Walker->getClobberingMemoryAccessWithoutInvariantGroup(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">            Walker->getClobberingMemoryAccessWithoutInvariantGroup(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">                MU, *AA, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">                MU, *AA, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">        // We are guaranteed to find it or something is wrong.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">        // We are guaranteed to find it or something is wrong.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">        while (VersionStack[UpperBound] != Result) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">        while (VersionStack[UpperBound] != Result) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">          assert(UpperBound != 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">          assert(UpperBound != 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">          --UpperBound;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">          --UpperBound;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">        FoundClobberResult = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">        FoundClobberResult = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">      MemoryDef *MD = cast<MemoryDef>(VersionStack[UpperBound]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">      MemoryDef *MD = cast<MemoryDef>(VersionStack[UpperBound]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">      if (instructionClobbersQuery(MD, MU, UseMLOC, *AA)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">      if (instructionClobbersQuery(MD, MU, UseMLOC, *AA)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">        FoundClobberResult = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">        FoundClobberResult = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">      --UpperBound;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">      --UpperBound;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">    // At the end of this loop, UpperBound is either a clobber, or lower bound</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">    // At the end of this loop, UpperBound is either a clobber, or lower bound</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">    // PHI walking may cause it to be < LowerBound, and in fact, < LastKill.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">    // PHI walking may cause it to be < LowerBound, and in fact, < LastKill.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">    if (FoundClobberResult || UpperBound < LocInfo.LastKill) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">    if (FoundClobberResult || UpperBound < LocInfo.LastKill) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">      MU->setDefiningAccess(VersionStack[UpperBound], true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">      MU->setDefiningAccess(VersionStack[UpperBound], true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">      LocInfo.LastKill = UpperBound;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">      LocInfo.LastKill = UpperBound;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">      // Otherwise, we checked all the new ones, and now we know we can get to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">      // Otherwise, we checked all the new ones, and now we know we can get to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">      // LastKill.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">      // LastKill.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">      MU->setDefiningAccess(VersionStack[LocInfo.LastKill], true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">      MU->setDefiningAccess(VersionStack[LocInfo.LastKill], true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">    LocInfo.LowerBound = VersionStack.size() - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">    LocInfo.LowerBound = VersionStack.size() - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">    LocInfo.LowerBoundBlock = BB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">    LocInfo.LowerBoundBlock = BB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">/// Optimize uses to point to their actual clobbering definitions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">/// Optimize uses to point to their actual clobbering definitions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">void MemorySSA::OptimizeUses::optimizeUses() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">void MemorySSA::OptimizeUses::optimizeUses() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">  SmallVector<MemoryAccess *, 16> VersionStack;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">  SmallVector<MemoryAccess *, 16> VersionStack;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">  DenseMap<MemoryLocOrCall, MemlocStackInfo> LocStackInfo;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">  DenseMap<MemoryLocOrCall, MemlocStackInfo> LocStackInfo;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">  VersionStack.push_back(MSSA->getLiveOnEntryDef());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">  VersionStack.push_back(MSSA->getLiveOnEntryDef());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">  unsigned long StackEpoch = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">  unsigned long StackEpoch = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">  unsigned long PopEpoch = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">  unsigned long PopEpoch = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">  // We perform a non-recursive top-down dominator tree walk.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">  // We perform a non-recursive top-down dominator tree walk.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">  for (const auto *DomNode : depth_first(DT->getRootNode()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">  for (const auto *DomNode : depth_first(DT->getRootNode()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">    optimizeUsesInBlock(DomNode->getBlock(), StackEpoch, PopEpoch, VersionStack,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">    optimizeUsesInBlock(DomNode->getBlock(), StackEpoch, PopEpoch, VersionStack,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">                        LocStackInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">                        LocStackInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">void MemorySSA::placePHINodes(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">void MemorySSA::placePHINodes(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">    const SmallPtrSetImpl<BasicBlock *> &DefiningBlocks) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">    const SmallPtrSetImpl<BasicBlock *> &DefiningBlocks) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">  // Determine where our MemoryPhi's should go</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">  // Determine where our MemoryPhi's should go</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">  ForwardIDFCalculator IDFs(*DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">  ForwardIDFCalculator IDFs(*DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">  IDFs.setDefiningBlocks(DefiningBlocks);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">  IDFs.setDefiningBlocks(DefiningBlocks);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">  SmallVector<BasicBlock *, 32> IDFBlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">  SmallVector<BasicBlock *, 32> IDFBlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">  IDFs.calculate(IDFBlocks);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">  IDFs.calculate(IDFBlocks);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">  // Now place MemoryPhi nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">  // Now place MemoryPhi nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">  for (auto &BB : IDFBlocks)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">  for (auto &BB : IDFBlocks)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">    createMemoryPhi(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">    createMemoryPhi(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">void MemorySSA::buildMemorySSA(BatchAAResults &BAA) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">void MemorySSA::buildMemorySSA(BatchAAResults &BAA) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">  // We create an access to represent "live on entry", for things like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">  // We create an access to represent "live on entry", for things like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">  // arguments or users of globals, where the memory they use is defined before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">  // arguments or users of globals, where the memory they use is defined before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  // the beginning of the function. We do not actually insert it into the IR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  // the beginning of the function. We do not actually insert it into the IR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">  // We do not define a live on exit for the immediate uses, and thus our</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">  // We do not define a live on exit for the immediate uses, and thus our</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">  // semantics do *not* imply that something with no immediate uses can simply</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">  // semantics do *not* imply that something with no immediate uses can simply</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">  // be removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">  // be removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">  BasicBlock &StartingPoint = F.getEntryBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">  BasicBlock &StartingPoint = F.getEntryBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">  LiveOnEntryDef.reset(new MemoryDef(F.getContext(), nullptr, nullptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">  LiveOnEntryDef.reset(new MemoryDef(F.getContext(), nullptr, nullptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">                                     &StartingPoint, NextID++));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">                                     &StartingPoint, NextID++));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">  // We maintain lists of memory accesses per-block, trading memory for time. We</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">  // We maintain lists of memory accesses per-block, trading memory for time. We</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">  // could just look up the memory access for every possible instruction in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">  // could just look up the memory access for every possible instruction in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">  // stream.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">  // stream.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">  SmallPtrSet<BasicBlock *, 32> DefiningBlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">  SmallPtrSet<BasicBlock *, 32> DefiningBlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">  // Go through each block, figure out where defs occur, and chain together all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">  // Go through each block, figure out where defs occur, and chain together all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">  // the accesses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">  // the accesses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">    bool InsertIntoDef = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">    bool InsertIntoDef = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">    AccessList *Accesses = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">    AccessList *Accesses = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">    DefsList *Defs = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">    DefsList *Defs = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">    for (Instruction &I : B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">    for (Instruction &I : B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">      MemoryUseOrDef *MUD = createNewAccess(&I, &BAA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">      MemoryUseOrDef *MUD = createNewAccess(&I, &BAA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">      if (!MUD)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">      if (!MUD)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">      if (!Accesses)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">      if (!Accesses)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">        Accesses = getOrCreateAccessList(&B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">        Accesses = getOrCreateAccessList(&B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">      Accesses->push_back(MUD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">      Accesses->push_back(MUD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">      if (isa<MemoryDef>(MUD)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">      if (isa<MemoryDef>(MUD)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">        InsertIntoDef = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">        InsertIntoDef = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">        if (!Defs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">        if (!Defs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">          Defs = getOrCreateDefsList(&B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">          Defs = getOrCreateDefsList(&B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">        Defs->push_back(*MUD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">        Defs->push_back(*MUD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">    if (InsertIntoDef)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">    if (InsertIntoDef)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">      DefiningBlocks.insert(&B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">      DefiningBlocks.insert(&B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">  placePHINodes(DefiningBlocks);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">  placePHINodes(DefiningBlocks);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">  // Now do regular SSA renaming on the MemoryDef/MemoryUse. Visited will get</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">  // Now do regular SSA renaming on the MemoryDef/MemoryUse. Visited will get</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">  // filled in with all blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">  // filled in with all blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">  SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">  SmallPtrSet<BasicBlock *, 16> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">  renamePass(DT->getRootNode(), LiveOnEntryDef.get(), Visited);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">  renamePass(DT->getRootNode(), LiveOnEntryDef.get(), Visited);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">  // Mark the uses in unreachable blocks as live on entry, so that they go</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">  // Mark the uses in unreachable blocks as live on entry, so that they go</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">  // somewhere.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">  // somewhere.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">  for (auto &BB : F)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">  for (auto &BB : F)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">    if (!Visited.count(&BB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">    if (!Visited.count(&BB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">      markUnreachableAsLiveOnEntry(&BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">      markUnreachableAsLiveOnEntry(&BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">MemorySSAWalker *MemorySSA::getWalker() { return getWalkerImpl(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">MemorySSAWalker *MemorySSA::getWalker() { return getWalkerImpl(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">MemorySSA::CachingWalker *MemorySSA::getWalkerImpl() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">MemorySSA::CachingWalker *MemorySSA::getWalkerImpl() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">  if (Walker)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">  if (Walker)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">    return Walker.get();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">    return Walker.get();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">  if (!WalkerBase)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">  if (!WalkerBase)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">    WalkerBase = std::make_unique<ClobberWalkerBase>(this, DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">    WalkerBase = std::make_unique<ClobberWalkerBase>(this, DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">  Walker = std::make_unique<CachingWalker>(this, WalkerBase.get());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">  Walker = std::make_unique<CachingWalker>(this, WalkerBase.get());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">  return Walker.get();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">  return Walker.get();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">MemorySSAWalker *MemorySSA::getSkipSelfWalker() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">MemorySSAWalker *MemorySSA::getSkipSelfWalker() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">  if (SkipWalker)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">  if (SkipWalker)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">    return SkipWalker.get();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">    return SkipWalker.get();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">  if (!WalkerBase)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">  if (!WalkerBase)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">    WalkerBase = std::make_unique<ClobberWalkerBase>(this, DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">    WalkerBase = std::make_unique<ClobberWalkerBase>(this, DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">  SkipWalker = std::make_unique<SkipSelfWalker>(this, WalkerBase.get());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">  SkipWalker = std::make_unique<SkipSelfWalker>(this, WalkerBase.get());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">  return SkipWalker.get();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">  return SkipWalker.get();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine"> }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine"> }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">// This is a helper function used by the creation routines. It places NewAccess</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">// This is a helper function used by the creation routines. It places NewAccess</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">// into the access and defs lists for a given basic block, at the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">// into the access and defs lists for a given basic block, at the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">// insertion point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">// insertion point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">void MemorySSA::insertIntoListsForBlock(MemoryAccess *NewAccess,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">void MemorySSA::insertIntoListsForBlock(MemoryAccess *NewAccess,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">                                        const BasicBlock *BB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">                                        const BasicBlock *BB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">                                        InsertionPlace Point) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">                                        InsertionPlace Point) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">  auto *Accesses = getOrCreateAccessList(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">  auto *Accesses = getOrCreateAccessList(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">  if (Point == Beginning) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">  if (Point == Beginning) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">    // If it's a phi node, it goes first, otherwise, it goes after any phi</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">    // If it's a phi node, it goes first, otherwise, it goes after any phi</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">    // nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">    // nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">    if (isa<MemoryPhi>(NewAccess)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">    if (isa<MemoryPhi>(NewAccess)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">      Accesses->push_front(NewAccess);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">      Accesses->push_front(NewAccess);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">      auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">      auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">      Defs->push_front(*NewAccess);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">      Defs->push_front(*NewAccess);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">      auto AI = find_if_not(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">      auto AI = find_if_not(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">          *Accesses, [](const MemoryAccess &MA) { return isa<MemoryPhi>(MA); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">          *Accesses, [](const MemoryAccess &MA) { return isa<MemoryPhi>(MA); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">      Accesses->insert(AI, NewAccess);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">      Accesses->insert(AI, NewAccess);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">      if (!isa<MemoryUse>(NewAccess)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">      if (!isa<MemoryUse>(NewAccess)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">        auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">        auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">        auto DI = find_if_not(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">        auto DI = find_if_not(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">            *Defs, [](const MemoryAccess &MA) { return isa<MemoryPhi>(MA); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">            *Defs, [](const MemoryAccess &MA) { return isa<MemoryPhi>(MA); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">        Defs->insert(DI, *NewAccess);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">        Defs->insert(DI, *NewAccess);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">    Accesses->push_back(NewAccess);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">    Accesses->push_back(NewAccess);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">    if (!isa<MemoryUse>(NewAccess)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">    if (!isa<MemoryUse>(NewAccess)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">      auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">      auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">      Defs->push_back(*NewAccess);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">      Defs->push_back(*NewAccess);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">  BlockNumberingValid.erase(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">  BlockNumberingValid.erase(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">void MemorySSA::insertIntoListsBefore(MemoryAccess *What, const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">void MemorySSA::insertIntoListsBefore(MemoryAccess *What, const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">                                      AccessList::iterator InsertPt) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">                                      AccessList::iterator InsertPt) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">  auto *Accesses = getWritableBlockAccesses(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">  auto *Accesses = getWritableBlockAccesses(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">  bool WasEnd = InsertPt == Accesses->end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">  bool WasEnd = InsertPt == Accesses->end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">  Accesses->insert(AccessList::iterator(InsertPt), What);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">  Accesses->insert(AccessList::iterator(InsertPt), What);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">  if (!isa<MemoryUse>(What)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">  if (!isa<MemoryUse>(What)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">    auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">    auto *Defs = getOrCreateDefsList(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">    // If we got asked to insert at the end, we have an easy job, just shove it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">    // If we got asked to insert at the end, we have an easy job, just shove it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">    // at the end. If we got asked to insert before an existing def, we also get</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">    // at the end. If we got asked to insert before an existing def, we also get</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">    // an iterator. If we got asked to insert before a use, we have to hunt for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">    // an iterator. If we got asked to insert before a use, we have to hunt for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">    // the next def.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">    // the next def.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">    if (WasEnd) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">    if (WasEnd) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">      Defs->push_back(*What);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">      Defs->push_back(*What);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">    } else if (isa<MemoryDef>(InsertPt)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">    } else if (isa<MemoryDef>(InsertPt)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">      Defs->insert(InsertPt->getDefsIterator(), *What);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">      Defs->insert(InsertPt->getDefsIterator(), *What);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">      while (InsertPt != Accesses->end() && !isa<MemoryDef>(InsertPt))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">      while (InsertPt != Accesses->end() && !isa<MemoryDef>(InsertPt))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">        ++InsertPt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">        ++InsertPt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">      // Either we found a def, or we are inserting at the end</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">      // Either we found a def, or we are inserting at the end</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">      if (InsertPt == Accesses->end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">      if (InsertPt == Accesses->end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">        Defs->push_back(*What);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">        Defs->push_back(*What);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">        Defs->insert(InsertPt->getDefsIterator(), *What);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">        Defs->insert(InsertPt->getDefsIterator(), *What);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">  BlockNumberingValid.erase(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">  BlockNumberingValid.erase(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">void MemorySSA::prepareForMoveTo(MemoryAccess *What, BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">void MemorySSA::prepareForMoveTo(MemoryAccess *What, BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">  // Keep it in the lookup tables, remove from the lists</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">  // Keep it in the lookup tables, remove from the lists</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">  removeFromLists(What, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">  removeFromLists(What, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">  // Note that moving should implicitly invalidate the optimized state of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">  // Note that moving should implicitly invalidate the optimized state of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">  // MemoryUse (and Phis can't be optimized). However, it doesn't do so for a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">  // MemoryUse (and Phis can't be optimized). However, it doesn't do so for a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">  // MemoryDef.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">  // MemoryDef.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">  if (auto *MD = dyn_cast<MemoryDef>(What))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">  if (auto *MD = dyn_cast<MemoryDef>(What))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">    MD->resetOptimized();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">    MD->resetOptimized();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">  What->setBlock(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">  What->setBlock(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">// Move What before Where in the IR.  The end result is that What will belong to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">// Move What before Where in the IR.  The end result is that What will belong to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">// the right lists and have the right Block set, but will not otherwise be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">// the right lists and have the right Block set, but will not otherwise be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">// correct. It will not have the right defining access, and if it is a def,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">// correct. It will not have the right defining access, and if it is a def,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">// things below it will not properly be updated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">// things below it will not properly be updated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">void MemorySSA::moveTo(MemoryUseOrDef *What, BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">void MemorySSA::moveTo(MemoryUseOrDef *What, BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">                       AccessList::iterator Where) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">                       AccessList::iterator Where) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">  prepareForMoveTo(What, BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">  prepareForMoveTo(What, BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">  insertIntoListsBefore(What, BB, Where);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">  insertIntoListsBefore(What, BB, Where);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">void MemorySSA::moveTo(MemoryAccess *What, BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">void MemorySSA::moveTo(MemoryAccess *What, BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">                       InsertionPlace Point) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">                       InsertionPlace Point) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">  if (isa<MemoryPhi>(What)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">  if (isa<MemoryPhi>(What)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">    assert(Point == Beginning &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">    assert(Point == Beginning &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">           "Can only move a Phi at the beginning of the block");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">           "Can only move a Phi at the beginning of the block");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">    // Update lookup table entry</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">    // Update lookup table entry</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">    ValueToMemoryAccess.erase(What->getBlock());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">    ValueToMemoryAccess.erase(What->getBlock());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">    bool Inserted = ValueToMemoryAccess.insert({BB, What}).second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">    bool Inserted = ValueToMemoryAccess.insert({BB, What}).second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">    (void)Inserted;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">    (void)Inserted;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">    assert(Inserted && "Cannot move a Phi to a block that already has one");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">    assert(Inserted && "Cannot move a Phi to a block that already has one");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">  prepareForMoveTo(What, BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">  prepareForMoveTo(What, BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">  insertIntoListsForBlock(What, BB, Point);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">  insertIntoListsForBlock(What, BB, Point);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">MemoryPhi *MemorySSA::createMemoryPhi(BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">MemoryPhi *MemorySSA::createMemoryPhi(BasicBlock *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">  assert(!getMemoryAccess(BB) && "MemoryPhi already exists for this BB");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">  assert(!getMemoryAccess(BB) && "MemoryPhi already exists for this BB");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">  MemoryPhi *Phi = new MemoryPhi(BB->getContext(), BB, NextID++);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">  MemoryPhi *Phi = new MemoryPhi(BB->getContext(), BB, NextID++);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">  // Phi's always are placed at the front of the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">  // Phi's always are placed at the front of the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">  insertIntoListsForBlock(Phi, BB, Beginning);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">  insertIntoListsForBlock(Phi, BB, Beginning);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">  ValueToMemoryAccess[BB] = Phi;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">  ValueToMemoryAccess[BB] = Phi;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">  return Phi;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">  return Phi;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">MemoryUseOrDef *MemorySSA::createDefinedAccess(Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">MemoryUseOrDef *MemorySSA::createDefinedAccess(Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">                                               MemoryAccess *Definition,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">                                               MemoryAccess *Definition,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">                                               const MemoryUseOrDef *Template,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">                                               const MemoryUseOrDef *Template,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">                                               bool CreationMustSucceed) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">                                               bool CreationMustSucceed) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">  assert(!isa<PHINode>(I) && "Cannot create a defined access for a PHI");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">  assert(!isa<PHINode>(I) && "Cannot create a defined access for a PHI");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">  MemoryUseOrDef *NewAccess = createNewAccess(I, AA, Template);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">  MemoryUseOrDef *NewAccess = createNewAccess(I, AA, Template);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">  if (CreationMustSucceed)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">  if (CreationMustSucceed)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">    assert(NewAccess != nullptr && "Tried to create a memory access for a "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">    assert(NewAccess != nullptr && "Tried to create a memory access for a "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">                                   "non-memory touching instruction");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">                                   "non-memory touching instruction");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">  if (NewAccess) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">  if (NewAccess) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">    assert((!Definition || !isa<MemoryUse>(Definition)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">    assert((!Definition || !isa<MemoryUse>(Definition)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">           "A use cannot be a defining access");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">           "A use cannot be a defining access");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">    NewAccess->setDefiningAccess(Definition);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">    NewAccess->setDefiningAccess(Definition);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">  return NewAccess;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">  return NewAccess;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">// Return true if the instruction has ordering constraints.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">// Return true if the instruction has ordering constraints.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">// Note specifically that this only considers stores and loads</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">// Note specifically that this only considers stores and loads</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">// because others are still considered ModRef by getModRefInfo.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">// because others are still considered ModRef by getModRefInfo.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">static inline bool isOrdered(const Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">static inline bool isOrdered(const Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">  if (auto *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">  if (auto *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">    if (!SI->isUnordered())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">    if (!SI->isUnordered())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">  } else if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">  } else if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">    if (!LI->isUnordered())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">    if (!LI->isUnordered())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">/// Helper function to create new memory accesses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">/// Helper function to create new memory accesses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">template <typename AliasAnalysisType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">template <typename AliasAnalysisType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">MemoryUseOrDef *MemorySSA::createNewAccess(Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">MemoryUseOrDef *MemorySSA::createNewAccess(Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">                                           AliasAnalysisType *AAP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">                                           AliasAnalysisType *AAP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">                                           const MemoryUseOrDef *Template) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">                                           const MemoryUseOrDef *Template) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">  // The assume intrinsic has a control dependency which we model by claiming</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">  // The assume intrinsic has a control dependency which we model by claiming</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">  // that it writes arbitrarily. Debuginfo intrinsics may be considered</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">  // that it writes arbitrarily. Debuginfo intrinsics may be considered</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">  // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">  // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">  // dependencies here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">  // dependencies here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">  // FIXME: Replace this special casing with a more accurate modelling of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">  // FIXME: Replace this special casing with a more accurate modelling of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">  // assume's control dependency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">  // assume's control dependency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">  if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">  if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">    switch (II->getIntrinsicID()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">    case Intrinsic::assume:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">    case Intrinsic::assume:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">    case Intrinsic::experimental_noalias_scope_decl:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">    case Intrinsic::experimental_noalias_scope_decl:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">    case Intrinsic::pseudoprobe:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">    case Intrinsic::pseudoprobe:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">  // Using a nonstandard AA pipelines might leave us with unexpected modref</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">  // Using a nonstandard AA pipelines might leave us with unexpected modref</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">  // results for I, so add a check to not model instructions that may not read</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">  // results for I, so add a check to not model instructions that may not read</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">  // from or write to memory. This is necessary for correctness.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">  // from or write to memory. This is necessary for correctness.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">  if (!I->mayReadFromMemory() && !I->mayWriteToMemory())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">  if (!I->mayReadFromMemory() && !I->mayWriteToMemory())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">  bool Def, Use;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">  bool Def, Use;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">  if (Template) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">  if (Template) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">    Def = isa<MemoryDef>(Template);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">    Def = isa<MemoryDef>(Template);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">    Use = isa<MemoryUse>(Template);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">    Use = isa<MemoryUse>(Template);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">#if !defined(NDEBUG)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">#if !defined(NDEBUG)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">    ModRefInfo ModRef = AAP->getModRefInfo(I, std::nullopt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">    ModRefInfo ModRef = AAP->getModRefInfo(I, std::nullopt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">    bool DefCheck, UseCheck;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">    bool DefCheck, UseCheck;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">    DefCheck = isModSet(ModRef) || isOrdered(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">    DefCheck = isModSet(ModRef) || isOrdered(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">    UseCheck = isRefSet(ModRef);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">    UseCheck = isRefSet(ModRef);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">    // Memory accesses should only be reduced and can not be increased since AA</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">    // Memory accesses should only be reduced and can not be increased since AA</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">    // just might return better results as a result of some transformations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">    // just might return better results as a result of some transformations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">    assert((Def == DefCheck || !DefCheck) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">    assert((Def == DefCheck || !DefCheck) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">           "Memory accesses should only be reduced");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">           "Memory accesses should only be reduced");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">    if (!Def && Use != UseCheck) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">    if (!Def && Use != UseCheck) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">      // New Access should not have more power than template access</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">      // New Access should not have more power than template access</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">      assert(!UseCheck && "Invalid template");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">      assert(!UseCheck && "Invalid template");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">    // Find out what affect this instruction has on memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">    // Find out what affect this instruction has on memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">    ModRefInfo ModRef = AAP->getModRefInfo(I, std::nullopt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">    ModRefInfo ModRef = AAP->getModRefInfo(I, std::nullopt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">    // The isOrdered check is used to ensure that volatiles end up as defs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">    // The isOrdered check is used to ensure that volatiles end up as defs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">    // (atomics end up as ModRef right now anyway).  Until we separate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">    // (atomics end up as ModRef right now anyway).  Until we separate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">    // ordering chain from the memory chain, this enables people to see at least</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">    // ordering chain from the memory chain, this enables people to see at least</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">    // some relative ordering to volatiles.  Note that getClobberingMemoryAccess</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">    // some relative ordering to volatiles.  Note that getClobberingMemoryAccess</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">    // will still give an answer that bypasses other volatile loads.  TODO:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">    // will still give an answer that bypasses other volatile loads.  TODO:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">    // Separate memory aliasing and ordering into two different chains so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">    // Separate memory aliasing and ordering into two different chains so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">    // we can precisely represent both "what memory will this read/write/is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">    // we can precisely represent both "what memory will this read/write/is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">    // clobbered by" and "what instructions can I move this past".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">    // clobbered by" and "what instructions can I move this past".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">    Def = isModSet(ModRef) || isOrdered(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">    Def = isModSet(ModRef) || isOrdered(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">    Use = isRefSet(ModRef);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">    Use = isRefSet(ModRef);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">  // It's possible for an instruction to not modify memory at all. During</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">  // It's possible for an instruction to not modify memory at all. During</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">  // construction, we ignore them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">  // construction, we ignore them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">  if (!Def && !Use)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">  if (!Def && !Use)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">  MemoryUseOrDef *MUD;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">  MemoryUseOrDef *MUD;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">  if (Def) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">  if (Def) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">    MUD = new MemoryDef(I->getContext(), nullptr, I, I->getParent(), NextID++);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">    MUD = new MemoryDef(I->getContext(), nullptr, I, I->getParent(), NextID++);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">    MUD = new MemoryUse(I->getContext(), nullptr, I, I->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">    MUD = new MemoryUse(I->getContext(), nullptr, I, I->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">    if (isUseTriviallyOptimizableToLiveOnEntry(*AAP, I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">    if (isUseTriviallyOptimizableToLiveOnEntry(*AAP, I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">      MemoryAccess *LiveOnEntry = getLiveOnEntryDef();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">      MemoryAccess *LiveOnEntry = getLiveOnEntryDef();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">      MUD->setOptimized(LiveOnEntry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">      MUD->setOptimized(LiveOnEntry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">  ValueToMemoryAccess[I] = MUD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">  ValueToMemoryAccess[I] = MUD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">  return MUD;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">  return MUD;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">/// Properly remove \p MA from all of MemorySSA's lookup tables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">/// Properly remove \p MA from all of MemorySSA's lookup tables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">void MemorySSA::removeFromLookups(MemoryAccess *MA) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">void MemorySSA::removeFromLookups(MemoryAccess *MA) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">  assert(MA->use_empty() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">  assert(MA->use_empty() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">         "Trying to remove memory access that still has uses");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">         "Trying to remove memory access that still has uses");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">  BlockNumbering.erase(MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">  BlockNumbering.erase(MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">  if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">  if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">    MUD->setDefiningAccess(nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">    MUD->setDefiningAccess(nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">  // Invalidate our walker's cache if necessary</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">  // Invalidate our walker's cache if necessary</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">  if (!isa<MemoryUse>(MA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">  if (!isa<MemoryUse>(MA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">    getWalker()->invalidateInfo(MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">    getWalker()->invalidateInfo(MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">  Value *MemoryInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">  Value *MemoryInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">  if (const auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">  if (const auto *MUD = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">    MemoryInst = MUD->getMemoryInst();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">    MemoryInst = MUD->getMemoryInst();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">    MemoryInst = MA->getBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">    MemoryInst = MA->getBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">  auto VMA = ValueToMemoryAccess.find(MemoryInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">  auto VMA = ValueToMemoryAccess.find(MemoryInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">  if (VMA->second == MA)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">  if (VMA->second == MA)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">    ValueToMemoryAccess.erase(VMA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">    ValueToMemoryAccess.erase(VMA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">/// Properly remove \p MA from all of MemorySSA's lists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">/// Properly remove \p MA from all of MemorySSA's lists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">/// Because of the way the intrusive list and use lists work, it is important to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">/// Because of the way the intrusive list and use lists work, it is important to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">/// do removal in the right order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">/// do removal in the right order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">/// ShouldDelete defaults to true, and will cause the memory access to also be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">/// ShouldDelete defaults to true, and will cause the memory access to also be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">/// deleted, not just removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">/// deleted, not just removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">void MemorySSA::removeFromLists(MemoryAccess *MA, bool ShouldDelete) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">void MemorySSA::removeFromLists(MemoryAccess *MA, bool ShouldDelete) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">  BasicBlock *BB = MA->getBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">  BasicBlock *BB = MA->getBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">  // The access list owns the reference, so we erase it from the non-owning list</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">  // The access list owns the reference, so we erase it from the non-owning list</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">  // first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">  // first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">  if (!isa<MemoryUse>(MA)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">  if (!isa<MemoryUse>(MA)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">    auto DefsIt = PerBlockDefs.find(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">    auto DefsIt = PerBlockDefs.find(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">    std::unique_ptr<DefsList> &Defs = DefsIt->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">    std::unique_ptr<DefsList> &Defs = DefsIt->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">    Defs->remove(*MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">    Defs->remove(*MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">    if (Defs->empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">    if (Defs->empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">      PerBlockDefs.erase(DefsIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">      PerBlockDefs.erase(DefsIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">  // The erase call here will delete it. If we don't want it deleted, we call</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">  // The erase call here will delete it. If we don't want it deleted, we call</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">  // remove instead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">  // remove instead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">  auto AccessIt = PerBlockAccesses.find(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">  auto AccessIt = PerBlockAccesses.find(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">  std::unique_ptr<AccessList> &Accesses = AccessIt->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">  std::unique_ptr<AccessList> &Accesses = AccessIt->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">  if (ShouldDelete)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">  if (ShouldDelete)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">    Accesses->erase(MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">    Accesses->erase(MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">    Accesses->remove(MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">    Accesses->remove(MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">  if (Accesses->empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">  if (Accesses->empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">    PerBlockAccesses.erase(AccessIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">    PerBlockAccesses.erase(AccessIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">    BlockNumberingValid.erase(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">    BlockNumberingValid.erase(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">void MemorySSA::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">void MemorySSA::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">  MemorySSAAnnotatedWriter Writer(this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">  MemorySSAAnnotatedWriter Writer(this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">  F.print(OS, &Writer);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">  F.print(OS, &Writer);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">LLVM_DUMP_METHOD void MemorySSA::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">LLVM_DUMP_METHOD void MemorySSA::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">void MemorySSA::verifyMemorySSA(VerificationLevel VL) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">void MemorySSA::verifyMemorySSA(VerificationLevel VL) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">#if !defined(NDEBUG) && defined(EXPENSIVE_CHECKS)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">#if !defined(NDEBUG) && defined(EXPENSIVE_CHECKS)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">  VL = VerificationLevel::Full;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">  VL = VerificationLevel::Full;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">  verifyOrderingDominationAndDefUses(F, VL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">  verifyOrderingDominationAndDefUses(F, VL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">  verifyDominationNumbers(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">  verifyDominationNumbers(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">  if (VL == VerificationLevel::Full)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">  if (VL == VerificationLevel::Full)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">    verifyPrevDefInPhis(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">    verifyPrevDefInPhis(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">  // Previously, the verification used to also verify that the clobberingAccess</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">  // Previously, the verification used to also verify that the clobberingAccess</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">  // cached by MemorySSA is the same as the clobberingAccess found at a later</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">  // cached by MemorySSA is the same as the clobberingAccess found at a later</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">  // query to AA. This does not hold true in general due to the current fragility</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">  // query to AA. This does not hold true in general due to the current fragility</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">  // of BasicAA which has arbitrary caps on the things it analyzes before giving</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">  // of BasicAA which has arbitrary caps on the things it analyzes before giving</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">  // up. As a result, transformations that are correct, will lead to BasicAA</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">  // up. As a result, transformations that are correct, will lead to BasicAA</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">  // returning different Alias answers before and after that transformation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">  // returning different Alias answers before and after that transformation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">  // Invalidating MemorySSA is not an option, as the results in BasicAA can be so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">  // Invalidating MemorySSA is not an option, as the results in BasicAA can be so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">  // random, in the worst case we'd need to rebuild MemorySSA from scratch after</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">  // random, in the worst case we'd need to rebuild MemorySSA from scratch after</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">  // every transformation, which defeats the purpose of using it. For such an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">  // every transformation, which defeats the purpose of using it. For such an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">  // example, see test4 added in D51960.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">  // example, see test4 added in D51960.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">void MemorySSA::verifyPrevDefInPhis(Function &F) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">void MemorySSA::verifyPrevDefInPhis(Function &F) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">  for (const BasicBlock &BB : F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">  for (const BasicBlock &BB : F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">    if (MemoryPhi *Phi = getMemoryAccess(&BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">    if (MemoryPhi *Phi = getMemoryAccess(&BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">      for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">      for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">        auto *Pred = Phi->getIncomingBlock(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">        auto *Pred = Phi->getIncomingBlock(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">        auto *IncAcc = Phi->getIncomingValue(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">        auto *IncAcc = Phi->getIncomingValue(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">        // If Pred has no unreachable predecessors, get last def looking at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">        // If Pred has no unreachable predecessors, get last def looking at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">        // IDoms. If, while walkings IDoms, any of these has an unreachable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">        // IDoms. If, while walkings IDoms, any of these has an unreachable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">        // predecessor, then the incoming def can be any access.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">        // predecessor, then the incoming def can be any access.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">        if (auto *DTNode = DT->getNode(Pred)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">        if (auto *DTNode = DT->getNode(Pred)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">          while (DTNode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">          while (DTNode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">            if (auto *DefList = getBlockDefs(DTNode->getBlock())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">            if (auto *DefList = getBlockDefs(DTNode->getBlock())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">              auto *LastAcc = &*(--DefList->end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">              auto *LastAcc = &*(--DefList->end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">              assert(LastAcc == IncAcc &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">              assert(LastAcc == IncAcc &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">                     "Incorrect incoming access into phi.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">                     "Incorrect incoming access into phi.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">              (void)IncAcc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">              (void)IncAcc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">              (void)LastAcc;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">              (void)LastAcc;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">              break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">              break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">            DTNode = DTNode->getIDom();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">            DTNode = DTNode->getIDom();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">          // If Pred has unreachable predecessors, but has at least a Def, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">          // If Pred has unreachable predecessors, but has at least a Def, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">          // incoming access can be the last Def in Pred, or it could have been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">          // incoming access can be the last Def in Pred, or it could have been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">          // optimized to LoE. After an update, though, the LoE may have been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">          // optimized to LoE. After an update, though, the LoE may have been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">          // replaced by another access, so IncAcc may be any access.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">          // replaced by another access, so IncAcc may be any access.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">          // If Pred has unreachable predecessors and no Defs, incoming access</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">          // If Pred has unreachable predecessors and no Defs, incoming access</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">          // should be LoE; However, after an update, it may be any access.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">          // should be LoE; However, after an update, it may be any access.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">/// Verify that all of the blocks we believe to have valid domination numbers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">/// Verify that all of the blocks we believe to have valid domination numbers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">/// actually have valid domination numbers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">/// actually have valid domination numbers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">void MemorySSA::verifyDominationNumbers(const Function &F) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">void MemorySSA::verifyDominationNumbers(const Function &F) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">  if (BlockNumberingValid.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">  if (BlockNumberingValid.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">  SmallPtrSet<const BasicBlock *, 16> ValidBlocks = BlockNumberingValid;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">  SmallPtrSet<const BasicBlock *, 16> ValidBlocks = BlockNumberingValid;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">  for (const BasicBlock &BB : F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">  for (const BasicBlock &BB : F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">    if (!ValidBlocks.count(&BB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">    if (!ValidBlocks.count(&BB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">    ValidBlocks.erase(&BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">    ValidBlocks.erase(&BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">    const AccessList *Accesses = getBlockAccesses(&BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">    const AccessList *Accesses = getBlockAccesses(&BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">    // It's correct to say an empty block has valid numbering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">    // It's correct to say an empty block has valid numbering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">    if (!Accesses)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">    if (!Accesses)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">    // Block numbering starts at 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">    // Block numbering starts at 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">    unsigned long LastNumber = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">    unsigned long LastNumber = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">    for (const MemoryAccess &MA : *Accesses) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">    for (const MemoryAccess &MA : *Accesses) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">      auto ThisNumberIter = BlockNumbering.find(&MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">      auto ThisNumberIter = BlockNumbering.find(&MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">      assert(ThisNumberIter != BlockNumbering.end() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">      assert(ThisNumberIter != BlockNumbering.end() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">             "MemoryAccess has no domination number in a valid block!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">             "MemoryAccess has no domination number in a valid block!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">      unsigned long ThisNumber = ThisNumberIter->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">      unsigned long ThisNumber = ThisNumberIter->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">      assert(ThisNumber > LastNumber &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">      assert(ThisNumber > LastNumber &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">             "Domination numbers should be strictly increasing!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">             "Domination numbers should be strictly increasing!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">      (void)LastNumber;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">      (void)LastNumber;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">      LastNumber = ThisNumber;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">      LastNumber = ThisNumber;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">  assert(ValidBlocks.empty() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">  assert(ValidBlocks.empty() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">         "All valid BasicBlocks should exist in F -- dangling pointers?");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">         "All valid BasicBlocks should exist in F -- dangling pointers?");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">/// Verify ordering: the order and existence of MemoryAccesses matches the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">/// Verify ordering: the order and existence of MemoryAccesses matches the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">/// order and existence of memory affecting instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">/// order and existence of memory affecting instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">/// Verify domination: each definition dominates all of its uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">/// Verify domination: each definition dominates all of its uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">/// Verify def-uses: the immediate use information - walk all the memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">/// Verify def-uses: the immediate use information - walk all the memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">/// accesses and verifying that, for each use, it appears in the appropriate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">/// accesses and verifying that, for each use, it appears in the appropriate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">/// def's use list</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">/// def's use list</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">void MemorySSA::verifyOrderingDominationAndDefUses(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">void MemorySSA::verifyOrderingDominationAndDefUses(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">                                                   VerificationLevel VL) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">                                                   VerificationLevel VL) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">  // Walk all the blocks, comparing what the lookups think and what the access</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">  // Walk all the blocks, comparing what the lookups think and what the access</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">  // lists think, as well as the order in the blocks vs the order in the access</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">  // lists think, as well as the order in the blocks vs the order in the access</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">  // lists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">  // lists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  SmallVector<MemoryAccess *, 32> ActualAccesses;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  SmallVector<MemoryAccess *, 32> ActualAccesses;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">  SmallVector<MemoryAccess *, 32> ActualDefs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">  SmallVector<MemoryAccess *, 32> ActualDefs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">  for (BasicBlock &B : F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">    const AccessList *AL = getBlockAccesses(&B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">    const AccessList *AL = getBlockAccesses(&B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">    const auto *DL = getBlockDefs(&B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">    const auto *DL = getBlockDefs(&B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">    MemoryPhi *Phi = getMemoryAccess(&B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">    MemoryPhi *Phi = getMemoryAccess(&B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">    if (Phi) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">    if (Phi) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">      // Verify ordering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">      // Verify ordering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">      ActualAccesses.push_back(Phi);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">      ActualAccesses.push_back(Phi);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">      ActualDefs.push_back(Phi);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">      ActualDefs.push_back(Phi);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">      // Verify domination</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">      // Verify domination</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">      for (const Use &U : Phi->uses()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">      for (const Use &U : Phi->uses()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">        assert(dominates(Phi, U) && "Memory PHI does not dominate it's uses");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">        assert(dominates(Phi, U) && "Memory PHI does not dominate it's uses");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">        (void)U;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">        (void)U;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">      // Verify def-uses for full verify.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">      // Verify def-uses for full verify.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">      if (VL == VerificationLevel::Full) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">      if (VL == VerificationLevel::Full) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">        assert(Phi->getNumOperands() == static_cast<unsigned>(std::distance(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">        assert(Phi->getNumOperands() == static_cast<unsigned>(std::distance(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">                                            pred_begin(&B), pred_end(&B))) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">                                            pred_begin(&B), pred_end(&B))) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">               "Incomplete MemoryPhi Node");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">               "Incomplete MemoryPhi Node");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">        for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">        for (unsigned I = 0, E = Phi->getNumIncomingValues(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">          verifyUseInDefs(Phi->getIncomingValue(I), Phi);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">          verifyUseInDefs(Phi->getIncomingValue(I), Phi);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">          assert(is_contained(predecessors(&B), Phi->getIncomingBlock(I)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">          assert(is_contained(predecessors(&B), Phi->getIncomingBlock(I)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">                 "Incoming phi block not a block predecessor");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">                 "Incoming phi block not a block predecessor");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">    for (Instruction &I : B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">    for (Instruction &I : B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">      MemoryUseOrDef *MA = getMemoryAccess(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">      MemoryUseOrDef *MA = getMemoryAccess(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">      assert((!MA || (AL && (isa<MemoryUse>(MA) || DL))) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">      assert((!MA || (AL && (isa<MemoryUse>(MA) || DL))) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">             "We have memory affecting instructions "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">             "We have memory affecting instructions "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">             "in this block but they are not in the "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">             "in this block but they are not in the "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">             "access list or defs list");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">             "access list or defs list");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">      if (MA) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">      if (MA) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">        // Verify ordering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">        // Verify ordering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">        ActualAccesses.push_back(MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">        ActualAccesses.push_back(MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">        if (MemoryAccess *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">        if (MemoryAccess *MD = dyn_cast<MemoryDef>(MA)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">          // Verify ordering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">          // Verify ordering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">          ActualDefs.push_back(MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">          ActualDefs.push_back(MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">          // Verify domination.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">          // Verify domination.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">          for (const Use &U : MD->uses()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">          for (const Use &U : MD->uses()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">            assert(dominates(MD, U) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">            assert(dominates(MD, U) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">                   "Memory Def does not dominate it's uses");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">                   "Memory Def does not dominate it's uses");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">            (void)U;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">            (void)U;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">        // Verify def-uses for full verify.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">        // Verify def-uses for full verify.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">        if (VL == VerificationLevel::Full)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">        if (VL == VerificationLevel::Full)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">          verifyUseInDefs(MA->getDefiningAccess(), MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">          verifyUseInDefs(MA->getDefiningAccess(), MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">    // Either we hit the assert, really have no accesses, or we have both</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">    // Either we hit the assert, really have no accesses, or we have both</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">    // accesses and an access list. Same with defs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">    // accesses and an access list. Same with defs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">    if (!AL && !DL)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">    if (!AL && !DL)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">    // Verify ordering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">    // Verify ordering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">    assert(AL->size() == ActualAccesses.size() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">    assert(AL->size() == ActualAccesses.size() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">           "We don't have the same number of accesses in the block as on the "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">           "We don't have the same number of accesses in the block as on the "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">           "access list");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">           "access list");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">    assert((DL || ActualDefs.size() == 0) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">    assert((DL || ActualDefs.size() == 0) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">           "Either we should have a defs list, or we should have no defs");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">           "Either we should have a defs list, or we should have no defs");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">    assert((!DL || DL->size() == ActualDefs.size()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">    assert((!DL || DL->size() == ActualDefs.size()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">           "We don't have the same number of defs in the block as on the "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">           "We don't have the same number of defs in the block as on the "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">           "def list");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">           "def list");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">    auto ALI = AL->begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">    auto ALI = AL->begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">    auto AAI = ActualAccesses.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">    auto AAI = ActualAccesses.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">    while (ALI != AL->end() && AAI != ActualAccesses.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">    while (ALI != AL->end() && AAI != ActualAccesses.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">      assert(&*ALI == *AAI && "Not the same accesses in the same order");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">      assert(&*ALI == *AAI && "Not the same accesses in the same order");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">      ++ALI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">      ++ALI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">      ++AAI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">      ++AAI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">    ActualAccesses.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">    ActualAccesses.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">    if (DL) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">    if (DL) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">      auto DLI = DL->begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">      auto DLI = DL->begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">      auto ADI = ActualDefs.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">      auto ADI = ActualDefs.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">      while (DLI != DL->end() && ADI != ActualDefs.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">      while (DLI != DL->end() && ADI != ActualDefs.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">        assert(&*DLI == *ADI && "Not the same defs in the same order");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">        assert(&*DLI == *ADI && "Not the same defs in the same order");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">        ++DLI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">        ++DLI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">        ++ADI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">        ++ADI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">    ActualDefs.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">    ActualDefs.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">/// Verify the def-use lists in MemorySSA, by verifying that \p Use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">/// Verify the def-use lists in MemorySSA, by verifying that \p Use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">/// appears in the use list of \p Def.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">/// appears in the use list of \p Def.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">void MemorySSA::verifyUseInDefs(MemoryAccess *Def, MemoryAccess *Use) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">void MemorySSA::verifyUseInDefs(MemoryAccess *Def, MemoryAccess *Use) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">  // The live on entry use may cause us to get a NULL def here</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">  // The live on entry use may cause us to get a NULL def here</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">  if (!Def)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">  if (!Def)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">    assert(isLiveOnEntryDef(Use) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">    assert(isLiveOnEntryDef(Use) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">           "Null def but use not point to live on entry def");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">           "Null def but use not point to live on entry def");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">    assert(is_contained(Def->users(), Use) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">    assert(is_contained(Def->users(), Use) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">           "Did not find use in def's use list");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">           "Did not find use in def's use list");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">/// Perform a local numbering on blocks so that instruction ordering can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">/// Perform a local numbering on blocks so that instruction ordering can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">/// determined in constant time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">/// determined in constant time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">/// TODO: We currently just number in order.  If we numbered by N, we could</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">/// TODO: We currently just number in order.  If we numbered by N, we could</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">/// allow at least N-1 sequences of insertBefore or insertAfter (and at least</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">/// allow at least N-1 sequences of insertBefore or insertAfter (and at least</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">/// log2(N) sequences of mixed before and after) without needing to invalidate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">/// log2(N) sequences of mixed before and after) without needing to invalidate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">/// the numbering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">/// the numbering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">void MemorySSA::renumberBlock(const BasicBlock *B) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">void MemorySSA::renumberBlock(const BasicBlock *B) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">  // The pre-increment ensures the numbers really start at 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">  // The pre-increment ensures the numbers really start at 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">  unsigned long CurrentNumber = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">  unsigned long CurrentNumber = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">  const AccessList *AL = getBlockAccesses(B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">  const AccessList *AL = getBlockAccesses(B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">  assert(AL != nullptr && "Asking to renumber an empty block");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">  assert(AL != nullptr && "Asking to renumber an empty block");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">  for (const auto &I : *AL)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">  for (const auto &I : *AL)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">    BlockNumbering[&I] = ++CurrentNumber;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">    BlockNumbering[&I] = ++CurrentNumber;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">  BlockNumberingValid.insert(B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">  BlockNumberingValid.insert(B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">/// Determine, for two memory accesses in the same block,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">/// Determine, for two memory accesses in the same block,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">/// whether \p Dominator dominates \p Dominatee.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">/// whether \p Dominator dominates \p Dominatee.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">/// \returns True if \p Dominator dominates \p Dominatee.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">/// \returns True if \p Dominator dominates \p Dominatee.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">bool MemorySSA::locallyDominates(const MemoryAccess *Dominator,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">bool MemorySSA::locallyDominates(const MemoryAccess *Dominator,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">                                 const MemoryAccess *Dominatee) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">                                 const MemoryAccess *Dominatee) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">  const BasicBlock *DominatorBlock = Dominator->getBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">  const BasicBlock *DominatorBlock = Dominator->getBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">  assert((DominatorBlock == Dominatee->getBlock()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">  assert((DominatorBlock == Dominatee->getBlock()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">         "Asking for local domination when accesses are in different blocks!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">         "Asking for local domination when accesses are in different blocks!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">  // A node dominates itself.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">  // A node dominates itself.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">  if (Dominatee == Dominator)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">  if (Dominatee == Dominator)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">  // When Dominatee is defined on function entry, it is not dominated by another</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">  // When Dominatee is defined on function entry, it is not dominated by another</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">  // memory access.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">  // memory access.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">  if (isLiveOnEntryDef(Dominatee))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">  if (isLiveOnEntryDef(Dominatee))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">  // When Dominator is defined on function entry, it dominates the other memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">  // When Dominator is defined on function entry, it dominates the other memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">  // access.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">  // access.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">  if (isLiveOnEntryDef(Dominator))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">  if (isLiveOnEntryDef(Dominator))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">  if (!BlockNumberingValid.count(DominatorBlock))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">  if (!BlockNumberingValid.count(DominatorBlock))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">    renumberBlock(DominatorBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">    renumberBlock(DominatorBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">  unsigned long DominatorNum = BlockNumbering.lookup(Dominator);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">  unsigned long DominatorNum = BlockNumbering.lookup(Dominator);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">  // All numbers start with 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">  // All numbers start with 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">  assert(DominatorNum != 0 && "Block was not numbered properly");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">  assert(DominatorNum != 0 && "Block was not numbered properly");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">  unsigned long DominateeNum = BlockNumbering.lookup(Dominatee);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">  unsigned long DominateeNum = BlockNumbering.lookup(Dominatee);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">  assert(DominateeNum != 0 && "Block was not numbered properly");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">  assert(DominateeNum != 0 && "Block was not numbered properly");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">  return DominatorNum < DominateeNum;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">  return DominatorNum < DominateeNum;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">bool MemorySSA::dominates(const MemoryAccess *Dominator,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">bool MemorySSA::dominates(const MemoryAccess *Dominator,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">                          const MemoryAccess *Dominatee) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">                          const MemoryAccess *Dominatee) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">  if (Dominator == Dominatee)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">  if (Dominator == Dominatee)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">  if (isLiveOnEntryDef(Dominatee))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">  if (isLiveOnEntryDef(Dominatee))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">  if (Dominator->getBlock() != Dominatee->getBlock())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">  if (Dominator->getBlock() != Dominatee->getBlock())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">    return DT->dominates(Dominator->getBlock(), Dominatee->getBlock());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">    return DT->dominates(Dominator->getBlock(), Dominatee->getBlock());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">  return locallyDominates(Dominator, Dominatee);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">  return locallyDominates(Dominator, Dominatee);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">bool MemorySSA::dominates(const MemoryAccess *Dominator,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">bool MemorySSA::dominates(const MemoryAccess *Dominator,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">                          const Use &Dominatee) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">                          const Use &Dominatee) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">  if (MemoryPhi *MP = dyn_cast<MemoryPhi>(Dominatee.getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">  if (MemoryPhi *MP = dyn_cast<MemoryPhi>(Dominatee.getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">    BasicBlock *UseBB = MP->getIncomingBlock(Dominatee);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">    BasicBlock *UseBB = MP->getIncomingBlock(Dominatee);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">    // The def must dominate the incoming block of the phi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">    // The def must dominate the incoming block of the phi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">    if (UseBB != Dominator->getBlock())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">    if (UseBB != Dominator->getBlock())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">      return DT->dominates(Dominator->getBlock(), UseBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">      return DT->dominates(Dominator->getBlock(), UseBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">    // If the UseBB and the DefBB are the same, compare locally.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">    // If the UseBB and the DefBB are the same, compare locally.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">    return locallyDominates(Dominator, cast<MemoryAccess>(Dominatee));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">    return locallyDominates(Dominator, cast<MemoryAccess>(Dominatee));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">  // If it's not a PHI node use, the normal dominates can already handle it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">  // If it's not a PHI node use, the normal dominates can already handle it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">  return dominates(Dominator, cast<MemoryAccess>(Dominatee.getUser()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">  return dominates(Dominator, cast<MemoryAccess>(Dominatee.getUser()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">void MemorySSA::ensureOptimizedUses() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">void MemorySSA::ensureOptimizedUses() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">  if (IsOptimized)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">  if (IsOptimized)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">  BatchAAResults BatchAA(*AA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">  BatchAAResults BatchAA(*AA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">  ClobberWalkerBase WalkerBase(this, DT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">  ClobberWalkerBase WalkerBase(this, DT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">  CachingWalker WalkerLocal(this, &WalkerBase);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">  CachingWalker WalkerLocal(this, &WalkerBase);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">  OptimizeUses(this, &WalkerLocal, &BatchAA, DT).optimizeUses();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">  OptimizeUses(this, &WalkerLocal, &BatchAA, DT).optimizeUses();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">  IsOptimized = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">  IsOptimized = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">void MemoryAccess::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">void MemoryAccess::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">  switch (getValueID()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">  switch (getValueID()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">  case MemoryPhiVal: return static_cast<const MemoryPhi *>(this)->print(OS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">  case MemoryPhiVal: return static_cast<const MemoryPhi *>(this)->print(OS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">  case MemoryDefVal: return static_cast<const MemoryDef *>(this)->print(OS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">  case MemoryDefVal: return static_cast<const MemoryDef *>(this)->print(OS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">  case MemoryUseVal: return static_cast<const MemoryUse *>(this)->print(OS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">  case MemoryUseVal: return static_cast<const MemoryUse *>(this)->print(OS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">  llvm_unreachable("invalid value id");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">  llvm_unreachable("invalid value id");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">void MemoryDef::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">void MemoryDef::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">  MemoryAccess *UO = getDefiningAccess();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">  MemoryAccess *UO = getDefiningAccess();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">  auto printID = [&OS](MemoryAccess *A) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">  auto printID = [&OS](MemoryAccess *A) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">    if (A && A->getID())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">    if (A && A->getID())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">      OS << A->getID();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">      OS << A->getID();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">      OS << LiveOnEntryStr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">      OS << LiveOnEntryStr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">  OS << getID() << " = MemoryDef(";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">  OS << getID() << " = MemoryDef(";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">  printID(UO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">  printID(UO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">  OS << ")";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">  OS << ")";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">  if (isOptimized()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">  if (isOptimized()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">    OS << "->";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">    OS << "->";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">    printID(getOptimized());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">    printID(getOptimized());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">void MemoryPhi::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">void MemoryPhi::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">  ListSeparator LS(",");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">  ListSeparator LS(",");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">  OS << getID() << " = MemoryPhi(";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">  OS << getID() << " = MemoryPhi(";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">  for (const auto &Op : operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">  for (const auto &Op : operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">    BasicBlock *BB = getIncomingBlock(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">    BasicBlock *BB = getIncomingBlock(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">    MemoryAccess *MA = cast<MemoryAccess>(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">    MemoryAccess *MA = cast<MemoryAccess>(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">    OS << LS << '{';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">    OS << LS << '{';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">    if (BB->hasName())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">    if (BB->hasName())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">      OS << BB->getName();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">      OS << BB->getName();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">      BB->printAsOperand(OS, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">      BB->printAsOperand(OS, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">    OS << ',';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">    OS << ',';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">    if (unsigned ID = MA->getID())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">    if (unsigned ID = MA->getID())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">      OS << ID;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">      OS << ID;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">      OS << LiveOnEntryStr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">      OS << LiveOnEntryStr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">    OS << '}';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">    OS << '}';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">  OS << ')';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">  OS << ')';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">void MemoryUse::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">void MemoryUse::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">  MemoryAccess *UO = getDefiningAccess();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">  MemoryAccess *UO = getDefiningAccess();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">  OS << "MemoryUse(";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">  OS << "MemoryUse(";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">  if (UO && UO->getID())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">  if (UO && UO->getID())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">    OS << UO->getID();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">    OS << UO->getID();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">    OS << LiveOnEntryStr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">    OS << LiveOnEntryStr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">  OS << ')';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">  OS << ')';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">void MemoryAccess::dump() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">void MemoryAccess::dump() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">// Cannot completely remove virtual function even in release mode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">// Cannot completely remove virtual function even in release mode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">  print(dbgs());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">  print(dbgs());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">  dbgs() << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">  dbgs() << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">class DOTFuncMSSAInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">class DOTFuncMSSAInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">  const Function &F;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">  const Function &F;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">  MemorySSAAnnotatedWriter MSSAWriter;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">  MemorySSAAnnotatedWriter MSSAWriter;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">  DOTFuncMSSAInfo(const Function &F, MemorySSA &MSSA)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">  DOTFuncMSSAInfo(const Function &F, MemorySSA &MSSA)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">      : F(F), MSSAWriter(&MSSA) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">      : F(F), MSSAWriter(&MSSA) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">  const Function *getFunction() { return &F; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">  const Function *getFunction() { return &F; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">  MemorySSAAnnotatedWriter &getWriter() { return MSSAWriter; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">  MemorySSAAnnotatedWriter &getWriter() { return MSSAWriter; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">template <></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">template <></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">struct GraphTraits<DOTFuncMSSAInfo *> : public GraphTraits<const BasicBlock *> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">struct GraphTraits<DOTFuncMSSAInfo *> : public GraphTraits<const BasicBlock *> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">  static NodeRef getEntryNode(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">  static NodeRef getEntryNode(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">    return &(CFGInfo->getFunction()->getEntryBlock());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">    return &(CFGInfo->getFunction()->getEntryBlock());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine">  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine">  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">  using nodes_iterator = pointer_iterator<Function::const_iterator>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">  using nodes_iterator = pointer_iterator<Function::const_iterator>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">  static nodes_iterator nodes_begin(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">  static nodes_iterator nodes_begin(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">    return nodes_iterator(CFGInfo->getFunction()->begin());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">    return nodes_iterator(CFGInfo->getFunction()->begin());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">  static nodes_iterator nodes_end(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">  static nodes_iterator nodes_end(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">    return nodes_iterator(CFGInfo->getFunction()->end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">    return nodes_iterator(CFGInfo->getFunction()->end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">  static size_t size(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">  static size_t size(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">    return CFGInfo->getFunction()->size();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">    return CFGInfo->getFunction()->size();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">template <></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">template <></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">struct DOTGraphTraits<DOTFuncMSSAInfo *> : public DefaultDOTGraphTraits {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">struct DOTGraphTraits<DOTFuncMSSAInfo *> : public DefaultDOTGraphTraits {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">  DOTGraphTraits(bool IsSimple = false) : DefaultDOTGraphTraits(IsSimple) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">  DOTGraphTraits(bool IsSimple = false) : DefaultDOTGraphTraits(IsSimple) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">  static std::string getGraphName(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">  static std::string getGraphName(DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">    return "MSSA CFG for '" + CFGInfo->getFunction()->getName().str() +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">    return "MSSA CFG for '" + CFGInfo->getFunction()->getName().str() +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">           "' function";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">           "' function";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">  std::string getNodeLabel(const BasicBlock *Node, DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">  std::string getNodeLabel(const BasicBlock *Node, DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">    return DOTGraphTraits<DOTFuncInfo *>::getCompleteNodeLabel(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">    return DOTGraphTraits<DOTFuncInfo *>::getCompleteNodeLabel(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">        Node, nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">        Node, nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">        [CFGInfo](raw_string_ostream &OS, const BasicBlock &BB) -> void {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">        [CFGInfo](raw_string_ostream &OS, const BasicBlock &BB) -> void {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">          BB.print(OS, &CFGInfo->getWriter(), true, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">          BB.print(OS, &CFGInfo->getWriter(), true, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">        [](std::string &S, unsigned &I, unsigned Idx) -> void {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">        [](std::string &S, unsigned &I, unsigned Idx) -> void {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">          std::string Str = S.substr(I, Idx - I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">          std::string Str = S.substr(I, Idx - I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">          StringRef SR = Str;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">          StringRef SR = Str;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">          if (SR.count(" = MemoryDef(") || SR.count(" = MemoryPhi(") ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">          if (SR.count(" = MemoryDef(") || SR.count(" = MemoryPhi(") ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">              SR.count("MemoryUse("))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">              SR.count("MemoryUse("))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">            return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">            return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">          DOTGraphTraits<DOTFuncInfo *>::eraseComment(S, I, Idx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">          DOTGraphTraits<DOTFuncInfo *>::eraseComment(S, I, Idx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">  static std::string getEdgeSourceLabel(const BasicBlock *Node,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">  static std::string getEdgeSourceLabel(const BasicBlock *Node,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">                                        const_succ_iterator I) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">                                        const_succ_iterator I) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">    return DOTGraphTraits<DOTFuncInfo *>::getEdgeSourceLabel(Node, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">    return DOTGraphTraits<DOTFuncInfo *>::getEdgeSourceLabel(Node, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">  /// Display the raw branch weights from PGO.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">  /// Display the raw branch weights from PGO.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">  std::string getEdgeAttributes(const BasicBlock *Node, const_succ_iterator I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">  std::string getEdgeAttributes(const BasicBlock *Node, const_succ_iterator I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">                                DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">                                DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">    return "";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">    return "";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">  std::string getNodeAttributes(const BasicBlock *Node,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">  std::string getNodeAttributes(const BasicBlock *Node,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">                                DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">                                DOTFuncMSSAInfo *CFGInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">    return getNodeLabel(Node, CFGInfo).find(';') != std::string::npos</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">    return getNodeLabel(Node, CFGInfo).find(';') != std::string::npos</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">               ? "style=filled, fillcolor=lightpink"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">               ? "style=filled, fillcolor=lightpink"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">               : "";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">               : "";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">AnalysisKey MemorySSAAnalysis::Key;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">AnalysisKey MemorySSAAnalysis::Key;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">MemorySSAAnalysis::Result MemorySSAAnalysis::run(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">MemorySSAAnalysis::Result MemorySSAAnalysis::run(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine">                                                 FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine">                                                 FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">  auto &AA = AM.getResult<AAManager>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">  auto &AA = AM.getResult<AAManager>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">  return MemorySSAAnalysis::Result(std::make_unique<MemorySSA>(F, &AA, &DT));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">  return MemorySSAAnalysis::Result(std::make_unique<MemorySSA>(F, &AA, &DT));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine">bool MemorySSAAnalysis::Result::invalidate(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine">bool MemorySSAAnalysis::Result::invalidate(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">    Function &F, const PreservedAnalyses &PA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">    Function &F, const PreservedAnalyses &PA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">    FunctionAnalysisManager::Invalidator &Inv) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">    FunctionAnalysisManager::Invalidator &Inv) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">  auto PAC = PA.getChecker<MemorySSAAnalysis>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">  auto PAC = PA.getChecker<MemorySSAAnalysis>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">  return !(PAC.preserved() || PAC.preservedSet<AllAnalysesOn<Function>>()) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">  return !(PAC.preserved() || PAC.preservedSet<AllAnalysesOn<Function>>()) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">         Inv.invalidate<AAManager>(F, PA) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">         Inv.invalidate<AAManager>(F, PA) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">         Inv.invalidate<DominatorTreeAnalysis>(F, PA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">         Inv.invalidate<DominatorTreeAnalysis>(F, PA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">PreservedAnalyses MemorySSAPrinterPass::run(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">PreservedAnalyses MemorySSAPrinterPass::run(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">                                            FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">                                            FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">  auto &MSSA = AM.getResult<MemorySSAAnalysis>(F).getMSSA();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">  auto &MSSA = AM.getResult<MemorySSAAnalysis>(F).getMSSA();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">  if (EnsureOptimizedUses)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">  if (EnsureOptimizedUses)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">    MSSA.ensureOptimizedUses();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">    MSSA.ensureOptimizedUses();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">  if (DotCFGMSSA != "") {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">  if (DotCFGMSSA != "") {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">    DOTFuncMSSAInfo CFGInfo(F, MSSA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">    DOTFuncMSSAInfo CFGInfo(F, MSSA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">    WriteGraph(&CFGInfo, "", false, "MSSA", DotCFGMSSA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">    WriteGraph(&CFGInfo, "", false, "MSSA", DotCFGMSSA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">    OS << "MemorySSA for function: " << F.getName() << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">    OS << "MemorySSA for function: " << F.getName() << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">    MSSA.print(OS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">    MSSA.print(OS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">PreservedAnalyses MemorySSAWalkerPrinterPass::run(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">PreservedAnalyses MemorySSAWalkerPrinterPass::run(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">                                                  FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">                                                  FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">  auto &MSSA = AM.getResult<MemorySSAAnalysis>(F).getMSSA();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">  auto &MSSA = AM.getResult<MemorySSAAnalysis>(F).getMSSA();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">  OS << "MemorySSA (walker) for function: " << F.getName() << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">  OS << "MemorySSA (walker) for function: " << F.getName() << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">  MemorySSAWalkerAnnotatedWriter Writer(&MSSA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">  MemorySSAWalkerAnnotatedWriter Writer(&MSSA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">  F.print(OS, &Writer);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">  F.print(OS, &Writer);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">PreservedAnalyses MemorySSAVerifierPass::run(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">PreservedAnalyses MemorySSAVerifierPass::run(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">                                             FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">                                             FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">  AM.getResult<MemorySSAAnalysis>(F).getMSSA().verifyMemorySSA();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">  AM.getResult<MemorySSAAnalysis>(F).getMSSA().verifyMemorySSA();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine">char MemorySSAWrapperPass::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine">char MemorySSAWrapperPass::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">MemorySSAWrapperPass::MemorySSAWrapperPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">MemorySSAWrapperPass::MemorySSAWrapperPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">  initializeMemorySSAWrapperPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">  initializeMemorySSAWrapperPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">void MemorySSAWrapperPass::releaseMemory() { MSSA.reset(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">void MemorySSAWrapperPass::releaseMemory() { MSSA.reset(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">void MemorySSAWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">void MemorySSAWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">  AU.setPreservesAll();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">  AU.setPreservesAll();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine">  AU.addRequiredTransitive<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine">  AU.addRequiredTransitive<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">  AU.addRequiredTransitive<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">  AU.addRequiredTransitive<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">bool MemorySSAWrapperPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">bool MemorySSAWrapperPass::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">  auto &AA = getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">  MSSA.reset(new MemorySSA(F, &AA, &DT));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">  MSSA.reset(new MemorySSA(F, &AA, &DT));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">void MemorySSAWrapperPass::verifyAnalysis() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">void MemorySSAWrapperPass::verifyAnalysis() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">  if (VerifyMemorySSA)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">  if (VerifyMemorySSA)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">    MSSA->verifyMemorySSA();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">    MSSA->verifyMemorySSA();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">void MemorySSAWrapperPass::print(raw_ostream &OS, const Module *M) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">void MemorySSAWrapperPass::print(raw_ostream &OS, const Module *M) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">  MSSA->print(OS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">  MSSA->print(OS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">MemorySSAWalker::MemorySSAWalker(MemorySSA *M) : MSSA(M) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">MemorySSAWalker::MemorySSAWalker(MemorySSA *M) : MSSA(M) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">/// Walk the use-def chains starting at \p StartingAccess and find</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">/// Walk the use-def chains starting at \p StartingAccess and find</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine">/// the MemoryAccess that actually clobbers Loc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine">/// the MemoryAccess that actually clobbers Loc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">/// \returns our clobbering memory access</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">/// \returns our clobbering memory access</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">MemoryAccess *MemorySSA::ClobberWalkerBase::getClobberingMemoryAccessBase(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">MemoryAccess *MemorySSA::ClobberWalkerBase::getClobberingMemoryAccessBase(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">    MemoryAccess *StartingAccess, const MemoryLocation &Loc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">    MemoryAccess *StartingAccess, const MemoryLocation &Loc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">    BatchAAResults &BAA, unsigned &UpwardWalkLimit) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">    BatchAAResults &BAA, unsigned &UpwardWalkLimit) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">  assert(!isa<MemoryUse>(StartingAccess) && "Use cannot be defining access");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">  assert(!isa<MemoryUse>(StartingAccess) && "Use cannot be defining access");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">  Instruction *I = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">  Instruction *I = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">  if (auto *StartingUseOrDef = dyn_cast<MemoryUseOrDef>(StartingAccess)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">  if (auto *StartingUseOrDef = dyn_cast<MemoryUseOrDef>(StartingAccess)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">    if (MSSA->isLiveOnEntryDef(StartingUseOrDef))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">    if (MSSA->isLiveOnEntryDef(StartingUseOrDef))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">      return StartingUseOrDef;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">      return StartingUseOrDef;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">    I = StartingUseOrDef->getMemoryInst();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">    I = StartingUseOrDef->getMemoryInst();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">    // Conservatively, fences are always clobbers, so don't perform the walk if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">    // Conservatively, fences are always clobbers, so don't perform the walk if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">    // we hit a fence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">    // we hit a fence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">    if (!isa<CallBase>(I) && I->isFenceLike())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">    if (!isa<CallBase>(I) && I->isFenceLike())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine">      return StartingUseOrDef;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine">      return StartingUseOrDef;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine">  UpwardsMemoryQuery Q;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine">  UpwardsMemoryQuery Q;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">  Q.OriginalAccess = StartingAccess;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">  Q.OriginalAccess = StartingAccess;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">  Q.StartingLoc = Loc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">  Q.StartingLoc = Loc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">  Q.Inst = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">  Q.Inst = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">  Q.IsCall = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">  Q.IsCall = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">  // Unlike the other function, do not walk to the def of a def, because we are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">  // Unlike the other function, do not walk to the def of a def, because we are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">  // handed something we already believe is the clobbering access.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">  // handed something we already believe is the clobbering access.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">  // We never set SkipSelf to true in Q in this method.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">  // We never set SkipSelf to true in Q in this method.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">  MemoryAccess *Clobber =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">  MemoryAccess *Clobber =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">      Walker.findClobber(BAA, StartingAccess, Q, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">      Walker.findClobber(BAA, StartingAccess, Q, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">    dbgs() << "Clobber starting at access " << *StartingAccess << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">    dbgs() << "Clobber starting at access " << *StartingAccess << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">    if (I)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">    if (I)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">      dbgs() << "  for instruction " << *I << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">      dbgs() << "  for instruction " << *I << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">    dbgs() << "  is " << *Clobber << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">    dbgs() << "  is " << *Clobber << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">  return Clobber;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">  return Clobber;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">static const Instruction *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">static const Instruction *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">getInvariantGroupClobberingInstruction(Instruction &I, DominatorTree &DT) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">getInvariantGroupClobberingInstruction(Instruction &I, DominatorTree &DT) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">  if (!I.hasMetadata(LLVMContext::MD_invariant_group) || I.isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">  if (!I.hasMetadata(LLVMContext::MD_invariant_group) || I.isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">  // We consider bitcasts and zero GEPs to be the same pointer value. Start by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">  // We consider bitcasts and zero GEPs to be the same pointer value. Start by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">  // stripping bitcasts and zero GEPs, then we will recursively look at loads</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">  // stripping bitcasts and zero GEPs, then we will recursively look at loads</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">  // and stores through bitcasts and zero GEPs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">  // and stores through bitcasts and zero GEPs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">  Value *PointerOperand = getLoadStorePointerOperand(&I)->stripPointerCasts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">  Value *PointerOperand = getLoadStorePointerOperand(&I)->stripPointerCasts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">  // It's not safe to walk the use list of a global value because function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">  // It's not safe to walk the use list of a global value because function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">  // passes aren't allowed to look outside their functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">  // passes aren't allowed to look outside their functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">  // FIXME: this could be fixed by filtering instructions from outside of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">  // FIXME: this could be fixed by filtering instructions from outside of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">  // current function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">  // current function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">  if (isa<Constant>(PointerOperand))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">  if (isa<Constant>(PointerOperand))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">  // Queue to process all pointers that are equivalent to load operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">  // Queue to process all pointers that are equivalent to load operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">  SmallVector<const Value *, 8> PointerUsesQueue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">  SmallVector<const Value *, 8> PointerUsesQueue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">  PointerUsesQueue.push_back(PointerOperand);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">  PointerUsesQueue.push_back(PointerOperand);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">  const Instruction *MostDominatingInstruction = &I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">  const Instruction *MostDominatingInstruction = &I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">  // FIXME: This loop is O(n^2) because dominates can be O(n) and in worst case</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">  // FIXME: This loop is O(n^2) because dominates can be O(n) and in worst case</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">  // we will see all the instructions. It may not matter in practice. If it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">  // we will see all the instructions. It may not matter in practice. If it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">  // does, we will have to support MemorySSA construction and updates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">  // does, we will have to support MemorySSA construction and updates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">  while (!PointerUsesQueue.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">  while (!PointerUsesQueue.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine">    const Value *Ptr = PointerUsesQueue.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine">    const Value *Ptr = PointerUsesQueue.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">    assert(Ptr && !isa<GlobalValue>(Ptr) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">    assert(Ptr && !isa<GlobalValue>(Ptr) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">           "Null or GlobalValue should not be inserted");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">           "Null or GlobalValue should not be inserted");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">    for (const User *Us : Ptr->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">    for (const User *Us : Ptr->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">      auto *U = dyn_cast<Instruction>(Us);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">      auto *U = dyn_cast<Instruction>(Us);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">      if (!U || U == &I || !DT.dominates(U, MostDominatingInstruction))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">      if (!U || U == &I || !DT.dominates(U, MostDominatingInstruction))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">      // Add bitcasts and zero GEPs to queue.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">      // Add bitcasts and zero GEPs to queue.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine">      if (isa<BitCastInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine">      if (isa<BitCastInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">        PointerUsesQueue.push_back(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">        PointerUsesQueue.push_back(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">      if (auto *GEP = dyn_cast<GetElementPtrInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">        if (GEP->hasAllZeroIndices())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">        if (GEP->hasAllZeroIndices())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">          PointerUsesQueue.push_back(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">          PointerUsesQueue.push_back(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">      // If we hit a load/store with an invariant.group metadata and the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">      // If we hit a load/store with an invariant.group metadata and the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">      // pointer operand, we can assume that value pointed to by the pointer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">      // pointer operand, we can assume that value pointed to by the pointer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine">      // operand didn't change.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine">      // operand didn't change.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine">      if (U->hasMetadata(LLVMContext::MD_invariant_group) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine">      if (U->hasMetadata(LLVMContext::MD_invariant_group) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine">          getLoadStorePointerOperand(U) == Ptr && !U->isVolatile()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine">          getLoadStorePointerOperand(U) == Ptr && !U->isVolatile()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine">        MostDominatingInstruction = U;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine">        MostDominatingInstruction = U;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine">  return MostDominatingInstruction == &I ? nullptr : MostDominatingInstruction;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine">  return MostDominatingInstruction == &I ? nullptr : MostDominatingInstruction;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine">MemoryAccess *MemorySSA::ClobberWalkerBase::getClobberingMemoryAccessBase(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine">MemoryAccess *MemorySSA::ClobberWalkerBase::getClobberingMemoryAccessBase(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">    MemoryAccess *MA, BatchAAResults &BAA, unsigned &UpwardWalkLimit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">    MemoryAccess *MA, BatchAAResults &BAA, unsigned &UpwardWalkLimit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine">    bool SkipSelf, bool UseInvariantGroup) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine">    bool SkipSelf, bool UseInvariantGroup) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">  auto *StartingAccess = dyn_cast<MemoryUseOrDef>(MA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">  auto *StartingAccess = dyn_cast<MemoryUseOrDef>(MA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">  // If this is a MemoryPhi, we can't do anything.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">  // If this is a MemoryPhi, we can't do anything.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine">  if (!StartingAccess)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine">  if (!StartingAccess)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">    return MA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">    return MA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine">  if (UseInvariantGroup) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine">  if (UseInvariantGroup) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">    if (auto *I = getInvariantGroupClobberingInstruction(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">    if (auto *I = getInvariantGroupClobberingInstruction(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine">            *StartingAccess->getMemoryInst(), MSSA->getDomTree())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine">            *StartingAccess->getMemoryInst(), MSSA->getDomTree())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">      assert(isa<LoadInst>(I) || isa<StoreInst>(I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">      assert(isa<LoadInst>(I) || isa<StoreInst>(I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">      auto *ClobberMA = MSSA->getMemoryAccess(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">      auto *ClobberMA = MSSA->getMemoryAccess(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine">      assert(ClobberMA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine">      assert(ClobberMA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">      if (isa<MemoryUse>(ClobberMA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">      if (isa<MemoryUse>(ClobberMA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine">        return ClobberMA->getDefiningAccess();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine">        return ClobberMA->getDefiningAccess();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">      return ClobberMA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">      return ClobberMA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">  bool IsOptimized = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">  bool IsOptimized = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">  // If this is an already optimized use or def, return the optimized result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">  // If this is an already optimized use or def, return the optimized result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine">  // Note: Currently, we store the optimized def result in a separate field,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine">  // Note: Currently, we store the optimized def result in a separate field,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine">  // since we can't use the defining access.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine">  // since we can't use the defining access.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine">  if (StartingAccess->isOptimized()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine">  if (StartingAccess->isOptimized()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine">    if (!SkipSelf || !isa<MemoryDef>(StartingAccess))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine">    if (!SkipSelf || !isa<MemoryDef>(StartingAccess))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine">      return StartingAccess->getOptimized();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine">      return StartingAccess->getOptimized();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">    IsOptimized = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">    IsOptimized = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">  const Instruction *I = StartingAccess->getMemoryInst();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">  const Instruction *I = StartingAccess->getMemoryInst();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine">  // We can't sanely do anything with a fence, since they conservatively clobber</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine">  // We can't sanely do anything with a fence, since they conservatively clobber</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">  // all memory, and have no locations to get pointers from to try to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">  // all memory, and have no locations to get pointers from to try to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine">  // disambiguate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine">  // disambiguate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine">  if (!isa<CallBase>(I) && I->isFenceLike())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine">  if (!isa<CallBase>(I) && I->isFenceLike())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine">    return StartingAccess;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine">    return StartingAccess;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine">  UpwardsMemoryQuery Q(I, StartingAccess);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine">  UpwardsMemoryQuery Q(I, StartingAccess);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">  if (isUseTriviallyOptimizableToLiveOnEntry(BAA, I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">  if (isUseTriviallyOptimizableToLiveOnEntry(BAA, I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine">    MemoryAccess *LiveOnEntry = MSSA->getLiveOnEntryDef();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine">    MemoryAccess *LiveOnEntry = MSSA->getLiveOnEntryDef();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">    StartingAccess->setOptimized(LiveOnEntry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">    StartingAccess->setOptimized(LiveOnEntry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">    return LiveOnEntry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">    return LiveOnEntry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">  MemoryAccess *OptimizedAccess;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">  MemoryAccess *OptimizedAccess;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">  if (!IsOptimized) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">  if (!IsOptimized) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine">    // Start with the thing we already think clobbers this location</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine">    // Start with the thing we already think clobbers this location</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine">    MemoryAccess *DefiningAccess = StartingAccess->getDefiningAccess();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine">    MemoryAccess *DefiningAccess = StartingAccess->getDefiningAccess();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine">    // At this point, DefiningAccess may be the live on entry def.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine">    // At this point, DefiningAccess may be the live on entry def.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine">    // If it is, we will not get a better result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine">    // If it is, we will not get a better result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine">    if (MSSA->isLiveOnEntryDef(DefiningAccess)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine">    if (MSSA->isLiveOnEntryDef(DefiningAccess)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine">      StartingAccess->setOptimized(DefiningAccess);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine">      StartingAccess->setOptimized(DefiningAccess);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine">      return DefiningAccess;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine">      return DefiningAccess;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine">    OptimizedAccess =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine">    OptimizedAccess =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine">        Walker.findClobber(BAA, DefiningAccess, Q, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine">        Walker.findClobber(BAA, DefiningAccess, Q, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine">    StartingAccess->setOptimized(OptimizedAccess);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine">    StartingAccess->setOptimized(OptimizedAccess);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine">    OptimizedAccess = StartingAccess->getOptimized();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine">    OptimizedAccess = StartingAccess->getOptimized();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Starting Memory SSA clobber for " << *I << " is ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Starting Memory SSA clobber for " << *I << " is ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << *StartingAccess << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << *StartingAccess << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Optimized Memory SSA clobber for " << *I << " is ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Optimized Memory SSA clobber for " << *I << " is ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << *OptimizedAccess << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << *OptimizedAccess << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine">  MemoryAccess *Result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine">  MemoryAccess *Result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine">  if (SkipSelf && isa<MemoryPhi>(OptimizedAccess) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine">  if (SkipSelf && isa<MemoryPhi>(OptimizedAccess) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine">      isa<MemoryDef>(StartingAccess) && UpwardWalkLimit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine">      isa<MemoryDef>(StartingAccess) && UpwardWalkLimit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine">    assert(isa<MemoryDef>(Q.OriginalAccess));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine">    assert(isa<MemoryDef>(Q.OriginalAccess));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine">    Q.SkipSelfAccess = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine">    Q.SkipSelfAccess = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine">    Result = Walker.findClobber(BAA, OptimizedAccess, Q, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine">    Result = Walker.findClobber(BAA, OptimizedAccess, Q, UpwardWalkLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine">    Result = OptimizedAccess;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine">    Result = OptimizedAccess;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Result Memory SSA clobber [SkipSelf = " << SkipSelf);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Result Memory SSA clobber [SkipSelf = " << SkipSelf);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "] for " << *I << " is " << *Result << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "] for " << *I << " is " << *Result << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine">MemoryAccess *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine">MemoryAccess *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine">DoNothingMemorySSAWalker::getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine">DoNothingMemorySSAWalker::getClobberingMemoryAccess(MemoryAccess *MA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine">                                                    BatchAAResults &) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine">                                                    BatchAAResults &) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine">  if (auto *Use = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine">  if (auto *Use = dyn_cast<MemoryUseOrDef>(MA))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine">    return Use->getDefiningAccess();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine">    return Use->getDefiningAccess();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine">  return MA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine">  return MA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeLine">MemoryAccess *DoNothingMemorySSAWalker::getClobberingMemoryAccess(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2578</td>
    <td class="codeLine">MemoryAccess *DoNothingMemorySSAWalker::getClobberingMemoryAccess(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeLine">    MemoryAccess *StartingAccess, const MemoryLocation &, BatchAAResults &) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2579</td>
    <td class="codeLine">    MemoryAccess *StartingAccess, const MemoryLocation &, BatchAAResults &) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeLine">  if (auto *Use = dyn_cast<MemoryUseOrDef>(StartingAccess))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2580</td>
    <td class="codeLine">  if (auto *Use = dyn_cast<MemoryUseOrDef>(StartingAccess))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeLine">    return Use->getDefiningAccess();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2581</td>
    <td class="codeLine">    return Use->getDefiningAccess();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeLine">  return StartingAccess;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2582</td>
    <td class="codeLine">  return StartingAccess;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2583</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeLine">void MemoryPhi::deleteMe(DerivedUser *Self) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2585</td>
    <td class="codeLine">void MemoryPhi::deleteMe(DerivedUser *Self) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeLine">  delete static_cast<MemoryPhi *>(Self);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2586</td>
    <td class="codeLine">  delete static_cast<MemoryPhi *>(Self);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2587</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeLine">void MemoryDef::deleteMe(DerivedUser *Self) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2589</td>
    <td class="codeLine">void MemoryDef::deleteMe(DerivedUser *Self) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeLine">  delete static_cast<MemoryDef *>(Self);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2590</td>
    <td class="codeLine">  delete static_cast<MemoryDef *>(Self);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2591</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeLine">void MemoryUse::deleteMe(DerivedUser *Self) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2593</td>
    <td class="codeLine">void MemoryUse::deleteMe(DerivedUser *Self) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeLine">  delete static_cast<MemoryUse *>(Self);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2594</td>
    <td class="codeLine">  delete static_cast<MemoryUse *>(Self);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2595</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeLine">bool upward_defs_iterator::IsGuaranteedLoopInvariant(const Value *Ptr) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2597</td>
    <td class="codeLine">bool upward_defs_iterator::IsGuaranteedLoopInvariant(const Value *Ptr) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeLine">  auto IsGuaranteedLoopInvariantBase = [](const Value *Ptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2598</td>
    <td class="codeLine">  auto IsGuaranteedLoopInvariantBase = [](const Value *Ptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeLine">    Ptr = Ptr->stripPointerCasts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2599</td>
    <td class="codeLine">    Ptr = Ptr->stripPointerCasts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeLine">    if (!isa<Instruction>(Ptr))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2600</td>
    <td class="codeLine">    if (!isa<Instruction>(Ptr))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2601</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeLine">    return isa<AllocaInst>(Ptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2602</td>
    <td class="codeLine">    return isa<AllocaInst>(Ptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2603</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeLine">  Ptr = Ptr->stripPointerCasts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2605</td>
    <td class="codeLine">  Ptr = Ptr->stripPointerCasts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeLine">  if (auto *I = dyn_cast<Instruction>(Ptr)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2606</td>
    <td class="codeLine">  if (auto *I = dyn_cast<Instruction>(Ptr)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeLine">    if (I->getParent()->isEntryBlock())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2607</td>
    <td class="codeLine">    if (I->getParent()->isEntryBlock())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2608</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2609</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeLine">  if (auto *GEP = dyn_cast<GEPOperator>(Ptr)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2610</td>
    <td class="codeLine">  if (auto *GEP = dyn_cast<GEPOperator>(Ptr)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeLine">    return IsGuaranteedLoopInvariantBase(GEP->getPointerOperand()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2611</td>
    <td class="codeLine">    return IsGuaranteedLoopInvariantBase(GEP->getPointerOperand()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeLine">           GEP->hasAllConstantIndices();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2612</td>
    <td class="codeLine">           GEP->hasAllConstantIndices();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeLine">  return IsGuaranteedLoopInvariantBase(Ptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2614</td>
    <td class="codeLine">  return IsGuaranteedLoopInvariantBase(Ptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2615</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>