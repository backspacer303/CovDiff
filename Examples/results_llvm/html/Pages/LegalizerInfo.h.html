<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>LegalizerInfo.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- llvm/CodeGen/GlobalISel/LegalizerInfo.h ------------------*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">/// \file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">/// Interface for Targets to specify which operations they can successfully</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// select and how the others should be expanded most efficiently.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#ifndef LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#define LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/ADT/SmallBitVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/CodeGen/LowLevelType.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/CodeGen/MachineMemOperand.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/CodeGen/TargetOpcodes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/MC/MCInstrDesc.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/Support/AtomicOrdering.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include <tuple></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">extern cl::opt<bool> DisableGISelLegalityCheck;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">class MachineFunction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">class raw_ostream;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">class LegalizerHelper;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">class MachineInstr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">class MachineRegisterInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">class MCInstrInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">namespace LegalizeActions {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">enum LegalizeAction : std::uint8_t {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">  /// The operation is expected to be selectable directly by the target, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">  /// no transformation is necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">  Legal,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">  /// The operation should be synthesized from multiple instructions acting on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">  /// a narrower scalar base-type. For example a 64-bit add might be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">  /// implemented in terms of 32-bit add-with-carry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">  NarrowScalar,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">  /// The operation should be implemented in terms of a wider scalar</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">  /// base-type. For example a <2 x s8> add could be implemented as a <2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">  /// x s32> add (ignoring the high bits).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">  WidenScalar,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">  /// The (vector) operation should be implemented by splitting it into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">  /// sub-vectors where the operation is legal. For example a <8 x s64> add</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">  /// might be implemented as 4 separate <2 x s64> adds. There can be a leftover</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">  /// if there are not enough elements for last sub-vector e.g. <7 x s64> add</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">  /// will be implemented as 3 separate <2 x s64> adds and one s64 add. Leftover</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">  /// types can be avoided by doing MoreElements first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">  FewerElements,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">  /// The (vector) operation should be implemented by widening the input</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">  /// vector and ignoring the lanes added by doing so. For example <2 x i8> is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">  /// rarely legal, but you might perform an <8 x i8> and then only look at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">  /// the first two results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">  MoreElements,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">  /// Perform the operation on a different, but equivalently sized type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">  Bitcast,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">  /// The operation itself must be expressed in terms of simpler actions on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">  /// this target. E.g. a SREM replaced by an SDIV and subtraction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">  Lower,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">  /// The operation should be implemented as a call to some kind of runtime</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">  /// support library. For example this usually happens on machines that don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">  /// support floating-point operations natively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">  Libcall,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">  /// The target wants to do something special with this combination of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">  /// operand and type. A callback will be issued when it is needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">  Custom,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">  /// This operation is completely unsupported on the target. A programming</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">  /// error has occurred.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">  Unsupported,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">  /// Sentinel value for when no action was found in the specified table.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">  NotFound,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">  /// Fall back onto the old rules.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">  /// TODO: Remove this once we've migrated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">  UseLegacyRules,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">} // end namespace LegalizeActions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">raw_ostream &operator<<(raw_ostream &OS, LegalizeActions::LegalizeAction Action);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">using LegalizeActions::LegalizeAction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">/// The LegalityQuery object bundles together all the information that's needed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">/// to decide whether a given operation is legal or not.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">/// For efficiency, it doesn't make a copy of Types so care must be taken not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">/// to free it before using the query.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">struct LegalityQuery {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">  unsigned Opcode;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">  ArrayRef<LLT> Types;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">  struct MemDesc {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">    LLT MemoryTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">    uint64_t AlignInBits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">    AtomicOrdering Ordering;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">    MemDesc() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">    MemDesc(LLT MemoryTy, uint64_t AlignInBits, AtomicOrdering Ordering)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">        : MemoryTy(MemoryTy), AlignInBits(AlignInBits), Ordering(Ordering) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="uncoveredLine">    MemDesc(const MachineMemOperand &MMO)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="uncoveredLine">        : MemoryTy(MMO.getMemoryType()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="uncoveredLine">          AlignInBits(MMO.getAlign().value() * 8),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="uncoveredLine">          Ordering(MMO.getSuccessOrdering()) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">  /// Operations which require memory can use this to place requirements on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">  /// memory type for each MMO.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">  ArrayRef<MemDesc> MMODescrs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="uncoveredLine">  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">                          const ArrayRef<MemDesc> MMODescrs)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="uncoveredLine">      : Opcode(Opcode), Types(Types), MMODescrs(MMODescrs) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">      : LegalityQuery(Opcode, Types, {}) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">  raw_ostream &print(raw_ostream &OS) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">/// The result of a query. It either indicates a final answer of Legal or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">/// Unsupported or describes an action that must be taken to make an operation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">/// more legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">struct LegalizeActionStep {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">  /// The action to take or the final answer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">  LegalizeAction Action;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">  /// If describing an action, the type index to change. Otherwise zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">  unsigned TypeIdx;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">  /// If describing an action, the new type for TypeIdx. Otherwise LLT{}.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">  LLT NewType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="uncoveredLine">  LegalizeActionStep(LegalizeAction Action, unsigned TypeIdx,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">                     const LLT NewType)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="uncoveredLine">      : Action(Action), TypeIdx(TypeIdx), NewType(NewType) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="uncoveredLine">  LegalizeActionStep(LegacyLegalizeActionStep Step)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="uncoveredLine">      : TypeIdx(Step.TypeIdx), NewType(Step.NewType) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="uncoveredLine">    switch (Step.Action) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="uncoveredLine">    case LegacyLegalizeActions::Legal:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="uncoveredLine">      Action = LegalizeActions::Legal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="uncoveredLine">    case LegacyLegalizeActions::NarrowScalar:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="uncoveredLine">      Action = LegalizeActions::NarrowScalar;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="uncoveredLine">    case LegacyLegalizeActions::WidenScalar:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="uncoveredLine">      Action = LegalizeActions::WidenScalar;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="uncoveredLine">    case LegacyLegalizeActions::FewerElements:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="uncoveredLine">      Action = LegalizeActions::FewerElements;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">    case LegacyLegalizeActions::MoreElements:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">      Action = LegalizeActions::MoreElements;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="uncoveredLine">    case LegacyLegalizeActions::Bitcast:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="uncoveredLine">      Action = LegalizeActions::Bitcast;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="uncoveredLine">    case LegacyLegalizeActions::Lower:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="uncoveredLine">      Action = LegalizeActions::Lower;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="uncoveredLine">    case LegacyLegalizeActions::Libcall:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="uncoveredLine">      Action = LegalizeActions::Libcall;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="uncoveredLine">    case LegacyLegalizeActions::Custom:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="uncoveredLine">      Action = LegalizeActions::Custom;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="uncoveredLine">    case LegacyLegalizeActions::Unsupported:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="uncoveredLine">      Action = LegalizeActions::Unsupported;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="uncoveredLine">    case LegacyLegalizeActions::NotFound:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="uncoveredLine">      Action = LegalizeActions::NotFound;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">  bool operator==(const LegalizeActionStep &RHS) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">    return std::tie(Action, TypeIdx, NewType) ==</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">        std::tie(RHS.Action, RHS.TypeIdx, RHS.NewType);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">using LegalityPredicate = std::function<bool (const LegalityQuery &)>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">using LegalizeMutation =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">    std::function<std::pair<unsigned, LLT>(const LegalityQuery &)>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">namespace LegalityPredicates {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">struct TypePairAndMemDesc {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  LLT Type0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">  LLT Type1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">  LLT MemTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">  uint64_t Align;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">  bool operator==(const TypePairAndMemDesc &Other) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">    return Type0 == Other.Type0 && Type1 == Other.Type1 &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">           Align == Other.Align && MemTy == Other.MemTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">  /// \returns true if this memory access is legal with for the access described</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">  /// by \p Other (The alignment is sufficient for the size and result type).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">  bool isCompatible(const TypePairAndMemDesc &Other) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">    return Type0 == Other.Type0 && Type1 == Other.Type1 &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">           Align >= Other.Align &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">           // FIXME: This perhaps should be stricter, but the current legality</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">           // rules are written only considering the size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">           MemTy.getSizeInBits() == Other.MemTy.getSizeInBits();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">/// True iff P0 and P1 are true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">template<typename Predicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="coveredLine">Predicate all(Predicate P0, Predicate P1) {</td>
    <td>100</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">  return [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="uncoveredLine">    return P0(Query) && P1(Query);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="coveredLine">  };</td>
    <td>100</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">/// True iff all given predicates are true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">template<typename Predicate, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">Predicate all(Predicate P0, Predicate P1, Args... args) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">  return all(all(P0, P1), args...);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">/// True iff P0 or P1 are true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">template<typename Predicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">Predicate any(Predicate P0, Predicate P1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">  return [=](const LegalityQuery &Query) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">    return P0(Query) || P1(Query);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">/// True iff any given predicates are true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">template<typename Predicate, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">Predicate any(Predicate P0, Predicate P1, Args... args) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">  return any(any(P0, P1), args...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">/// True iff the given type index is the specified type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">LegalityPredicate typeIs(unsigned TypeIdx, LLT TypesInit);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">/// True iff the given type index is one of the specified types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">LegalityPredicate typeInSet(unsigned TypeIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">                            std::initializer_list<LLT> TypesInit);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">/// True iff the given type index is not the specified type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="uncoveredLine">inline LegalityPredicate typeIsNot(unsigned TypeIdx, LLT Type) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">  return [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="uncoveredLine">           return Query.Types[TypeIdx] != Type;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="uncoveredLine">         };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">/// True iff the given types for the given pair of type indexes is one of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">/// specified type pairs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">LegalityPredicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">typePairInSet(unsigned TypeIdx0, unsigned TypeIdx1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">              std::initializer_list<std::pair<LLT, LLT>> TypesInit);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">/// True iff the given types for the given pair of type indexes is one of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">/// specified type pairs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">LegalityPredicate typePairAndMemDescInSet(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">    unsigned TypeIdx0, unsigned TypeIdx1, unsigned MMOIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">    std::initializer_list<TypePairAndMemDesc> TypesAndMemDescInit);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">/// True iff the specified type index is a scalar.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">LegalityPredicate isScalar(unsigned TypeIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">/// True iff the specified type index is a vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">LegalityPredicate isVector(unsigned TypeIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">/// True iff the specified type index is a pointer (with any address space).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">LegalityPredicate isPointer(unsigned TypeIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">/// True iff the specified type index is a pointer with the specified address</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">/// space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">LegalityPredicate isPointer(unsigned TypeIdx, unsigned AddrSpace);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">/// True if the type index is a vector with element type \p EltTy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">LegalityPredicate elementTypeIs(unsigned TypeIdx, LLT EltTy);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">/// True iff the specified type index is a scalar that's narrower than the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">/// size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">LegalityPredicate scalarNarrowerThan(unsigned TypeIdx, unsigned Size);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">/// True iff the specified type index is a scalar that's wider than the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">/// size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">LegalityPredicate scalarWiderThan(unsigned TypeIdx, unsigned Size);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">/// True iff the specified type index is a scalar or vector with an element type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">/// that's narrower than the given size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">LegalityPredicate scalarOrEltNarrowerThan(unsigned TypeIdx, unsigned Size);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">/// True iff the specified type index is a scalar or a vector with an element</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">/// type that's wider than the given size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">LegalityPredicate scalarOrEltWiderThan(unsigned TypeIdx, unsigned Size);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="">/// True iff the specified type index is a scalar whose size is not a multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">/// of Size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">LegalityPredicate sizeNotMultipleOf(unsigned TypeIdx, unsigned Size);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">/// True iff the specified type index is a scalar whose size is not a power of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">/// 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">LegalityPredicate sizeNotPow2(unsigned TypeIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">/// True iff the specified type index is a scalar or vector whose element size</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">/// is not a power of 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">LegalityPredicate scalarOrEltSizeNotPow2(unsigned TypeIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">/// True if the total bitwidth of the specified type index is \p Size bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">LegalityPredicate sizeIs(unsigned TypeIdx, unsigned Size);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">/// True iff the specified type indices are both the same bit size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">LegalityPredicate sameSize(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">/// True iff the first type index has a larger total bit size than second type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">/// index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">LegalityPredicate largerThan(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">/// True iff the first type index has a smaller total bit size than second type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">/// index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">LegalityPredicate smallerThan(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">/// True iff the specified MMO index has a size (rounded to bytes) that is not a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">/// power of 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">LegalityPredicate memSizeInBytesNotPow2(unsigned MMOIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">/// True iff the specified MMO index has a size that is not an even byte size,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">/// or that even byte size is not a power of 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">LegalityPredicate memSizeNotByteSizePow2(unsigned MMOIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">/// True iff the specified type index is a vector whose element count is not a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">/// power of 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">LegalityPredicate numElementsNotPow2(unsigned TypeIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">/// True iff the specified MMO index has at an atomic ordering of at Ordering or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">/// stronger.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">LegalityPredicate atomicOrderingAtLeastOrStrongerThan(unsigned MMOIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">                                                      AtomicOrdering Ordering);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">} // end namespace LegalityPredicates</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">namespace LegalizeMutations {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">/// Select this specific type for the given type index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">LegalizeMutation changeTo(unsigned TypeIdx, LLT Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">/// Keep the same type as the given type index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">LegalizeMutation changeTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">/// Keep the same scalar or element type as the given type index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">LegalizeMutation changeElementTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">/// Keep the same scalar or element type as the given type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">LegalizeMutation changeElementTo(unsigned TypeIdx, LLT Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">/// Keep the same scalar or element type as \p TypeIdx, but take the number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">/// elements from \p FromTypeIdx.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">LegalizeMutation changeElementCountTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">/// Keep the same scalar or element type as \p TypeIdx, but take the number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">/// elements from \p Ty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">LegalizeMutation changeElementCountTo(unsigned TypeIdx, LLT Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">/// Change the scalar size or element size to have the same scalar size as type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">/// index \p FromIndex. Unlike changeElementTo, this discards pointer types and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">/// only changes the size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">LegalizeMutation changeElementSizeTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">/// Widen the scalar type or vector element type for the given type index to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">/// next power of 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">LegalizeMutation widenScalarOrEltToNextPow2(unsigned TypeIdx, unsigned Min = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="">/// Widen the scalar type or vector element type for the given type index to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">/// next multiple of \p Size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">LegalizeMutation widenScalarOrEltToNextMultipleOf(unsigned TypeIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">                                                  unsigned Size);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">/// Add more elements to the type for the given type index to the next power of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">/// 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">LegalizeMutation moreElementsToNextPow2(unsigned TypeIdx, unsigned Min = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">/// Break up the vector type for the given type index into the element type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">LegalizeMutation scalarize(unsigned TypeIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">} // end namespace LegalizeMutations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="">/// A single rule in a legalizer info ruleset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">/// The specified action is chosen when the predicate is true. Where appropriate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">/// for the action (e.g. for WidenScalar) the new type is selected using the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">/// given mutator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">class LegalizeRule {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">  LegalityPredicate Predicate;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">  LegalizeAction Action;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">  LegalizeMutation Mutation;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="coveredLine">  LegalizeRule(LegalityPredicate Predicate, LegalizeAction Action,</td>
    <td>920</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">               LegalizeMutation Mutation = nullptr)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="coveredLine">      : Predicate(Predicate), Action(Action), Mutation(Mutation) {}</td>
    <td>920</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">  /// Test whether the LegalityQuery matches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">  bool match(const LegalityQuery &Query) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">    return Predicate(Query);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">  LegalizeAction getAction() const { return Action; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">  /// Determine the change to make.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="uncoveredLine">  std::pair<unsigned, LLT> determineMutation(const LegalityQuery &Query) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">    if (Mutation)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">      return Mutation(Query);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">    return std::make_pair(0, LLT{});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">class LegalizeRuleSet {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">  /// When non-zero, the opcode we are an alias of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">  unsigned AliasOf = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">  /// If true, there is another opcode that aliases this one</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">  bool IsAliasedByAnother = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">  SmallVector<LegalizeRule, 2> Rules;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  /// If bit I is set, this rule set contains a rule that may handle (predicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">  /// or perform an action upon (or both)) the type index I. The uncertainty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">  /// comes from free-form rules executing user-provided lambda functions. We</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">  /// conservatively assume such rules do the right thing and cover all type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  /// indices. The bitset is intentionally 1 bit wider than it absolutely needs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">  /// to be to distinguish such cases from the cases where all type indices are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">  /// individually handled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">  SmallBitVector TypeIdxsCovered{MCOI::OPERAND_LAST_GENERIC -</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">                                 MCOI::OPERAND_FIRST_GENERIC + 2};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">  SmallBitVector ImmIdxsCovered{MCOI::OPERAND_LAST_GENERIC_IMM -</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">                                MCOI::OPERAND_FIRST_GENERIC_IMM + 2};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="coveredLine">  unsigned typeIdx(unsigned TypeIdx) {</td>
    <td>1070</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="coveredLine">    assert(TypeIdx <=</td>
    <td>1070</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">               (MCOI::OPERAND_LAST_GENERIC - MCOI::OPERAND_FIRST_GENERIC) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">           "Type Index is out of bounds");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="coveredLine">    TypeIdxsCovered.set(TypeIdx);</td>
    <td>1070</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="coveredLine">    return TypeIdx;</td>
    <td>1070</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="coveredLine">  void markAllIdxsAsCovered() {</td>
    <td>120</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="coveredLine">    TypeIdxsCovered.set();</td>
    <td>120</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="coveredLine">    ImmIdxsCovered.set();</td>
    <td>120</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="coveredLine">  }</td>
    <td>120</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="coveredLine">  void add(const LegalizeRule &Rule) {</td>
    <td>920</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="coveredLine">    assert(AliasOf == 0 &&</td>
    <td>920</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">           "RuleSet is aliased, change the representative opcode instead");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="coveredLine">    Rules.push_back(Rule);</td>
    <td>920</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="coveredLine">  }</td>
    <td>920</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">  static bool always(const LegalityQuery &) { return true; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">  /// Use the given action when the predicate is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">  /// Action should not be an action that requires mutation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="coveredLine">  LegalizeRuleSet &actionIf(LegalizeAction Action,</td>
    <td>530</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">                            LegalityPredicate Predicate) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="coveredLine">    add({Predicate, Action});</td>
    <td>530</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="coveredLine">    return *this;</td>
    <td>530</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">  /// Use the given action when the predicate is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  /// Action should be an action that requires mutation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="coveredLine">  LegalizeRuleSet &actionIf(LegalizeAction Action, LegalityPredicate Predicate,</td>
    <td>390</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">                            LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="coveredLine">    add({Predicate, Action, Mutation});</td>
    <td>390</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="coveredLine">    return *this;</td>
    <td>390</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">  /// Use the given action when type index 0 is any type in the given list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  /// Action should not be an action that requires mutation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="coveredLine">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td>140</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">                             std::initializer_list<LLT> Types) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="coveredLine">    return actionIf(Action, typeInSet(typeIdx(0), Types));</td>
    <td>140</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">  /// Use the given action when type index 0 is any type in the given list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">  /// Action should be an action that requires mutation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="">                             std::initializer_list<LLT> Types,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">                             LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">    return actionIf(Action, typeInSet(typeIdx(0), Types), Mutation);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">  /// Use the given action when type indexes 0 and 1 is any type pair in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">  /// given list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">  /// Action should not be an action that requires mutation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="coveredLine">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td>160</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">                             std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="coveredLine">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));</td>
    <td>160</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">  /// Use the given action when type indexes 0 and 1 is any type pair in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">  /// given list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">  /// Action should be an action that requires mutation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="uncoveredLine">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">                             std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">                             LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">                    Mutation);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  /// Use the given action when type index 0 is any type in the given list and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">  /// imm index 0 is anything. Action should not be an action that requires</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">  /// mutation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">  LegalizeRuleSet &actionForTypeWithAnyImm(LegalizeAction Action,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">                                           std::initializer_list<LLT> Types) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">    immIdx(0); // Inform verifier imm idx 0 is handled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">    return actionIf(Action, typeInSet(typeIdx(0), Types));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">  LegalizeRuleSet &actionForTypeWithAnyImm(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">    LegalizeAction Action, std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">    immIdx(0); // Inform verifier imm idx 0 is handled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">  /// Use the given action when type indexes 0 and 1 are both in the given list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">  /// That is, the type pair is in the cartesian product of the list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">  /// Action should not be an action that requires mutation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">  LegalizeRuleSet &actionForCartesianProduct(LegalizeAction Action,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">                                             std::initializer_list<LLT> Types) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">    return actionIf(Action, all(typeInSet(typeIdx(0), Types),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">                                typeInSet(typeIdx(1), Types)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">  /// Use the given action when type indexes 0 and 1 are both in their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">  /// respective lists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">  /// That is, the type pair is in the cartesian product of the lists</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">  /// Action should not be an action that requires mutation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">  LegalizeRuleSet &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="coveredLine">  actionForCartesianProduct(LegalizeAction Action,</td>
    <td>100</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">                            std::initializer_list<LLT> Types0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">                            std::initializer_list<LLT> Types1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="coveredLine">    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),</td>
    <td>200</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="coveredLine">                                typeInSet(typeIdx(1), Types1)));</td>
    <td>300</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">  /// Use the given action when type indexes 0, 1, and 2 are all in their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">  /// respective lists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">  /// That is, the type triple is in the cartesian product of the lists</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">  /// Action should not be an action that requires mutation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="uncoveredLine">  LegalizeRuleSet &actionForCartesianProduct(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">      LegalizeAction Action, std::initializer_list<LLT> Types0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">      std::initializer_list<LLT> Types1, std::initializer_list<LLT> Types2) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="uncoveredLine">    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="uncoveredLine">                                all(typeInSet(typeIdx(1), Types1),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="uncoveredLine">                                    typeInSet(typeIdx(2), Types2))));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="coveredLine">  LegalizeRuleSet() = default;</td>
    <td>2100</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="coveredLine">  bool isAliasedByAnother() { return IsAliasedByAnother; }</td>
    <td>450</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="coveredLine">  void setIsAliasedByAnother() { IsAliasedByAnother = true; }</td>
    <td>130</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="coveredLine">  void aliasTo(unsigned Opcode) {</td>
    <td>270</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="coveredLine">    assert((AliasOf == 0 || AliasOf == Opcode) &&</td>
    <td>270</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">           "Opcode is already aliased to another opcode");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="coveredLine">    assert(Rules.empty() && "Aliasing will discard rules");</td>
    <td>270</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="coveredLine">    AliasOf = Opcode;</td>
    <td>270</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="coveredLine">  }</td>
    <td>270</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="coveredLine">  unsigned getAlias() const { return AliasOf; }</td>
    <td>2820</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="uncoveredLine">  unsigned immIdx(unsigned ImmIdx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">    assert(ImmIdx <= (MCOI::OPERAND_LAST_GENERIC_IMM -</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">                      MCOI::OPERAND_FIRST_GENERIC_IMM) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">           "Imm Index is out of bounds");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">    ImmIdxsCovered.set(ImmIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="uncoveredLine">    return ImmIdx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">  /// The instruction is legal if predicate is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="coveredLine">  LegalizeRuleSet &legalIf(LegalityPredicate Predicate) {</td>
    <td>70</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">    // We have no choice but conservatively assume that the free-form</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">    // user-provided Predicate properly handles all type indices:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="coveredLine">    markAllIdxsAsCovered();</td>
    <td>70</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="coveredLine">    return actionIf(LegalizeAction::Legal, Predicate);</td>
    <td>70</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">  /// The instruction is legal when type index 0 is any type in the given list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="coveredLine">  LegalizeRuleSet &legalFor(std::initializer_list<LLT> Types) {</td>
    <td>110</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="coveredLine">    return actionFor(LegalizeAction::Legal, Types);</td>
    <td>110</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">  /// The instruction is legal when type indexes 0 and 1 is any type pair in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">  /// given list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="coveredLine">  LegalizeRuleSet &legalFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td>100</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="coveredLine">    return actionFor(LegalizeAction::Legal, Types);</td>
    <td>100</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">  /// The instruction is legal when type index 0 is any type in the given list</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">  /// and imm index 0 is anything.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">  LegalizeRuleSet &legalForTypeWithAnyImm(std::initializer_list<LLT> Types) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">    markAllIdxsAsCovered();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">  LegalizeRuleSet &legalForTypeWithAnyImm(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">    std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">    markAllIdxsAsCovered();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">  /// The instruction is legal when type indexes 0 and 1 along with the memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">  /// size and minimum alignment is any type and size tuple in the given list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="coveredLine">  LegalizeRuleSet &legalForTypesWithMemDesc(</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">      std::initializer_list<LegalityPredicates::TypePairAndMemDesc></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">          TypesAndMemDesc) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="coveredLine">    return actionIf(LegalizeAction::Legal,</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="coveredLine">                    LegalityPredicates::typePairAndMemDescInSet(</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="coveredLine">                        typeIdx(0), typeIdx(1), /*MMOIdx*/ 0, TypesAndMemDesc));</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">  /// The instruction is legal when type indexes 0 and 1 are both in the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">  /// list. That is, the type pair is in the cartesian product of the list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">    return actionForCartesianProduct(LegalizeAction::Legal, Types);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">  /// The instruction is legal when type indexes 0 and 1 are both their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">  /// respective lists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="coveredLine">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td>40</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">                                            std::initializer_list<LLT> Types1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="coveredLine">    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1);</td>
    <td>40</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">  /// The instruction is legal when type indexes 0, 1, and 2 are both their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">  /// respective lists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">                                            std::initializer_list<LLT> Types1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">                                            std::initializer_list<LLT> Types2) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="uncoveredLine">                                     Types2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">  LegalizeRuleSet &alwaysLegal() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">    markAllIdxsAsCovered();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::Legal, always);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  /// The specified type index is coerced if predicate is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">  LegalizeRuleSet &bitcastIf(LegalityPredicate Predicate,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">                             LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">    // We have no choice but conservatively assume that lowering with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">    // free-form user provided Predicate properly handles all type indices:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">    markAllIdxsAsCovered();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::Bitcast, Predicate, Mutation);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">  /// The instruction is lowered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="coveredLine">  LegalizeRuleSet &lower() {</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">    // We have no choice but conservatively assume that predicate-less lowering</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">    // properly handles all type indices by design:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="coveredLine">    markAllIdxsAsCovered();</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="coveredLine">    return actionIf(LegalizeAction::Lower, always);</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">  /// The instruction is lowered if predicate is true. Keep type index 0 as the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">  /// same type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="coveredLine">  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">    // We have no choice but conservatively assume that lowering with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">    // free-form user provided Predicate properly handles all type indices:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="coveredLine">    markAllIdxsAsCovered();</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="coveredLine">    return actionIf(LegalizeAction::Lower, Predicate);</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="">  /// The instruction is lowered if predicate is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">                           LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">    // We have no choice but conservatively assume that lowering with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">    // free-form user provided Predicate properly handles all type indices:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">    markAllIdxsAsCovered();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">    return actionIf(LegalizeAction::Lower, Predicate, Mutation);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">  /// The instruction is lowered when type index 0 is any type in the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">  /// list. Keep type index 0 as the same type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="coveredLine">  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="coveredLine">    return actionFor(LegalizeAction::Lower, Types);</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">  /// The instruction is lowered when type index 0 is any type in the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">  /// list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">                            LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">    return actionFor(LegalizeAction::Lower, Types, Mutation);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">  /// The instruction is lowered when type indexes 0 and 1 is any type pair in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">  /// the given list. Keep type index 0 as the same type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="coveredLine">  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td>60</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="coveredLine">    return actionFor(LegalizeAction::Lower, Types);</td>
    <td>60</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">  /// The instruction is lowered when type indexes 0 and 1 is any type pair in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">  /// the given list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">                            LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">    return actionFor(LegalizeAction::Lower, Types, Mutation);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">  /// The instruction is lowered when type indexes 0 and 1 are both in their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">  /// respective lists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="coveredLine">  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">                                            std::initializer_list<LLT> Types1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="coveredLine">    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1);</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="">  /// The instruction is lowered when when type indexes 0, 1, and 2 are all in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">  /// their respective lists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">                                            std::initializer_list<LLT> Types1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">                                            std::initializer_list<LLT> Types2) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="">                                     Types2);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">  /// The instruction is emitted as a library call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="coveredLine">  LegalizeRuleSet &libcall() {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">    // We have no choice but conservatively assume that predicate-less lowering</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">    // properly handles all type indices by design:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="coveredLine">    markAllIdxsAsCovered();</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="coveredLine">    return actionIf(LegalizeAction::Libcall, always);</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">  /// Like legalIf, but for the Libcall action.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">  LegalizeRuleSet &libcallIf(LegalityPredicate Predicate) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">    // We have no choice but conservatively assume that a libcall with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">    // free-form user provided Predicate properly handles all type indices:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">    markAllIdxsAsCovered();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">    return actionIf(LegalizeAction::Libcall, Predicate);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="coveredLine">  LegalizeRuleSet &libcallFor(std::initializer_list<LLT> Types) {</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="coveredLine">    return actionFor(LegalizeAction::Libcall, Types);</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">  LegalizeRuleSet &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">  libcallFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">    return actionFor(LegalizeAction::Libcall, Types);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">  LegalizeRuleSet &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="">  libcallForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">    return actionForCartesianProduct(LegalizeAction::Libcall, Types);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">  LegalizeRuleSet &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="coveredLine">  libcallForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td>40</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">                             std::initializer_list<LLT> Types1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="coveredLine">    return actionForCartesianProduct(LegalizeAction::Libcall, Types0, Types1);</td>
    <td>40</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">  /// Widen the scalar to the one selected by the mutation if the predicate is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">  /// true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">  LegalizeRuleSet &widenScalarIf(LegalityPredicate Predicate,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">                                 LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">    // We have no choice but conservatively assume that an action with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">    // free-form user provided Predicate properly handles all type indices:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">    markAllIdxsAsCovered();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::WidenScalar, Predicate, Mutation);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">  /// Narrow the scalar to the one selected by the mutation if the predicate is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">  /// true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">  LegalizeRuleSet &narrowScalarIf(LegalityPredicate Predicate,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">                                  LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">    // We have no choice but conservatively assume that an action with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">    // free-form user provided Predicate properly handles all type indices:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">    markAllIdxsAsCovered();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::NarrowScalar, Predicate, Mutation);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">  /// Narrow the scalar, specified in mutation, when type indexes 0 and 1 is any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">  /// type pair in the given list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="">  LegalizeRuleSet &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">  narrowScalarFor(std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">                  LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="uncoveredLine">    return actionFor(LegalizeAction::NarrowScalar, Types, Mutation);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">  /// Add more elements to reach the type selected by the mutation if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">  /// predicate is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">  LegalizeRuleSet &moreElementsIf(LegalityPredicate Predicate,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">                                  LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">    // We have no choice but conservatively assume that an action with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">    // free-form user provided Predicate properly handles all type indices:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">    markAllIdxsAsCovered();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::MoreElements, Predicate, Mutation);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">  /// Remove elements to reach the type selected by the mutation if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">  /// predicate is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">  LegalizeRuleSet &fewerElementsIf(LegalityPredicate Predicate,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">                                   LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">    // We have no choice but conservatively assume that an action with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">    // free-form user provided Predicate properly handles all type indices:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="uncoveredLine">    markAllIdxsAsCovered();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::FewerElements, Predicate, Mutation);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">  /// The instruction is unsupported.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">  LegalizeRuleSet &unsupported() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">    markAllIdxsAsCovered();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::Unsupported, always);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="uncoveredLine">  LegalizeRuleSet &unsupportedIf(LegalityPredicate Predicate) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::Unsupported, Predicate);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">  LegalizeRuleSet &unsupportedFor(std::initializer_list<LLT> Types) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="uncoveredLine">    return actionFor(LegalizeAction::Unsupported, Types);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="uncoveredLine">  LegalizeRuleSet &unsupportedIfMemSizeNotPow2() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::Unsupported,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">                    LegalityPredicates::memSizeInBytesNotPow2(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">  /// Lower a memory operation if the memory size, rounded to bytes, is not a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">  /// power of 2. For example, this will not trigger for s1 or s7, but will for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">  /// s24.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">  LegalizeRuleSet &lowerIfMemSizeNotPow2() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::Lower,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="uncoveredLine">                    LegalityPredicates::memSizeInBytesNotPow2(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">  /// Lower a memory operation if the memory access size is not a round power of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">  /// 2 byte size. This is stricter than lowerIfMemSizeNotPow2, and more likely</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">  /// what you want (e.g. this will lower s1, s7 and s24).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">  LegalizeRuleSet &lowerIfMemSizeNotByteSizePow2() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::Lower,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">                    LegalityPredicates::memSizeNotByteSizePow2(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="coveredLine">  LegalizeRuleSet &customIf(LegalityPredicate Predicate) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="">    // We have no choice but conservatively assume that a custom action with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">    // free-form user provided Predicate properly handles all type indices:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="coveredLine">    markAllIdxsAsCovered();</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="coveredLine">    return actionIf(LegalizeAction::Custom, Predicate);</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">  LegalizeRuleSet &customFor(std::initializer_list<LLT> Types) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">    return actionFor(LegalizeAction::Custom, Types);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">  /// The instruction is custom when type indexes 0 and 1 is any type pair in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">  /// given list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="uncoveredLine">  LegalizeRuleSet &customFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">    return actionFor(LegalizeAction::Custom, Types);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="">  LegalizeRuleSet &customForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">    return actionForCartesianProduct(LegalizeAction::Custom, Types);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">  /// The instruction is custom when type indexes 0 and 1 are both in their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">  /// respective lists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">  LegalizeRuleSet &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="coveredLine">  customForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">                            std::initializer_list<LLT> Types1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="coveredLine">    return actionForCartesianProduct(LegalizeAction::Custom, Types0, Types1);</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">  /// The instruction is custom when when type indexes 0, 1, and 2 are all in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">  /// their respective lists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">  LegalizeRuleSet &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">  customForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">                            std::initializer_list<LLT> Types1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">                            std::initializer_list<LLT> Types2) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">    return actionForCartesianProduct(LegalizeAction::Custom, Types0, Types1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">                                     Types2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">  /// Unconditionally custom lower.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="uncoveredLine">  LegalizeRuleSet &custom() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">    return customIf(always);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  /// Widen the scalar to the next power of two that is at least MinSize.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">  /// No effect if the type is not a scalar or is a power of two.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">  LegalizeRuleSet &widenScalarToNextPow2(unsigned TypeIdx,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">                                         unsigned MinSize = 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">    return actionIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">        LegalizeAction::WidenScalar, sizeNotPow2(typeIdx(TypeIdx)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">  /// Widen the scalar to the next multiple of Size. No effect if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">  /// type is not a scalar or is a multiple of Size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="uncoveredLine">  LegalizeRuleSet &widenScalarToNextMultipleOf(unsigned TypeIdx,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">                                               unsigned Size) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="uncoveredLine">    return actionIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="uncoveredLine">        LegalizeAction::WidenScalar, sizeNotMultipleOf(typeIdx(TypeIdx), Size),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="uncoveredLine">        LegalizeMutations::widenScalarOrEltToNextMultipleOf(TypeIdx, Size));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">  /// Widen the scalar or vector element type to the next power of two that is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">  /// at least MinSize.  No effect if the scalar size is a power of two.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="uncoveredLine">  LegalizeRuleSet &widenScalarOrEltToNextPow2(unsigned TypeIdx,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">                                              unsigned MinSize = 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="uncoveredLine">    return actionIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">        LegalizeAction::WidenScalar, scalarOrEltSizeNotPow2(typeIdx(TypeIdx)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="uncoveredLine">        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">  LegalizeRuleSet &narrowScalar(unsigned TypeIdx, LegalizeMutation Mutation) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">    return actionIf(LegalizeAction::NarrowScalar, isScalar(typeIdx(TypeIdx)),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">                    Mutation);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">  LegalizeRuleSet &scalarize(unsigned TypeIdx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::FewerElements, isVector(typeIdx(TypeIdx)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="uncoveredLine">                    LegalizeMutations::scalarize(TypeIdx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">  LegalizeRuleSet &scalarizeIf(LegalityPredicate Predicate, unsigned TypeIdx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::FewerElements,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">                    all(Predicate, isVector(typeIdx(TypeIdx))),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">                    LegalizeMutations::scalarize(TypeIdx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">  /// Ensure the scalar or element is at least as wide as Ty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">  LegalizeRuleSet &minScalarOrElt(unsigned TypeIdx, const LLT Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="uncoveredLine">                    scalarOrEltNarrowerThan(TypeIdx, Ty.getScalarSizeInBits()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="uncoveredLine">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">  /// Ensure the scalar or element is at least as wide as Ty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="uncoveredLine">  LegalizeRuleSet &minScalarOrEltIf(LegalityPredicate Predicate,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">                                    unsigned TypeIdx, const LLT Ty) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="uncoveredLine">                    all(Predicate, scalarOrEltNarrowerThan(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="">                                       TypeIdx, Ty.getScalarSizeInBits())),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">  /// Ensure the vector size is at least as wide as VectorSize by promoting the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">  /// element.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">  LegalizeRuleSet &widenVectorEltsToVectorMinSize(unsigned TypeIdx,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">                                                  unsigned VectorSize) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">    return actionIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">        LegalizeAction::WidenScalar,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="uncoveredLine">          const LLT VecTy = Query.Types[TypeIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="uncoveredLine">          return VecTy.isVector() && !VecTy.isScalable() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">                 VecTy.getSizeInBits() < VectorSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">        },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">          const LLT VecTy = Query.Types[TypeIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="uncoveredLine">          unsigned NumElts = VecTy.getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="uncoveredLine">          unsigned MinSize = VectorSize / NumElts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">          LLT NewTy = LLT::fixed_vector(NumElts, LLT::scalar(MinSize));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="uncoveredLine">          return std::make_pair(TypeIdx, NewTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="uncoveredLine">        });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">  /// Ensure the scalar is at least as wide as Ty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="coveredLine">  LegalizeRuleSet &minScalar(unsigned TypeIdx, const LLT Ty) {</td>
    <td>210</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="coveredLine">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td>210</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="coveredLine">                    scalarNarrowerThan(TypeIdx, Ty.getSizeInBits()),</td>
    <td>420</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="coveredLine">                    changeTo(typeIdx(TypeIdx), Ty));</td>
    <td>630</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">  /// Ensure the scalar is at least as wide as Ty if condition is met.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="">  LegalizeRuleSet &minScalarIf(LegalityPredicate Predicate, unsigned TypeIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="">                               const LLT Ty) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">    return actionIf(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">        LegalizeAction::WidenScalar,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="">        [=](const LegalityQuery &Query) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">          const LLT QueryTy = Query.Types[TypeIdx];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="">          return QueryTy.isScalar() &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">                 QueryTy.getSizeInBits() < Ty.getSizeInBits() &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">                 Predicate(Query);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="">        },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">        changeTo(typeIdx(TypeIdx), Ty));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="">  /// Ensure the scalar is at most as wide as Ty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="uncoveredLine">  LegalizeRuleSet &maxScalarOrElt(unsigned TypeIdx, const LLT Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::NarrowScalar,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="uncoveredLine">                    scalarOrEltWiderThan(TypeIdx, Ty.getScalarSizeInBits()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="uncoveredLine">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">  /// Ensure the scalar is at most as wide as Ty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="coveredLine">  LegalizeRuleSet &maxScalar(unsigned TypeIdx, const LLT Ty) {</td>
    <td>180</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="coveredLine">    return actionIf(LegalizeAction::NarrowScalar,</td>
    <td>180</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="coveredLine">                    scalarWiderThan(TypeIdx, Ty.getSizeInBits()),</td>
    <td>360</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="coveredLine">                    changeTo(typeIdx(TypeIdx), Ty));</td>
    <td>540</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="">  /// Conditionally limit the maximum size of the scalar.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="">  /// For example, when the maximum size of one type depends on the size of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="">  /// another such as extracting N bits from an M bit container.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="uncoveredLine">  LegalizeRuleSet &maxScalarIf(LegalityPredicate Predicate, unsigned TypeIdx,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">                               const LLT Ty) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">    using namespace LegalizeMutations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="uncoveredLine">    return actionIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">        LegalizeAction::NarrowScalar,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">          const LLT QueryTy = Query.Types[TypeIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">          return QueryTy.isScalar() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">                 QueryTy.getSizeInBits() > Ty.getSizeInBits() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="uncoveredLine">                 Predicate(Query);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">        },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="uncoveredLine">        changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">  /// Limit the range of scalar sizes to MinTy and MaxTy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="coveredLine">  LegalizeRuleSet &clampScalar(unsigned TypeIdx, const LLT MinTy,</td>
    <td>90</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">                               const LLT MaxTy) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="coveredLine">    assert(MinTy.isScalar() && MaxTy.isScalar() && "Expected scalar types");</td>
    <td>90</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="coveredLine">    return minScalar(TypeIdx, MinTy).maxScalar(TypeIdx, MaxTy);</td>
    <td>90</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">  /// Limit the range of scalar sizes to MinTy and MaxTy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="uncoveredLine">  LegalizeRuleSet &clampScalarOrElt(unsigned TypeIdx, const LLT MinTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">                                    const LLT MaxTy) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="uncoveredLine">    return minScalarOrElt(TypeIdx, MinTy).maxScalarOrElt(TypeIdx, MaxTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">  /// Widen the scalar to match the size of another.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="uncoveredLine">  LegalizeRuleSet &minScalarSameAs(unsigned TypeIdx, unsigned LargeTypeIdx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">    typeIdx(TypeIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="uncoveredLine">    return widenScalarIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">          return Query.Types[LargeTypeIdx].getScalarSizeInBits() ></td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="uncoveredLine">                 Query.Types[TypeIdx].getSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="">        },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="uncoveredLine">        LegalizeMutations::changeElementSizeTo(TypeIdx, LargeTypeIdx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">  /// Narrow the scalar to match the size of another.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="uncoveredLine">  LegalizeRuleSet &maxScalarSameAs(unsigned TypeIdx, unsigned NarrowTypeIdx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="uncoveredLine">    typeIdx(TypeIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="uncoveredLine">    return narrowScalarIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">          return Query.Types[NarrowTypeIdx].getScalarSizeInBits() <</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="uncoveredLine">                 Query.Types[TypeIdx].getSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">        },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="uncoveredLine">        LegalizeMutations::changeElementSizeTo(TypeIdx, NarrowTypeIdx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">  /// Change the type \p TypeIdx to have the same scalar size as type \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="">  /// SameSizeIdx.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="uncoveredLine">  LegalizeRuleSet &scalarSameSizeAs(unsigned TypeIdx, unsigned SameSizeIdx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="uncoveredLine">    return minScalarSameAs(TypeIdx, SameSizeIdx)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="uncoveredLine">          .maxScalarSameAs(TypeIdx, SameSizeIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="">  /// Conditionally widen the scalar or elt to match the size of another.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">  LegalizeRuleSet &minScalarEltSameAsIf(LegalityPredicate Predicate,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="">                                   unsigned TypeIdx, unsigned LargeTypeIdx) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="uncoveredLine">    typeIdx(TypeIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="uncoveredLine">    return widenScalarIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="uncoveredLine">          return Query.Types[LargeTypeIdx].getScalarSizeInBits() ></td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="uncoveredLine">                     Query.Types[TypeIdx].getScalarSizeInBits() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">                 Predicate(Query);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">        },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="uncoveredLine">          LLT T = Query.Types[LargeTypeIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="uncoveredLine">          if (T.isVector() && T.getElementType().isPointer())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">            T = T.changeElementType(LLT::scalar(T.getScalarSizeInBits()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="uncoveredLine">          return std::make_pair(TypeIdx, T);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">        });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="">  /// Conditionally narrow the scalar or elt to match the size of another.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="uncoveredLine">  LegalizeRuleSet &maxScalarEltSameAsIf(LegalityPredicate Predicate,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">                                        unsigned TypeIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">                                        unsigned SmallTypeIdx) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="uncoveredLine">    typeIdx(TypeIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">    return narrowScalarIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">          return Query.Types[SmallTypeIdx].getScalarSizeInBits() <</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="uncoveredLine">                     Query.Types[TypeIdx].getScalarSizeInBits() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="uncoveredLine">                 Predicate(Query);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">        },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="uncoveredLine">          LLT T = Query.Types[SmallTypeIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">          return std::make_pair(TypeIdx, T);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">        });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="">  /// Add more elements to the vector to reach the next power of two.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">  /// No effect if the type is not a vector or the element count is a power of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="">  /// two.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">  LegalizeRuleSet &moreElementsToNextPow2(unsigned TypeIdx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">    using namespace LegalityPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">    return actionIf(LegalizeAction::MoreElements,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="uncoveredLine">                    numElementsNotPow2(typeIdx(TypeIdx)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="uncoveredLine">                    LegalizeMutations::moreElementsToNextPow2(TypeIdx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="">  /// Limit the number of elements in EltTy vectors to at least MinElements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">  LegalizeRuleSet &clampMinNumElements(unsigned TypeIdx, const LLT EltTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">                                       unsigned MinElements) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">    // Mark the type index as covered:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="uncoveredLine">    typeIdx(TypeIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="uncoveredLine">    return actionIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">        LegalizeAction::MoreElements,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="uncoveredLine">                 VecTy.getNumElements() < MinElements;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">        },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="uncoveredLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">          return std::make_pair(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">              TypeIdx, LLT::fixed_vector(MinElements, VecTy.getElementType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="uncoveredLine">        });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">  /// Set number of elements to nearest larger multiple of NumElts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="uncoveredLine">  LegalizeRuleSet &alignNumElementsTo(unsigned TypeIdx, const LLT EltTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">                                      unsigned NumElts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="uncoveredLine">    typeIdx(TypeIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="uncoveredLine">    return actionIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">        LegalizeAction::MoreElements,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="uncoveredLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="uncoveredLine">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="uncoveredLine">                 (VecTy.getNumElements() % NumElts != 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">        },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="uncoveredLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="uncoveredLine">          unsigned NewSize = alignTo(VecTy.getNumElements(), NumElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="uncoveredLine">          return std::make_pair(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="uncoveredLine">              TypeIdx, LLT::fixed_vector(NewSize, VecTy.getElementType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">        });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="">  /// Limit the number of elements in EltTy vectors to at most MaxElements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="uncoveredLine">  LegalizeRuleSet &clampMaxNumElements(unsigned TypeIdx, const LLT EltTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">                                       unsigned MaxElements) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">    // Mark the type index as covered:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">    typeIdx(TypeIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">    return actionIf(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">        LegalizeAction::FewerElements,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="uncoveredLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="uncoveredLine">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="uncoveredLine">                 VecTy.getNumElements() > MaxElements;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">        },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="uncoveredLine">        [=](const LegalityQuery &Query) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="uncoveredLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">          LLT NewTy = LLT::scalarOrVector(ElementCount::getFixed(MaxElements),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">                                          VecTy.getElementType());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">          return std::make_pair(TypeIdx, NewTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">        });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">  /// Limit the number of elements for the given vectors to at least MinTy's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="">  /// number of elements and at most MaxTy's number of elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="">  /// No effect if the type is not a vector or does not have the same element</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">  /// type as the constraints.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="">  /// The element type of MinTy and MaxTy must match.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="uncoveredLine">  LegalizeRuleSet &clampNumElements(unsigned TypeIdx, const LLT MinTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">                                    const LLT MaxTy) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="uncoveredLine">    assert(MinTy.getElementType() == MaxTy.getElementType() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="">           "Expected element types to agree");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="uncoveredLine">    const LLT EltTy = MinTy.getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">    return clampMinNumElements(TypeIdx, EltTy, MinTy.getNumElements())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="uncoveredLine">        .clampMaxNumElements(TypeIdx, EltTy, MaxTy.getNumElements());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">  /// Express \p EltTy vectors strictly using vectors with \p NumElts elements</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">  /// (or scalars when \p NumElts equals 1).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">  /// First pad with undef elements to nearest larger multiple of \p NumElts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">  /// Then perform split with all sub-instructions having the same type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">  /// Using clampMaxNumElements (non-strict) can result in leftover instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">  /// with different type (fewer elements then \p NumElts or scalar).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="">  /// No effect if the type is not a vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="uncoveredLine">  LegalizeRuleSet &clampMaxNumElementsStrict(unsigned TypeIdx, const LLT EltTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="">                                             unsigned NumElts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">    return alignNumElementsTo(TypeIdx, EltTy, NumElts)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="uncoveredLine">        .clampMaxNumElements(TypeIdx, EltTy, NumElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">  /// Fallback on the previous implementation. This should only be used while</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">  /// porting a rule.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">  LegalizeRuleSet &fallback() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">    add({always, LegalizeAction::UseLegacyRules});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="">    return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">  /// Check if there is no type index which is obviously not handled by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="">  /// LegalizeRuleSet in any way at all.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="">  /// \pre Type indices of the opcode form a dense [0, \p NumTypeIdxs) set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">  bool verifyTypeIdxsCoverage(unsigned NumTypeIdxs) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">  /// Check if there is no imm index which is obviously not handled by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="">  /// LegalizeRuleSet in any way at all.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">  /// \pre Type indices of the opcode form a dense [0, \p NumTypeIdxs) set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">  bool verifyImmIdxsCoverage(unsigned NumImmIdxs) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">  /// Apply the ruleset to the given LegalityQuery.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="">  LegalizeActionStep apply(const LegalityQuery &Query) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">class LegalizerInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="coveredLine">  virtual ~LegalizerInfo() = default;</td>
    <td>2110</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="uncoveredLine">  const LegacyLegalizerInfo &getLegacyLegalizerInfo() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="uncoveredLine">    return LegacyInfo;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="coveredLine">  LegacyLegalizerInfo &getLegacyLegalizerInfo() { return LegacyInfo; }</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">  unsigned getOpcodeIdxForOpcode(unsigned Opcode) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">  unsigned getActionDefinitionsIdx(unsigned Opcode) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="">  /// Perform simple self-diagnostic and assert if there is anything obviously</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">  /// wrong with the actions set up.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">  void verify(const MCInstrInfo &MII) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">  /// Get the action definitions for the given opcode. Use this to run a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">  /// LegalityQuery through the definitions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">  const LegalizeRuleSet &getActionDefinitions(unsigned Opcode) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">  /// Get the action definition builder for the given opcode. Use this to define</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">  /// the action definitions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">  /// It is an error to request an opcode that has already been requested by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">  /// multiple-opcode variant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">  LegalizeRuleSet &getActionDefinitionsBuilder(unsigned Opcode);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">  /// Get the action definition builder for the given set of opcodes. Use this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">  /// to define the action definitions for multiple opcodes at once. The first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">  /// opcode given will be considered the representative opcode and will hold</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">  /// the definitions whereas the other opcodes will be configured to refer to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">  /// the representative opcode. This lowers memory requirements and very</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">  /// slightly improves performance.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">  /// It would be very easy to introduce unexpected side-effects as a result of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">  /// this aliasing if it were permitted to request different but intersecting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">  /// sets of opcodes but that is difficult to keep track of. It is therefore an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">  /// error to request the same opcode twice using this API, to request an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">  /// opcode that already has definitions, or to use the single-opcode API on an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">  /// opcode that has already been requested by this API.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">  LegalizeRuleSet &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">  getActionDefinitionsBuilder(std::initializer_list<unsigned> Opcodes);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="">  void aliasActionDefinitions(unsigned OpcodeTo, unsigned OpcodeFrom);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">  /// Determine what action should be taken to legalize the described</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">  /// instruction. Requires computeTables to have been called.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="">  /// \returns a description of the next legalization step to perform.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">  LegalizeActionStep getAction(const LegalityQuery &Query) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">  /// Determine what action should be taken to legalize the given generic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="">  /// instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">  /// \returns a description of the next legalization step to perform.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">  LegalizeActionStep getAction(const MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">                               const MachineRegisterInfo &MRI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">  bool isLegal(const LegalityQuery &Query) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">    return getAction(Query).Action == LegalizeAction::Legal;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">  bool isLegalOrCustom(const LegalityQuery &Query) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">    auto Action = getAction(Query).Action;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">    return Action == LegalizeAction::Legal || Action == LegalizeAction::Custom;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">  bool isLegal(const MachineInstr &MI, const MachineRegisterInfo &MRI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">  bool isLegalOrCustom(const MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">                       const MachineRegisterInfo &MRI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">  /// Called for instructions with the Custom LegalizationAction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="uncoveredLine">  virtual bool legalizeCustom(LegalizerHelper &Helper,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">                              MachineInstr &MI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="uncoveredLine">    llvm_unreachable("must implement this if custom action is used");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">  /// \returns true if MI is either legal or has been legalized and false if not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">  /// legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">  /// Return true if MI is either legal or has been legalized and false</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">  /// if not legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="uncoveredLine">  virtual bool legalizeIntrinsic(LegalizerHelper &Helper,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">                                 MachineInstr &MI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="">  /// Return the opcode (SEXT/ZEXT/ANYEXT) that should be performed while</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">  /// widening a constant of type SmallTy which targets can override.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">  /// For eg, the DAG does (SmallTy.isByteSized() ? G_SEXT : G_ZEXT) which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">  /// will be the default.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">  virtual unsigned getExtOpcodeForWideningConstant(LLT SmallTy) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">  static const int FirstOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_START;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">  static const int LastOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_END;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="">  LegalizeRuleSet RulesForOpcode[LastOp - FirstOp + 1];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">  LegacyLegalizerInfo LegacyInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">/// Checks that MIR is fully legal, returns an illegal instruction if it's not,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">/// nullptr otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">const MachineInstr *machineFunctionIsIllegal(const MachineFunction &MF);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">} // end namespace llvm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">#endif // LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm13LegalityQuery7MemDescC2ERKNS_17MachineMemOperandE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm13LegalityQueryC2EjNS_8ArrayRefINS_3LLTEEENS1_INS0_7MemDescEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18LegalizeActionStepC2ENS_15LegalizeActions14LegalizeActionEjNS_3LLTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18LegalizeActionStepC2ENS_24LegacyLegalizeActionStepE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm12LegalizeRule5matchERKNS_13LegalityQueryE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm12LegalizeRule9getActionEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm12LegalizeRule17determineMutationERKNS_13LegalityQueryE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet18isAliasedByAnotherEv</td>
    <td class="numberOfCalls">450</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet21setIsAliasedByAnotherEv</td>
    <td class="numberOfCalls">130</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet7aliasToEj</td>
    <td class="numberOfCalls">270</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15LegalizeRuleSet8getAliasEv</td>
    <td class="numberOfCalls">2820</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm13LegalizerInfoD0Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm13LegalizerInfoD2Ev</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm13LegalizerInfo22getLegacyLegalizerInfoEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm13LegalizerInfo14legalizeCustomERNS_15LegalizerHelperERNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm13LegalizerInfo17legalizeIntrinsicERNS_15LegalizerHelperERNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18LegalityPredicates3allISt8functionIFbRKNS_13LegalityQueryEEEEET_S8_S8_</td>
    <td class="numberOfCalls">100</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm18LegalityPredicates3allISt8functionIFbRKNS_13LegalityQueryEEEEET_S8_S8_ENKUlS5_E_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18LegalityPredicates3allISt8functionIFbRKNS_13LegalityQueryEEEJS7_EEET_S8_S8_DpT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12LegalizeRuleC2ESt8functionIFbRKNS_13LegalityQueryEEENS_15LegalizeActions14LegalizeActionES1_IFSt4pairIjNS_3LLTEES4_EE</td>
    <td class="numberOfCalls">920</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet7typeIdxEj</td>
    <td class="numberOfCalls">1070</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet20markAllIdxsAsCoveredEv</td>
    <td class="numberOfCalls">120</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet3addERKNS_12LegalizeRuleE</td>
    <td class="numberOfCalls">920</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet6alwaysERKNS_13LegalityQueryE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet8actionIfENS_15LegalizeActions14LegalizeActionESt8functionIFbRKNS_13LegalityQueryEEE</td>
    <td class="numberOfCalls">530</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet8actionIfENS_15LegalizeActions14LegalizeActionESt8functionIFbRKNS_13LegalityQueryEEES3_IFSt4pairIjNS_3LLTEES6_EE</td>
    <td class="numberOfCalls">390</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet9actionForENS_15LegalizeActions14LegalizeActionESt16initializer_listINS_3LLTEE</td>
    <td class="numberOfCalls">140</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet9actionForENS_15LegalizeActions14LegalizeActionESt16initializer_listISt4pairINS_3LLTES5_EE</td>
    <td class="numberOfCalls">160</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet25actionForCartesianProductENS_15LegalizeActions14LegalizeActionESt16initializer_listINS_3LLTEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet25actionForCartesianProductENS_15LegalizeActions14LegalizeActionESt16initializer_listINS_3LLTEES5_</td>
    <td class="numberOfCalls">100</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet25actionForCartesianProductENS_15LegalizeActions14LegalizeActionESt16initializer_listINS_3LLTEES5_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSetC2Ev</td>
    <td class="numberOfCalls">2100</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet6immIdxEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet7legalIfESt8functionIFbRKNS_13LegalityQueryEEE</td>
    <td class="numberOfCalls">70</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet8legalForESt16initializer_listINS_3LLTEE</td>
    <td class="numberOfCalls">110</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet8legalForESt16initializer_listISt4pairINS_3LLTES3_EE</td>
    <td class="numberOfCalls">100</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet24legalForTypesWithMemDescESt16initializer_listINS_18LegalityPredicates18TypePairAndMemDescEE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet24legalForCartesianProductESt16initializer_listINS_3LLTEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet24legalForCartesianProductESt16initializer_listINS_3LLTEES3_S3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet11alwaysLegalEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet5lowerEv</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet7lowerIfESt8functionIFbRKNS_13LegalityQueryEEE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet8lowerForESt16initializer_listINS_3LLTEE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet7libcallEv</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet10libcallForESt16initializer_listINS_3LLTEE</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet13widenScalarIfESt8functionIFbRKNS_13LegalityQueryEEES1_IFSt4pairIjNS_3LLTEES4_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet14narrowScalarIfESt8functionIFbRKNS_13LegalityQueryEEES1_IFSt4pairIjNS_3LLTEES4_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet14moreElementsIfESt8functionIFbRKNS_13LegalityQueryEEES1_IFSt4pairIjNS_3LLTEES4_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet15fewerElementsIfESt8functionIFbRKNS_13LegalityQueryEEES1_IFSt4pairIjNS_3LLTEES4_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet11unsupportedEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet13unsupportedIfESt8functionIFbRKNS_13LegalityQueryEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet27unsupportedIfMemSizeNotPow2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet21lowerIfMemSizeNotPow2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet29lowerIfMemSizeNotByteSizePow2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet8customIfESt8functionIFbRKNS_13LegalityQueryEEE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet9customForESt16initializer_listISt4pairINS_3LLTES3_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet25customForCartesianProductESt16initializer_listINS_3LLTEES3_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet25customForCartesianProductESt16initializer_listINS_3LLTEES3_S3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet6customEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet21widenScalarToNextPow2Ejj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet26widenScalarOrEltToNextPow2Ejj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet9scalarizeEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet11scalarizeIfESt8functionIFbRKNS_13LegalityQueryEEEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet14minScalarOrEltEjNS_3LLTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet16minScalarOrEltIfESt8functionIFbRKNS_13LegalityQueryEEEjNS_3LLTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet30widenVectorEltsToVectorMinSizeEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet30widenVectorEltsToVectorMinSizeEjjENKUlRKNS_13LegalityQueryEE_clES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet30widenVectorEltsToVectorMinSizeEjjENKUlRKNS_13LegalityQueryEE0_clES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet9minScalarEjNS_3LLTE</td>
    <td class="numberOfCalls">210</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet14maxScalarOrEltEjNS_3LLTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet9maxScalarEjNS_3LLTE</td>
    <td class="numberOfCalls">180</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet11maxScalarIfESt8functionIFbRKNS_13LegalityQueryEEEjNS_3LLTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet11maxScalarIfESt8functionIFbRKNS_13LegalityQueryEEEjNS_3LLTEENKUlS4_E_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet11clampScalarEjNS_3LLTES1_</td>
    <td class="numberOfCalls">90</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet16clampScalarOrEltEjNS_3LLTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet15minScalarSameAsEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet15minScalarSameAsEjjENKUlRKNS_13LegalityQueryEE_clES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet15maxScalarSameAsEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet15maxScalarSameAsEjjENKUlRKNS_13LegalityQueryEE_clES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet16scalarSameSizeAsEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet20minScalarEltSameAsIfESt8functionIFbRKNS_13LegalityQueryEEEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet20minScalarEltSameAsIfESt8functionIFbRKNS_13LegalityQueryEEEjjENKUlS4_E_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet20minScalarEltSameAsIfESt8functionIFbRKNS_13LegalityQueryEEEjjENKUlS4_E0_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet20maxScalarEltSameAsIfESt8functionIFbRKNS_13LegalityQueryEEEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet20maxScalarEltSameAsIfESt8functionIFbRKNS_13LegalityQueryEEEjjENKUlS4_E_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet20maxScalarEltSameAsIfESt8functionIFbRKNS_13LegalityQueryEEEjjENKUlS4_E0_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet22moreElementsToNextPow2Ej</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet19clampMinNumElementsEjNS_3LLTEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet19clampMinNumElementsEjNS_3LLTEjENKUlRKNS_13LegalityQueryEE_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet19clampMinNumElementsEjNS_3LLTEjENKUlRKNS_13LegalityQueryEE0_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet19clampMaxNumElementsEjNS_3LLTEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet19clampMaxNumElementsEjNS_3LLTEjENKUlRKNS_13LegalityQueryEE_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet19clampMaxNumElementsEjNS_3LLTEjENKUlRKNS_13LegalityQueryEE0_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet16clampNumElementsEjNS_3LLTES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm13LegalizerInfo22getLegacyLegalizerInfoEv</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet24legalForCartesianProductESt16initializer_listINS_3LLTEES3_</td>
    <td class="numberOfCalls">40</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet8lowerForESt16initializer_listISt4pairINS_3LLTES3_EE</td>
    <td class="numberOfCalls">60</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet24lowerForCartesianProductESt16initializer_listINS_3LLTEES3_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet26libcallForCartesianProductESt16initializer_listINS_3LLTEES3_</td>
    <td class="numberOfCalls">40</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet10libcallForESt16initializer_listISt4pairINS_3LLTES3_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet9customForESt16initializer_listINS_3LLTEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18LegalityPredicates9typeIsNotEjNS_3LLTE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm18LegalityPredicates9typeIsNotEjNS_3LLTEENKUlRKNS_13LegalityQueryEE_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet9actionForENS_15LegalizeActions14LegalizeActionESt16initializer_listISt4pairINS_3LLTES5_EESt8functionIFS4_IjS5_ERKNS_13LegalityQueryEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet9bitcastIfESt8functionIFbRKNS_13LegalityQueryEEES1_IFSt4pairIjNS_3LLTEES4_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet15narrowScalarForESt16initializer_listISt4pairINS_3LLTES3_EESt8functionIFS2_IjS3_ERKNS_13LegalityQueryEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet14unsupportedForESt16initializer_listINS_3LLTEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet27widenScalarToNextMultipleOfEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet18alignNumElementsToEjNS_3LLTEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet18alignNumElementsToEjNS_3LLTEjENKUlRKNS_13LegalityQueryEE_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15LegalizeRuleSet18alignNumElementsToEjNS_3LLTEjENKUlRKNS_13LegalityQueryEE0_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15LegalizeRuleSet25clampMaxNumElementsStrictEjNS_3LLTEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/CodeGen/GlobalISel/LegalizerInfo.h ------------------*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/CodeGen/GlobalISel/LegalizerInfo.h ------------------*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">/// \file</td>
    <td class="lineNumber">8</td>
    <td class="codeline">/// \file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">/// Interface for Targets to specify which operations they can successfully</td>
    <td class="lineNumber">9</td>
    <td class="codeline">/// Interface for Targets to specify which operations they can successfully</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// select and how the others should be expanded most efficiently.</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// select and how the others should be expanded most efficiently.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">///</td>
    <td class="lineNumber">11</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">12</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline"></td>
    <td class="lineNumber">13</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#define LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#define LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline"></td>
    <td class="lineNumber">16</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/SmallBitVector.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/SmallBitVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/CodeGen/LowLevelType.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/CodeGen/LowLevelType.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/CodeGen/MachineMemOperand.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/CodeGen/MachineMemOperand.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/CodeGen/TargetOpcodes.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/CodeGen/TargetOpcodes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/MC/MCInstrDesc.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/MC/MCInstrDesc.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Support/AtomicOrdering.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include <tuple></td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include <tuple></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline"></td>
    <td class="lineNumber">30</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">31</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline"></td>
    <td class="lineNumber">32</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">extern cl::opt<bool> DisableGISelLegalityCheck;</td>
    <td class="lineNumber">33</td>
    <td class="codeline">extern cl::opt<bool> DisableGISelLegalityCheck;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline"></td>
    <td class="lineNumber">34</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">class MachineFunction;</td>
    <td class="lineNumber">35</td>
    <td class="codeline">class MachineFunction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">class raw_ostream;</td>
    <td class="lineNumber">36</td>
    <td class="codeline">class raw_ostream;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">class LegalizerHelper;</td>
    <td class="lineNumber">37</td>
    <td class="codeline">class LegalizerHelper;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">class MachineInstr;</td>
    <td class="lineNumber">38</td>
    <td class="codeline">class MachineInstr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">class MachineRegisterInfo;</td>
    <td class="lineNumber">39</td>
    <td class="codeline">class MachineRegisterInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">class MCInstrInfo;</td>
    <td class="lineNumber">40</td>
    <td class="codeline">class MCInstrInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">namespace LegalizeActions {</td>
    <td class="lineNumber">42</td>
    <td class="codeline">namespace LegalizeActions {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">enum LegalizeAction : std::uint8_t {</td>
    <td class="lineNumber">43</td>
    <td class="codeline">enum LegalizeAction : std::uint8_t {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">  /// The operation is expected to be selectable directly by the target, and</td>
    <td class="lineNumber">44</td>
    <td class="codeline">  /// The operation is expected to be selectable directly by the target, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">  /// no transformation is necessary.</td>
    <td class="lineNumber">45</td>
    <td class="codeline">  /// no transformation is necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">  Legal,</td>
    <td class="lineNumber">46</td>
    <td class="codeline">  Legal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline"></td>
    <td class="lineNumber">47</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">  /// The operation should be synthesized from multiple instructions acting on</td>
    <td class="lineNumber">48</td>
    <td class="codeline">  /// The operation should be synthesized from multiple instructions acting on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">  /// a narrower scalar base-type. For example a 64-bit add might be</td>
    <td class="lineNumber">49</td>
    <td class="codeline">  /// a narrower scalar base-type. For example a 64-bit add might be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">  /// implemented in terms of 32-bit add-with-carry.</td>
    <td class="lineNumber">50</td>
    <td class="codeline">  /// implemented in terms of 32-bit add-with-carry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">  NarrowScalar,</td>
    <td class="lineNumber">51</td>
    <td class="codeline">  NarrowScalar,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline"></td>
    <td class="lineNumber">52</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">  /// The operation should be implemented in terms of a wider scalar</td>
    <td class="lineNumber">53</td>
    <td class="codeline">  /// The operation should be implemented in terms of a wider scalar</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">  /// base-type. For example a <2 x s8> add could be implemented as a <2</td>
    <td class="lineNumber">54</td>
    <td class="codeline">  /// base-type. For example a <2 x s8> add could be implemented as a <2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">  /// x s32> add (ignoring the high bits).</td>
    <td class="lineNumber">55</td>
    <td class="codeline">  /// x s32> add (ignoring the high bits).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">  WidenScalar,</td>
    <td class="lineNumber">56</td>
    <td class="codeline">  WidenScalar,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">  /// The (vector) operation should be implemented by splitting it into</td>
    <td class="lineNumber">58</td>
    <td class="codeline">  /// The (vector) operation should be implemented by splitting it into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">  /// sub-vectors where the operation is legal. For example a <8 x s64> add</td>
    <td class="lineNumber">59</td>
    <td class="codeline">  /// sub-vectors where the operation is legal. For example a <8 x s64> add</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">  /// might be implemented as 4 separate <2 x s64> adds. There can be a leftover</td>
    <td class="lineNumber">60</td>
    <td class="codeline">  /// might be implemented as 4 separate <2 x s64> adds. There can be a leftover</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">  /// if there are not enough elements for last sub-vector e.g. <7 x s64> add</td>
    <td class="lineNumber">61</td>
    <td class="codeline">  /// if there are not enough elements for last sub-vector e.g. <7 x s64> add</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">  /// will be implemented as 3 separate <2 x s64> adds and one s64 add. Leftover</td>
    <td class="lineNumber">62</td>
    <td class="codeline">  /// will be implemented as 3 separate <2 x s64> adds and one s64 add. Leftover</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">  /// types can be avoided by doing MoreElements first.</td>
    <td class="lineNumber">63</td>
    <td class="codeline">  /// types can be avoided by doing MoreElements first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">  FewerElements,</td>
    <td class="lineNumber">64</td>
    <td class="codeline">  FewerElements,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline"></td>
    <td class="lineNumber">65</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">  /// The (vector) operation should be implemented by widening the input</td>
    <td class="lineNumber">66</td>
    <td class="codeline">  /// The (vector) operation should be implemented by widening the input</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">  /// vector and ignoring the lanes added by doing so. For example <2 x i8> is</td>
    <td class="lineNumber">67</td>
    <td class="codeline">  /// vector and ignoring the lanes added by doing so. For example <2 x i8> is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">  /// rarely legal, but you might perform an <8 x i8> and then only look at</td>
    <td class="lineNumber">68</td>
    <td class="codeline">  /// rarely legal, but you might perform an <8 x i8> and then only look at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">  /// the first two results.</td>
    <td class="lineNumber">69</td>
    <td class="codeline">  /// the first two results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">  MoreElements,</td>
    <td class="lineNumber">70</td>
    <td class="codeline">  MoreElements,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">  /// Perform the operation on a different, but equivalently sized type.</td>
    <td class="lineNumber">72</td>
    <td class="codeline">  /// Perform the operation on a different, but equivalently sized type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">  Bitcast,</td>
    <td class="lineNumber">73</td>
    <td class="codeline">  Bitcast,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline"></td>
    <td class="lineNumber">74</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">  /// The operation itself must be expressed in terms of simpler actions on</td>
    <td class="lineNumber">75</td>
    <td class="codeline">  /// The operation itself must be expressed in terms of simpler actions on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">  /// this target. E.g. a SREM replaced by an SDIV and subtraction.</td>
    <td class="lineNumber">76</td>
    <td class="codeline">  /// this target. E.g. a SREM replaced by an SDIV and subtraction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">  Lower,</td>
    <td class="lineNumber">77</td>
    <td class="codeline">  Lower,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline"></td>
    <td class="lineNumber">78</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">  /// The operation should be implemented as a call to some kind of runtime</td>
    <td class="lineNumber">79</td>
    <td class="codeline">  /// The operation should be implemented as a call to some kind of runtime</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">  /// support library. For example this usually happens on machines that don't</td>
    <td class="lineNumber">80</td>
    <td class="codeline">  /// support library. For example this usually happens on machines that don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">  /// support floating-point operations natively.</td>
    <td class="lineNumber">81</td>
    <td class="codeline">  /// support floating-point operations natively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">  Libcall,</td>
    <td class="lineNumber">82</td>
    <td class="codeline">  Libcall,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline"></td>
    <td class="lineNumber">83</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">  /// The target wants to do something special with this combination of</td>
    <td class="lineNumber">84</td>
    <td class="codeline">  /// The target wants to do something special with this combination of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">  /// operand and type. A callback will be issued when it is needed.</td>
    <td class="lineNumber">85</td>
    <td class="codeline">  /// operand and type. A callback will be issued when it is needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">  Custom,</td>
    <td class="lineNumber">86</td>
    <td class="codeline">  Custom,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">  /// This operation is completely unsupported on the target. A programming</td>
    <td class="lineNumber">88</td>
    <td class="codeline">  /// This operation is completely unsupported on the target. A programming</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">  /// error has occurred.</td>
    <td class="lineNumber">89</td>
    <td class="codeline">  /// error has occurred.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">  Unsupported,</td>
    <td class="lineNumber">90</td>
    <td class="codeline">  Unsupported,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline"></td>
    <td class="lineNumber">91</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">  /// Sentinel value for when no action was found in the specified table.</td>
    <td class="lineNumber">92</td>
    <td class="codeline">  /// Sentinel value for when no action was found in the specified table.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  NotFound,</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  NotFound,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline"></td>
    <td class="lineNumber">94</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  /// Fall back onto the old rules.</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  /// Fall back onto the old rules.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">  /// TODO: Remove this once we've migrated</td>
    <td class="lineNumber">96</td>
    <td class="codeline">  /// TODO: Remove this once we've migrated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">  UseLegacyRules,</td>
    <td class="lineNumber">97</td>
    <td class="codeline">  UseLegacyRules,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">};</td>
    <td class="lineNumber">98</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">} // end namespace LegalizeActions</td>
    <td class="lineNumber">99</td>
    <td class="codeline">} // end namespace LegalizeActions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">raw_ostream &operator<<(raw_ostream &OS, LegalizeActions::LegalizeAction Action);</td>
    <td class="lineNumber">100</td>
    <td class="codeline">raw_ostream &operator<<(raw_ostream &OS, LegalizeActions::LegalizeAction Action);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline"></td>
    <td class="lineNumber">101</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">using LegalizeActions::LegalizeAction;</td>
    <td class="lineNumber">102</td>
    <td class="codeline">using LegalizeActions::LegalizeAction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline"></td>
    <td class="lineNumber">103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">/// The LegalityQuery object bundles together all the information that's needed</td>
    <td class="lineNumber">104</td>
    <td class="codeline">/// The LegalityQuery object bundles together all the information that's needed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">/// to decide whether a given operation is legal or not.</td>
    <td class="lineNumber">105</td>
    <td class="codeline">/// to decide whether a given operation is legal or not.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">/// For efficiency, it doesn't make a copy of Types so care must be taken not</td>
    <td class="lineNumber">106</td>
    <td class="codeline">/// For efficiency, it doesn't make a copy of Types so care must be taken not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">/// to free it before using the query.</td>
    <td class="lineNumber">107</td>
    <td class="codeline">/// to free it before using the query.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">struct LegalityQuery {</td>
    <td class="lineNumber">108</td>
    <td class="codeline">struct LegalityQuery {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">  unsigned Opcode;</td>
    <td class="lineNumber">109</td>
    <td class="codeline">  unsigned Opcode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  ArrayRef<LLT> Types;</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  ArrayRef<LLT> Types;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  struct MemDesc {</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  struct MemDesc {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">    LLT MemoryTy;</td>
    <td class="lineNumber">113</td>
    <td class="codeline">    LLT MemoryTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">    uint64_t AlignInBits;</td>
    <td class="lineNumber">114</td>
    <td class="codeline">    uint64_t AlignInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">    AtomicOrdering Ordering;</td>
    <td class="lineNumber">115</td>
    <td class="codeline">    AtomicOrdering Ordering;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">    MemDesc() = default;</td>
    <td class="lineNumber">117</td>
    <td class="codeline">    MemDesc() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">    MemDesc(LLT MemoryTy, uint64_t AlignInBits, AtomicOrdering Ordering)</td>
    <td class="lineNumber">118</td>
    <td class="codeline">    MemDesc(LLT MemoryTy, uint64_t AlignInBits, AtomicOrdering Ordering)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">        : MemoryTy(MemoryTy), AlignInBits(AlignInBits), Ordering(Ordering) {}</td>
    <td class="lineNumber">119</td>
    <td class="codeline">        : MemoryTy(MemoryTy), AlignInBits(AlignInBits), Ordering(Ordering) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">    MemDesc(const MachineMemOperand &MMO)</td>
    <td class="lineNumber">120</td>
    <td class="codeline">    MemDesc(const MachineMemOperand &MMO)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">        : MemoryTy(MMO.getMemoryType()),</td>
    <td class="lineNumber">121</td>
    <td class="codeline">        : MemoryTy(MMO.getMemoryType()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">          AlignInBits(MMO.getAlign().value() * 8),</td>
    <td class="lineNumber">122</td>
    <td class="codeline">          AlignInBits(MMO.getAlign().value() * 8),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">          Ordering(MMO.getSuccessOrdering()) {}</td>
    <td class="lineNumber">123</td>
    <td class="codeline">          Ordering(MMO.getSuccessOrdering()) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">124</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  /// Operations which require memory can use this to place requirements on the</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  /// Operations which require memory can use this to place requirements on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  /// memory type for each MMO.</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  /// memory type for each MMO.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  ArrayRef<MemDesc> MMODescrs;</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  ArrayRef<MemDesc> MMODescrs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types,</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">                          const ArrayRef<MemDesc> MMODescrs)</td>
    <td class="lineNumber">131</td>
    <td class="codeline">                          const ArrayRef<MemDesc> MMODescrs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">      : Opcode(Opcode), Types(Types), MMODescrs(MMODescrs) {}</td>
    <td class="lineNumber">132</td>
    <td class="codeline">      : Opcode(Opcode), Types(Types), MMODescrs(MMODescrs) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types)</td>
    <td class="lineNumber">133</td>
    <td class="codeline">  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">      : LegalityQuery(Opcode, Types, {}) {}</td>
    <td class="lineNumber">134</td>
    <td class="codeline">      : LegalityQuery(Opcode, Types, {}) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline"></td>
    <td class="lineNumber">135</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  raw_ostream &print(raw_ostream &OS) const;</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  raw_ostream &print(raw_ostream &OS) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">};</td>
    <td class="lineNumber">137</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">/// The result of a query. It either indicates a final answer of Legal or</td>
    <td class="lineNumber">139</td>
    <td class="codeline">/// The result of a query. It either indicates a final answer of Legal or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">/// Unsupported or describes an action that must be taken to make an operation</td>
    <td class="lineNumber">140</td>
    <td class="codeline">/// Unsupported or describes an action that must be taken to make an operation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">/// more legal.</td>
    <td class="lineNumber">141</td>
    <td class="codeline">/// more legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">struct LegalizeActionStep {</td>
    <td class="lineNumber">142</td>
    <td class="codeline">struct LegalizeActionStep {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">  /// The action to take or the final answer.</td>
    <td class="lineNumber">143</td>
    <td class="codeline">  /// The action to take or the final answer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  LegalizeAction Action;</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  LegalizeAction Action;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">  /// If describing an action, the type index to change. Otherwise zero.</td>
    <td class="lineNumber">145</td>
    <td class="codeline">  /// If describing an action, the type index to change. Otherwise zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  unsigned TypeIdx;</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  unsigned TypeIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  /// If describing an action, the new type for TypeIdx. Otherwise LLT{}.</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  /// If describing an action, the new type for TypeIdx. Otherwise LLT{}.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  LLT NewType;</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  LLT NewType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">  LegalizeActionStep(LegalizeAction Action, unsigned TypeIdx,</td>
    <td class="lineNumber">150</td>
    <td class="codeline">  LegalizeActionStep(LegalizeAction Action, unsigned TypeIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">                     const LLT NewType)</td>
    <td class="lineNumber">151</td>
    <td class="codeline">                     const LLT NewType)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">      : Action(Action), TypeIdx(TypeIdx), NewType(NewType) {}</td>
    <td class="lineNumber">152</td>
    <td class="codeline">      : Action(Action), TypeIdx(TypeIdx), NewType(NewType) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">  LegalizeActionStep(LegacyLegalizeActionStep Step)</td>
    <td class="lineNumber">154</td>
    <td class="codeline">  LegalizeActionStep(LegacyLegalizeActionStep Step)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">      : TypeIdx(Step.TypeIdx), NewType(Step.NewType) {</td>
    <td class="lineNumber">155</td>
    <td class="codeline">      : TypeIdx(Step.TypeIdx), NewType(Step.NewType) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">    switch (Step.Action) {</td>
    <td class="lineNumber">156</td>
    <td class="codeline">    switch (Step.Action) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">    case LegacyLegalizeActions::Legal:</td>
    <td class="lineNumber">157</td>
    <td class="codeline">    case LegacyLegalizeActions::Legal:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">      Action = LegalizeActions::Legal;</td>
    <td class="lineNumber">158</td>
    <td class="codeline">      Action = LegalizeActions::Legal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">159</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">    case LegacyLegalizeActions::NarrowScalar:</td>
    <td class="lineNumber">160</td>
    <td class="codeline">    case LegacyLegalizeActions::NarrowScalar:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">      Action = LegalizeActions::NarrowScalar;</td>
    <td class="lineNumber">161</td>
    <td class="codeline">      Action = LegalizeActions::NarrowScalar;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">162</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">    case LegacyLegalizeActions::WidenScalar:</td>
    <td class="lineNumber">163</td>
    <td class="codeline">    case LegacyLegalizeActions::WidenScalar:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">      Action = LegalizeActions::WidenScalar;</td>
    <td class="lineNumber">164</td>
    <td class="codeline">      Action = LegalizeActions::WidenScalar;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">165</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">    case LegacyLegalizeActions::FewerElements:</td>
    <td class="lineNumber">166</td>
    <td class="codeline">    case LegacyLegalizeActions::FewerElements:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">      Action = LegalizeActions::FewerElements;</td>
    <td class="lineNumber">167</td>
    <td class="codeline">      Action = LegalizeActions::FewerElements;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">168</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">    case LegacyLegalizeActions::MoreElements:</td>
    <td class="lineNumber">169</td>
    <td class="codeline">    case LegacyLegalizeActions::MoreElements:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">      Action = LegalizeActions::MoreElements;</td>
    <td class="lineNumber">170</td>
    <td class="codeline">      Action = LegalizeActions::MoreElements;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">171</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">    case LegacyLegalizeActions::Bitcast:</td>
    <td class="lineNumber">172</td>
    <td class="codeline">    case LegacyLegalizeActions::Bitcast:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">      Action = LegalizeActions::Bitcast;</td>
    <td class="lineNumber">173</td>
    <td class="codeline">      Action = LegalizeActions::Bitcast;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">174</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">    case LegacyLegalizeActions::Lower:</td>
    <td class="lineNumber">175</td>
    <td class="codeline">    case LegacyLegalizeActions::Lower:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">      Action = LegalizeActions::Lower;</td>
    <td class="lineNumber">176</td>
    <td class="codeline">      Action = LegalizeActions::Lower;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">177</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">    case LegacyLegalizeActions::Libcall:</td>
    <td class="lineNumber">178</td>
    <td class="codeline">    case LegacyLegalizeActions::Libcall:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">      Action = LegalizeActions::Libcall;</td>
    <td class="lineNumber">179</td>
    <td class="codeline">      Action = LegalizeActions::Libcall;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">180</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">    case LegacyLegalizeActions::Custom:</td>
    <td class="lineNumber">181</td>
    <td class="codeline">    case LegacyLegalizeActions::Custom:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">      Action = LegalizeActions::Custom;</td>
    <td class="lineNumber">182</td>
    <td class="codeline">      Action = LegalizeActions::Custom;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">183</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">    case LegacyLegalizeActions::Unsupported:</td>
    <td class="lineNumber">184</td>
    <td class="codeline">    case LegacyLegalizeActions::Unsupported:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">      Action = LegalizeActions::Unsupported;</td>
    <td class="lineNumber">185</td>
    <td class="codeline">      Action = LegalizeActions::Unsupported;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">186</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">    case LegacyLegalizeActions::NotFound:</td>
    <td class="lineNumber">187</td>
    <td class="codeline">    case LegacyLegalizeActions::NotFound:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">      Action = LegalizeActions::NotFound;</td>
    <td class="lineNumber">188</td>
    <td class="codeline">      Action = LegalizeActions::NotFound;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">189</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">190</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  bool operator==(const LegalizeActionStep &RHS) const {</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  bool operator==(const LegalizeActionStep &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">    return std::tie(Action, TypeIdx, NewType) ==</td>
    <td class="lineNumber">194</td>
    <td class="codeline">    return std::tie(Action, TypeIdx, NewType) ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">        std::tie(RHS.Action, RHS.TypeIdx, RHS.NewType);</td>
    <td class="lineNumber">195</td>
    <td class="codeline">        std::tie(RHS.Action, RHS.TypeIdx, RHS.NewType);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">196</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">};</td>
    <td class="lineNumber">197</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">using LegalityPredicate = std::function<bool (const LegalityQuery &)>;</td>
    <td class="lineNumber">199</td>
    <td class="codeline">using LegalityPredicate = std::function<bool (const LegalityQuery &)>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">using LegalizeMutation =</td>
    <td class="lineNumber">200</td>
    <td class="codeline">using LegalizeMutation =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">    std::function<std::pair<unsigned, LLT>(const LegalityQuery &)>;</td>
    <td class="lineNumber">201</td>
    <td class="codeline">    std::function<std::pair<unsigned, LLT>(const LegalityQuery &)>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline"></td>
    <td class="lineNumber">202</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">namespace LegalityPredicates {</td>
    <td class="lineNumber">203</td>
    <td class="codeline">namespace LegalityPredicates {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">struct TypePairAndMemDesc {</td>
    <td class="lineNumber">204</td>
    <td class="codeline">struct TypePairAndMemDesc {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  LLT Type0;</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  LLT Type0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  LLT Type1;</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  LLT Type1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  LLT MemTy;</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  LLT MemTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  uint64_t Align;</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  uint64_t Align;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline"></td>
    <td class="lineNumber">209</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">  bool operator==(const TypePairAndMemDesc &Other) const {</td>
    <td class="lineNumber">210</td>
    <td class="codeline">  bool operator==(const TypePairAndMemDesc &Other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">    return Type0 == Other.Type0 && Type1 == Other.Type1 &&</td>
    <td class="lineNumber">211</td>
    <td class="codeline">    return Type0 == Other.Type0 && Type1 == Other.Type1 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">           Align == Other.Align && MemTy == Other.MemTy;</td>
    <td class="lineNumber">212</td>
    <td class="codeline">           Align == Other.Align && MemTy == Other.MemTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">  /// \returns true if this memory access is legal with for the access described</td>
    <td class="lineNumber">215</td>
    <td class="codeline">  /// \returns true if this memory access is legal with for the access described</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  /// by \p Other (The alignment is sufficient for the size and result type).</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  /// by \p Other (The alignment is sufficient for the size and result type).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  bool isCompatible(const TypePairAndMemDesc &Other) const {</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  bool isCompatible(const TypePairAndMemDesc &Other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">    return Type0 == Other.Type0 && Type1 == Other.Type1 &&</td>
    <td class="lineNumber">218</td>
    <td class="codeline">    return Type0 == Other.Type0 && Type1 == Other.Type1 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">           Align >= Other.Align &&</td>
    <td class="lineNumber">219</td>
    <td class="codeline">           Align >= Other.Align &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">           // FIXME: This perhaps should be stricter, but the current legality</td>
    <td class="lineNumber">220</td>
    <td class="codeline">           // FIXME: This perhaps should be stricter, but the current legality</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">           // rules are written only considering the size.</td>
    <td class="lineNumber">221</td>
    <td class="codeline">           // rules are written only considering the size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">           MemTy.getSizeInBits() == Other.MemTy.getSizeInBits();</td>
    <td class="lineNumber">222</td>
    <td class="codeline">           MemTy.getSizeInBits() == Other.MemTy.getSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">};</td>
    <td class="lineNumber">224</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">/// True iff P0 and P1 are true.</td>
    <td class="lineNumber">226</td>
    <td class="codeline">/// True iff P0 and P1 are true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">template<typename Predicate></td>
    <td class="lineNumber">227</td>
    <td class="codeline">template<typename Predicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">Predicate all(Predicate P0, Predicate P1) {</td>
    <td class="lineNumber">228</td>
    <td class="codeline">Predicate all(Predicate P0, Predicate P1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  return [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  return [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">    return P0(Query) && P1(Query);</td>
    <td class="lineNumber">230</td>
    <td class="codeline">    return P0(Query) && P1(Query);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">}</td>
    <td class="lineNumber">232</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">/// True iff all given predicates are true.</td>
    <td class="lineNumber">233</td>
    <td class="codeline">/// True iff all given predicates are true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">template<typename Predicate, typename... Args></td>
    <td class="lineNumber">234</td>
    <td class="codeline">template<typename Predicate, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">Predicate all(Predicate P0, Predicate P1, Args... args) {</td>
    <td class="lineNumber">235</td>
    <td class="codeline">Predicate all(Predicate P0, Predicate P1, Args... args) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">  return all(all(P0, P1), args...);</td>
    <td class="lineNumber">236</td>
    <td class="codeline">  return all(all(P0, P1), args...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">}</td>
    <td class="lineNumber">237</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">/// True iff P0 or P1 are true.</td>
    <td class="lineNumber">239</td>
    <td class="codeline">/// True iff P0 or P1 are true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">template<typename Predicate></td>
    <td class="lineNumber">240</td>
    <td class="codeline">template<typename Predicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">Predicate any(Predicate P0, Predicate P1) {</td>
    <td class="lineNumber">241</td>
    <td class="codeline">Predicate any(Predicate P0, Predicate P1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  return [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  return [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">    return P0(Query) || P1(Query);</td>
    <td class="lineNumber">243</td>
    <td class="codeline">    return P0(Query) || P1(Query);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">}</td>
    <td class="lineNumber">245</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">/// True iff any given predicates are true.</td>
    <td class="lineNumber">246</td>
    <td class="codeline">/// True iff any given predicates are true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">template<typename Predicate, typename... Args></td>
    <td class="lineNumber">247</td>
    <td class="codeline">template<typename Predicate, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">Predicate any(Predicate P0, Predicate P1, Args... args) {</td>
    <td class="lineNumber">248</td>
    <td class="codeline">Predicate any(Predicate P0, Predicate P1, Args... args) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  return any(any(P0, P1), args...);</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  return any(any(P0, P1), args...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">}</td>
    <td class="lineNumber">250</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">/// True iff the given type index is the specified type.</td>
    <td class="lineNumber">252</td>
    <td class="codeline">/// True iff the given type index is the specified type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">LegalityPredicate typeIs(unsigned TypeIdx, LLT TypesInit);</td>
    <td class="lineNumber">253</td>
    <td class="codeline">LegalityPredicate typeIs(unsigned TypeIdx, LLT TypesInit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">/// True iff the given type index is one of the specified types.</td>
    <td class="lineNumber">254</td>
    <td class="codeline">/// True iff the given type index is one of the specified types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">LegalityPredicate typeInSet(unsigned TypeIdx,</td>
    <td class="lineNumber">255</td>
    <td class="codeline">LegalityPredicate typeInSet(unsigned TypeIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">                            std::initializer_list<LLT> TypesInit);</td>
    <td class="lineNumber">256</td>
    <td class="codeline">                            std::initializer_list<LLT> TypesInit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline"></td>
    <td class="lineNumber">257</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">/// True iff the given type index is not the specified type.</td>
    <td class="lineNumber">258</td>
    <td class="codeline">/// True iff the given type index is not the specified type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">inline LegalityPredicate typeIsNot(unsigned TypeIdx, LLT Type) {</td>
    <td class="lineNumber">259</td>
    <td class="codeline">inline LegalityPredicate typeIsNot(unsigned TypeIdx, LLT Type) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  return [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  return [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">           return Query.Types[TypeIdx] != Type;</td>
    <td class="lineNumber">261</td>
    <td class="codeline">           return Query.Types[TypeIdx] != Type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">         };</td>
    <td class="lineNumber">262</td>
    <td class="codeline">         };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">}</td>
    <td class="lineNumber">263</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline"></td>
    <td class="lineNumber">264</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">/// True iff the given types for the given pair of type indexes is one of the</td>
    <td class="lineNumber">265</td>
    <td class="codeline">/// True iff the given types for the given pair of type indexes is one of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">/// specified type pairs.</td>
    <td class="lineNumber">266</td>
    <td class="codeline">/// specified type pairs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">LegalityPredicate</td>
    <td class="lineNumber">267</td>
    <td class="codeline">LegalityPredicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">typePairInSet(unsigned TypeIdx0, unsigned TypeIdx1,</td>
    <td class="lineNumber">268</td>
    <td class="codeline">typePairInSet(unsigned TypeIdx0, unsigned TypeIdx1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">              std::initializer_list<std::pair<LLT, LLT>> TypesInit);</td>
    <td class="lineNumber">269</td>
    <td class="codeline">              std::initializer_list<std::pair<LLT, LLT>> TypesInit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">/// True iff the given types for the given pair of type indexes is one of the</td>
    <td class="lineNumber">270</td>
    <td class="codeline">/// True iff the given types for the given pair of type indexes is one of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">/// specified type pairs.</td>
    <td class="lineNumber">271</td>
    <td class="codeline">/// specified type pairs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">LegalityPredicate typePairAndMemDescInSet(</td>
    <td class="lineNumber">272</td>
    <td class="codeline">LegalityPredicate typePairAndMemDescInSet(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">    unsigned TypeIdx0, unsigned TypeIdx1, unsigned MMOIdx,</td>
    <td class="lineNumber">273</td>
    <td class="codeline">    unsigned TypeIdx0, unsigned TypeIdx1, unsigned MMOIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">    std::initializer_list<TypePairAndMemDesc> TypesAndMemDescInit);</td>
    <td class="lineNumber">274</td>
    <td class="codeline">    std::initializer_list<TypePairAndMemDesc> TypesAndMemDescInit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">/// True iff the specified type index is a scalar.</td>
    <td class="lineNumber">275</td>
    <td class="codeline">/// True iff the specified type index is a scalar.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">LegalityPredicate isScalar(unsigned TypeIdx);</td>
    <td class="lineNumber">276</td>
    <td class="codeline">LegalityPredicate isScalar(unsigned TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">/// True iff the specified type index is a vector.</td>
    <td class="lineNumber">277</td>
    <td class="codeline">/// True iff the specified type index is a vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">LegalityPredicate isVector(unsigned TypeIdx);</td>
    <td class="lineNumber">278</td>
    <td class="codeline">LegalityPredicate isVector(unsigned TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">/// True iff the specified type index is a pointer (with any address space).</td>
    <td class="lineNumber">279</td>
    <td class="codeline">/// True iff the specified type index is a pointer (with any address space).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">LegalityPredicate isPointer(unsigned TypeIdx);</td>
    <td class="lineNumber">280</td>
    <td class="codeline">LegalityPredicate isPointer(unsigned TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">/// True iff the specified type index is a pointer with the specified address</td>
    <td class="lineNumber">281</td>
    <td class="codeline">/// True iff the specified type index is a pointer with the specified address</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">/// space.</td>
    <td class="lineNumber">282</td>
    <td class="codeline">/// space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">LegalityPredicate isPointer(unsigned TypeIdx, unsigned AddrSpace);</td>
    <td class="lineNumber">283</td>
    <td class="codeline">LegalityPredicate isPointer(unsigned TypeIdx, unsigned AddrSpace);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline"></td>
    <td class="lineNumber">284</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">/// True if the type index is a vector with element type \p EltTy</td>
    <td class="lineNumber">285</td>
    <td class="codeline">/// True if the type index is a vector with element type \p EltTy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">LegalityPredicate elementTypeIs(unsigned TypeIdx, LLT EltTy);</td>
    <td class="lineNumber">286</td>
    <td class="codeline">LegalityPredicate elementTypeIs(unsigned TypeIdx, LLT EltTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
    <td class="lineNumber">287</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">/// True iff the specified type index is a scalar that's narrower than the given</td>
    <td class="lineNumber">288</td>
    <td class="codeline">/// True iff the specified type index is a scalar that's narrower than the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">/// size.</td>
    <td class="lineNumber">289</td>
    <td class="codeline">/// size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">LegalityPredicate scalarNarrowerThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">290</td>
    <td class="codeline">LegalityPredicate scalarNarrowerThan(unsigned TypeIdx, unsigned Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">/// True iff the specified type index is a scalar that's wider than the given</td>
    <td class="lineNumber">292</td>
    <td class="codeline">/// True iff the specified type index is a scalar that's wider than the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">/// size.</td>
    <td class="lineNumber">293</td>
    <td class="codeline">/// size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">LegalityPredicate scalarWiderThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">294</td>
    <td class="codeline">LegalityPredicate scalarWiderThan(unsigned TypeIdx, unsigned Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">/// True iff the specified type index is a scalar or vector with an element type</td>
    <td class="lineNumber">296</td>
    <td class="codeline">/// True iff the specified type index is a scalar or vector with an element type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">/// that's narrower than the given size.</td>
    <td class="lineNumber">297</td>
    <td class="codeline">/// that's narrower than the given size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">LegalityPredicate scalarOrEltNarrowerThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">298</td>
    <td class="codeline">LegalityPredicate scalarOrEltNarrowerThan(unsigned TypeIdx, unsigned Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline"></td>
    <td class="lineNumber">299</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">/// True iff the specified type index is a scalar or a vector with an element</td>
    <td class="lineNumber">300</td>
    <td class="codeline">/// True iff the specified type index is a scalar or a vector with an element</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">/// type that's wider than the given size.</td>
    <td class="lineNumber">301</td>
    <td class="codeline">/// type that's wider than the given size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">LegalityPredicate scalarOrEltWiderThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">302</td>
    <td class="codeline">LegalityPredicate scalarOrEltWiderThan(unsigned TypeIdx, unsigned Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline"></td>
    <td class="lineNumber">303</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">/// True iff the specified type index is a scalar whose size is not a multiple</td>
    <td class="lineNumber">304</td>
    <td class="codeline">/// True iff the specified type index is a scalar whose size is not a multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">/// of Size.</td>
    <td class="lineNumber">305</td>
    <td class="codeline">/// of Size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">LegalityPredicate sizeNotMultipleOf(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">306</td>
    <td class="codeline">LegalityPredicate sizeNotMultipleOf(unsigned TypeIdx, unsigned Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline"></td>
    <td class="lineNumber">307</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">/// True iff the specified type index is a scalar whose size is not a power of</td>
    <td class="lineNumber">308</td>
    <td class="codeline">/// True iff the specified type index is a scalar whose size is not a power of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">/// 2.</td>
    <td class="lineNumber">309</td>
    <td class="codeline">/// 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">LegalityPredicate sizeNotPow2(unsigned TypeIdx);</td>
    <td class="lineNumber">310</td>
    <td class="codeline">LegalityPredicate sizeNotPow2(unsigned TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">/// True iff the specified type index is a scalar or vector whose element size</td>
    <td class="lineNumber">312</td>
    <td class="codeline">/// True iff the specified type index is a scalar or vector whose element size</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">/// is not a power of 2.</td>
    <td class="lineNumber">313</td>
    <td class="codeline">/// is not a power of 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">LegalityPredicate scalarOrEltSizeNotPow2(unsigned TypeIdx);</td>
    <td class="lineNumber">314</td>
    <td class="codeline">LegalityPredicate scalarOrEltSizeNotPow2(unsigned TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">/// True if the total bitwidth of the specified type index is \p Size bits.</td>
    <td class="lineNumber">316</td>
    <td class="codeline">/// True if the total bitwidth of the specified type index is \p Size bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">LegalityPredicate sizeIs(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">317</td>
    <td class="codeline">LegalityPredicate sizeIs(unsigned TypeIdx, unsigned Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline"></td>
    <td class="lineNumber">318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">/// True iff the specified type indices are both the same bit size.</td>
    <td class="lineNumber">319</td>
    <td class="codeline">/// True iff the specified type indices are both the same bit size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">LegalityPredicate sameSize(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td class="lineNumber">320</td>
    <td class="codeline">LegalityPredicate sameSize(unsigned TypeIdx0, unsigned TypeIdx1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline"></td>
    <td class="lineNumber">321</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">/// True iff the first type index has a larger total bit size than second type</td>
    <td class="lineNumber">322</td>
    <td class="codeline">/// True iff the first type index has a larger total bit size than second type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">/// index.</td>
    <td class="lineNumber">323</td>
    <td class="codeline">/// index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">LegalityPredicate largerThan(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td class="lineNumber">324</td>
    <td class="codeline">LegalityPredicate largerThan(unsigned TypeIdx0, unsigned TypeIdx1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">/// True iff the first type index has a smaller total bit size than second type</td>
    <td class="lineNumber">326</td>
    <td class="codeline">/// True iff the first type index has a smaller total bit size than second type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">/// index.</td>
    <td class="lineNumber">327</td>
    <td class="codeline">/// index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">LegalityPredicate smallerThan(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td class="lineNumber">328</td>
    <td class="codeline">LegalityPredicate smallerThan(unsigned TypeIdx0, unsigned TypeIdx1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline"></td>
    <td class="lineNumber">329</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">/// True iff the specified MMO index has a size (rounded to bytes) that is not a</td>
    <td class="lineNumber">330</td>
    <td class="codeline">/// True iff the specified MMO index has a size (rounded to bytes) that is not a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">/// power of 2.</td>
    <td class="lineNumber">331</td>
    <td class="codeline">/// power of 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">LegalityPredicate memSizeInBytesNotPow2(unsigned MMOIdx);</td>
    <td class="lineNumber">332</td>
    <td class="codeline">LegalityPredicate memSizeInBytesNotPow2(unsigned MMOIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline"></td>
    <td class="lineNumber">333</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">/// True iff the specified MMO index has a size that is not an even byte size,</td>
    <td class="lineNumber">334</td>
    <td class="codeline">/// True iff the specified MMO index has a size that is not an even byte size,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">/// or that even byte size is not a power of 2.</td>
    <td class="lineNumber">335</td>
    <td class="codeline">/// or that even byte size is not a power of 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">LegalityPredicate memSizeNotByteSizePow2(unsigned MMOIdx);</td>
    <td class="lineNumber">336</td>
    <td class="codeline">LegalityPredicate memSizeNotByteSizePow2(unsigned MMOIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline"></td>
    <td class="lineNumber">337</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">/// True iff the specified type index is a vector whose element count is not a</td>
    <td class="lineNumber">338</td>
    <td class="codeline">/// True iff the specified type index is a vector whose element count is not a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">/// power of 2.</td>
    <td class="lineNumber">339</td>
    <td class="codeline">/// power of 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">LegalityPredicate numElementsNotPow2(unsigned TypeIdx);</td>
    <td class="lineNumber">340</td>
    <td class="codeline">LegalityPredicate numElementsNotPow2(unsigned TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">/// True iff the specified MMO index has at an atomic ordering of at Ordering or</td>
    <td class="lineNumber">341</td>
    <td class="codeline">/// True iff the specified MMO index has at an atomic ordering of at Ordering or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">/// stronger.</td>
    <td class="lineNumber">342</td>
    <td class="codeline">/// stronger.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">LegalityPredicate atomicOrderingAtLeastOrStrongerThan(unsigned MMOIdx,</td>
    <td class="lineNumber">343</td>
    <td class="codeline">LegalityPredicate atomicOrderingAtLeastOrStrongerThan(unsigned MMOIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">                                                      AtomicOrdering Ordering);</td>
    <td class="lineNumber">344</td>
    <td class="codeline">                                                      AtomicOrdering Ordering);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">} // end namespace LegalityPredicates</td>
    <td class="lineNumber">345</td>
    <td class="codeline">} // end namespace LegalityPredicates</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline"></td>
    <td class="lineNumber">346</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">namespace LegalizeMutations {</td>
    <td class="lineNumber">347</td>
    <td class="codeline">namespace LegalizeMutations {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">/// Select this specific type for the given type index.</td>
    <td class="lineNumber">348</td>
    <td class="codeline">/// Select this specific type for the given type index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">LegalizeMutation changeTo(unsigned TypeIdx, LLT Ty);</td>
    <td class="lineNumber">349</td>
    <td class="codeline">LegalizeMutation changeTo(unsigned TypeIdx, LLT Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline"></td>
    <td class="lineNumber">350</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">/// Keep the same type as the given type index.</td>
    <td class="lineNumber">351</td>
    <td class="codeline">/// Keep the same type as the given type index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">LegalizeMutation changeTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">352</td>
    <td class="codeline">LegalizeMutation changeTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline"></td>
    <td class="lineNumber">353</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">/// Keep the same scalar or element type as the given type index.</td>
    <td class="lineNumber">354</td>
    <td class="codeline">/// Keep the same scalar or element type as the given type index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">LegalizeMutation changeElementTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">355</td>
    <td class="codeline">LegalizeMutation changeElementTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline"></td>
    <td class="lineNumber">356</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">/// Keep the same scalar or element type as the given type.</td>
    <td class="lineNumber">357</td>
    <td class="codeline">/// Keep the same scalar or element type as the given type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">LegalizeMutation changeElementTo(unsigned TypeIdx, LLT Ty);</td>
    <td class="lineNumber">358</td>
    <td class="codeline">LegalizeMutation changeElementTo(unsigned TypeIdx, LLT Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline"></td>
    <td class="lineNumber">359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">/// Keep the same scalar or element type as \p TypeIdx, but take the number of</td>
    <td class="lineNumber">360</td>
    <td class="codeline">/// Keep the same scalar or element type as \p TypeIdx, but take the number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">/// elements from \p FromTypeIdx.</td>
    <td class="lineNumber">361</td>
    <td class="codeline">/// elements from \p FromTypeIdx.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">LegalizeMutation changeElementCountTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">362</td>
    <td class="codeline">LegalizeMutation changeElementCountTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline"></td>
    <td class="lineNumber">363</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">/// Keep the same scalar or element type as \p TypeIdx, but take the number of</td>
    <td class="lineNumber">364</td>
    <td class="codeline">/// Keep the same scalar or element type as \p TypeIdx, but take the number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">/// elements from \p Ty.</td>
    <td class="lineNumber">365</td>
    <td class="codeline">/// elements from \p Ty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">LegalizeMutation changeElementCountTo(unsigned TypeIdx, LLT Ty);</td>
    <td class="lineNumber">366</td>
    <td class="codeline">LegalizeMutation changeElementCountTo(unsigned TypeIdx, LLT Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">/// Change the scalar size or element size to have the same scalar size as type</td>
    <td class="lineNumber">368</td>
    <td class="codeline">/// Change the scalar size or element size to have the same scalar size as type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">/// index \p FromIndex. Unlike changeElementTo, this discards pointer types and</td>
    <td class="lineNumber">369</td>
    <td class="codeline">/// index \p FromIndex. Unlike changeElementTo, this discards pointer types and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">/// only changes the size.</td>
    <td class="lineNumber">370</td>
    <td class="codeline">/// only changes the size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">LegalizeMutation changeElementSizeTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">371</td>
    <td class="codeline">LegalizeMutation changeElementSizeTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline"></td>
    <td class="lineNumber">372</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">/// Widen the scalar type or vector element type for the given type index to the</td>
    <td class="lineNumber">373</td>
    <td class="codeline">/// Widen the scalar type or vector element type for the given type index to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">/// next power of 2.</td>
    <td class="lineNumber">374</td>
    <td class="codeline">/// next power of 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">LegalizeMutation widenScalarOrEltToNextPow2(unsigned TypeIdx, unsigned Min = 0);</td>
    <td class="lineNumber">375</td>
    <td class="codeline">LegalizeMutation widenScalarOrEltToNextPow2(unsigned TypeIdx, unsigned Min = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline"></td>
    <td class="lineNumber">376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">/// Widen the scalar type or vector element type for the given type index to</td>
    <td class="lineNumber">377</td>
    <td class="codeline">/// Widen the scalar type or vector element type for the given type index to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">/// next multiple of \p Size.</td>
    <td class="lineNumber">378</td>
    <td class="codeline">/// next multiple of \p Size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">LegalizeMutation widenScalarOrEltToNextMultipleOf(unsigned TypeIdx,</td>
    <td class="lineNumber">379</td>
    <td class="codeline">LegalizeMutation widenScalarOrEltToNextMultipleOf(unsigned TypeIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">                                                  unsigned Size);</td>
    <td class="lineNumber">380</td>
    <td class="codeline">                                                  unsigned Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">/// Add more elements to the type for the given type index to the next power of</td>
    <td class="lineNumber">382</td>
    <td class="codeline">/// Add more elements to the type for the given type index to the next power of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">/// 2.</td>
    <td class="lineNumber">383</td>
    <td class="codeline">/// 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">LegalizeMutation moreElementsToNextPow2(unsigned TypeIdx, unsigned Min = 0);</td>
    <td class="lineNumber">384</td>
    <td class="codeline">LegalizeMutation moreElementsToNextPow2(unsigned TypeIdx, unsigned Min = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">/// Break up the vector type for the given type index into the element type.</td>
    <td class="lineNumber">385</td>
    <td class="codeline">/// Break up the vector type for the given type index into the element type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">LegalizeMutation scalarize(unsigned TypeIdx);</td>
    <td class="lineNumber">386</td>
    <td class="codeline">LegalizeMutation scalarize(unsigned TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">} // end namespace LegalizeMutations</td>
    <td class="lineNumber">387</td>
    <td class="codeline">} // end namespace LegalizeMutations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">/// A single rule in a legalizer info ruleset.</td>
    <td class="lineNumber">389</td>
    <td class="codeline">/// A single rule in a legalizer info ruleset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">/// The specified action is chosen when the predicate is true. Where appropriate</td>
    <td class="lineNumber">390</td>
    <td class="codeline">/// The specified action is chosen when the predicate is true. Where appropriate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">/// for the action (e.g. for WidenScalar) the new type is selected using the</td>
    <td class="lineNumber">391</td>
    <td class="codeline">/// for the action (e.g. for WidenScalar) the new type is selected using the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">/// given mutator.</td>
    <td class="lineNumber">392</td>
    <td class="codeline">/// given mutator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">class LegalizeRule {</td>
    <td class="lineNumber">393</td>
    <td class="codeline">class LegalizeRule {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  LegalityPredicate Predicate;</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  LegalityPredicate Predicate;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">  LegalizeAction Action;</td>
    <td class="lineNumber">395</td>
    <td class="codeline">  LegalizeAction Action;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  LegalizeMutation Mutation;</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  LegalizeMutation Mutation;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline"></td>
    <td class="lineNumber">397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">398</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">  LegalizeRule(LegalityPredicate Predicate, LegalizeAction Action,</td>
    <td class="lineNumber">399</td>
    <td class="codeline">  LegalizeRule(LegalityPredicate Predicate, LegalizeAction Action,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">               LegalizeMutation Mutation = nullptr)</td>
    <td class="lineNumber">400</td>
    <td class="codeline">               LegalizeMutation Mutation = nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">      : Predicate(Predicate), Action(Action), Mutation(Mutation) {}</td>
    <td class="lineNumber">401</td>
    <td class="codeline">      : Predicate(Predicate), Action(Action), Mutation(Mutation) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  /// Test whether the LegalityQuery matches.</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  /// Test whether the LegalityQuery matches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  bool match(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  bool match(const LegalityQuery &Query) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">    return Predicate(Query);</td>
    <td class="lineNumber">405</td>
    <td class="codeline">    return Predicate(Query);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">406</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline"></td>
    <td class="lineNumber">407</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">  LegalizeAction getAction() const { return Action; }</td>
    <td class="lineNumber">408</td>
    <td class="codeline">  LegalizeAction getAction() const { return Action; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">  /// Determine the change to make.</td>
    <td class="lineNumber">410</td>
    <td class="codeline">  /// Determine the change to make.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  std::pair<unsigned, LLT> determineMutation(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  std::pair<unsigned, LLT> determineMutation(const LegalityQuery &Query) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">    if (Mutation)</td>
    <td class="lineNumber">412</td>
    <td class="codeline">    if (Mutation)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">      return Mutation(Query);</td>
    <td class="lineNumber">413</td>
    <td class="codeline">      return Mutation(Query);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">    return std::make_pair(0, LLT{});</td>
    <td class="lineNumber">414</td>
    <td class="codeline">    return std::make_pair(0, LLT{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">};</td>
    <td class="lineNumber">416</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline"></td>
    <td class="lineNumber">417</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">class LegalizeRuleSet {</td>
    <td class="lineNumber">418</td>
    <td class="codeline">class LegalizeRuleSet {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">  /// When non-zero, the opcode we are an alias of</td>
    <td class="lineNumber">419</td>
    <td class="codeline">  /// When non-zero, the opcode we are an alias of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">  unsigned AliasOf = 0;</td>
    <td class="lineNumber">420</td>
    <td class="codeline">  unsigned AliasOf = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">  /// If true, there is another opcode that aliases this one</td>
    <td class="lineNumber">421</td>
    <td class="codeline">  /// If true, there is another opcode that aliases this one</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  bool IsAliasedByAnother = false;</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  bool IsAliasedByAnother = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  SmallVector<LegalizeRule, 2> Rules;</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  SmallVector<LegalizeRule, 2> Rules;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline"></td>
    <td class="lineNumber">424</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">425</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  /// If bit I is set, this rule set contains a rule that may handle (predicate</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  /// If bit I is set, this rule set contains a rule that may handle (predicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  /// or perform an action upon (or both)) the type index I. The uncertainty</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  /// or perform an action upon (or both)) the type index I. The uncertainty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  /// comes from free-form rules executing user-provided lambda functions. We</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  /// comes from free-form rules executing user-provided lambda functions. We</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  /// conservatively assume such rules do the right thing and cover all type</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  /// conservatively assume such rules do the right thing and cover all type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  /// indices. The bitset is intentionally 1 bit wider than it absolutely needs</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  /// indices. The bitset is intentionally 1 bit wider than it absolutely needs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  /// to be to distinguish such cases from the cases where all type indices are</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  /// to be to distinguish such cases from the cases where all type indices are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  /// individually handled.</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  /// individually handled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  SmallBitVector TypeIdxsCovered{MCOI::OPERAND_LAST_GENERIC -</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  SmallBitVector TypeIdxsCovered{MCOI::OPERAND_LAST_GENERIC -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">                                 MCOI::OPERAND_FIRST_GENERIC + 2};</td>
    <td class="lineNumber">434</td>
    <td class="codeline">                                 MCOI::OPERAND_FIRST_GENERIC + 2};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  SmallBitVector ImmIdxsCovered{MCOI::OPERAND_LAST_GENERIC_IMM -</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  SmallBitVector ImmIdxsCovered{MCOI::OPERAND_LAST_GENERIC_IMM -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">                                MCOI::OPERAND_FIRST_GENERIC_IMM + 2};</td>
    <td class="lineNumber">436</td>
    <td class="codeline">                                MCOI::OPERAND_FIRST_GENERIC_IMM + 2};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">437</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  unsigned typeIdx(unsigned TypeIdx) {</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  unsigned typeIdx(unsigned TypeIdx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">    assert(TypeIdx <=</td>
    <td class="lineNumber">440</td>
    <td class="codeline">    assert(TypeIdx <=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">               (MCOI::OPERAND_LAST_GENERIC - MCOI::OPERAND_FIRST_GENERIC) &&</td>
    <td class="lineNumber">441</td>
    <td class="codeline">               (MCOI::OPERAND_LAST_GENERIC - MCOI::OPERAND_FIRST_GENERIC) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">           "Type Index is out of bounds");</td>
    <td class="lineNumber">442</td>
    <td class="codeline">           "Type Index is out of bounds");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">443</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">    TypeIdxsCovered.set(TypeIdx);</td>
    <td class="lineNumber">444</td>
    <td class="codeline">    TypeIdxsCovered.set(TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">445</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">    return TypeIdx;</td>
    <td class="lineNumber">446</td>
    <td class="codeline">    return TypeIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">447</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  void markAllIdxsAsCovered() {</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  void markAllIdxsAsCovered() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">450</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">    TypeIdxsCovered.set();</td>
    <td class="lineNumber">451</td>
    <td class="codeline">    TypeIdxsCovered.set();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">    ImmIdxsCovered.set();</td>
    <td class="lineNumber">452</td>
    <td class="codeline">    ImmIdxsCovered.set();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">453</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">  void add(const LegalizeRule &Rule) {</td>
    <td class="lineNumber">456</td>
    <td class="codeline">  void add(const LegalizeRule &Rule) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">    assert(AliasOf == 0 &&</td>
    <td class="lineNumber">457</td>
    <td class="codeline">    assert(AliasOf == 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">           "RuleSet is aliased, change the representative opcode instead");</td>
    <td class="lineNumber">458</td>
    <td class="codeline">           "RuleSet is aliased, change the representative opcode instead");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">    Rules.push_back(Rule);</td>
    <td class="lineNumber">459</td>
    <td class="codeline">    Rules.push_back(Rule);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">460</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline"></td>
    <td class="lineNumber">461</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">  static bool always(const LegalityQuery &) { return true; }</td>
    <td class="lineNumber">462</td>
    <td class="codeline">  static bool always(const LegalityQuery &) { return true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  /// Use the given action when the predicate is true.</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  /// Use the given action when the predicate is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">  LegalizeRuleSet &actionIf(LegalizeAction Action,</td>
    <td class="lineNumber">466</td>
    <td class="codeline">  LegalizeRuleSet &actionIf(LegalizeAction Action,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">                            LegalityPredicate Predicate) {</td>
    <td class="lineNumber">467</td>
    <td class="codeline">                            LegalityPredicate Predicate) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">    add({Predicate, Action});</td>
    <td class="lineNumber">468</td>
    <td class="codeline">    add({Predicate, Action});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">469</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">  /// Use the given action when the predicate is true.</td>
    <td class="lineNumber">471</td>
    <td class="codeline">  /// Use the given action when the predicate is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  /// Action should be an action that requires mutation.</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  /// Action should be an action that requires mutation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  LegalizeRuleSet &actionIf(LegalizeAction Action, LegalityPredicate Predicate,</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  LegalizeRuleSet &actionIf(LegalizeAction Action, LegalityPredicate Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">                            LegalizeMutation Mutation) {</td>
    <td class="lineNumber">474</td>
    <td class="codeline">                            LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">    add({Predicate, Action, Mutation});</td>
    <td class="lineNumber">475</td>
    <td class="codeline">    add({Predicate, Action, Mutation});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">476</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  /// Use the given action when type index 0 is any type in the given list.</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  /// Use the given action when type index 0 is any type in the given list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">480</td>
    <td class="codeline">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">                             std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">481</td>
    <td class="codeline">                             std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">482</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">    return actionIf(Action, typeInSet(typeIdx(0), Types));</td>
    <td class="lineNumber">483</td>
    <td class="codeline">    return actionIf(Action, typeInSet(typeIdx(0), Types));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">  /// Use the given action when type index 0 is any type in the given list.</td>
    <td class="lineNumber">485</td>
    <td class="codeline">  /// Use the given action when type index 0 is any type in the given list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  /// Action should be an action that requires mutation.</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  /// Action should be an action that requires mutation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">                             std::initializer_list<LLT> Types,</td>
    <td class="lineNumber">488</td>
    <td class="codeline">                             std::initializer_list<LLT> Types,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">                             LegalizeMutation Mutation) {</td>
    <td class="lineNumber">489</td>
    <td class="codeline">                             LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">490</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">    return actionIf(Action, typeInSet(typeIdx(0), Types), Mutation);</td>
    <td class="lineNumber">491</td>
    <td class="codeline">    return actionIf(Action, typeInSet(typeIdx(0), Types), Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  /// Use the given action when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  /// Use the given action when type indexes 0 and 1 is any type pair in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  /// given list.</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  /// given list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">                             std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">497</td>
    <td class="codeline">                             std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">498</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">500</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">  /// Use the given action when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">501</td>
    <td class="codeline">  /// Use the given action when type indexes 0 and 1 is any type pair in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">  /// given list.</td>
    <td class="lineNumber">502</td>
    <td class="codeline">  /// given list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">  /// Action should be an action that requires mutation.</td>
    <td class="lineNumber">503</td>
    <td class="codeline">  /// Action should be an action that requires mutation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">504</td>
    <td class="codeline">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">                             std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td class="lineNumber">505</td>
    <td class="codeline">                             std::initializer_list<std::pair<LLT, LLT>> Types,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">                             LegalizeMutation Mutation) {</td>
    <td class="lineNumber">506</td>
    <td class="codeline">                             LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">507</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types),</td>
    <td class="lineNumber">508</td>
    <td class="codeline">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">                    Mutation);</td>
    <td class="lineNumber">509</td>
    <td class="codeline">                    Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  /// Use the given action when type index 0 is any type in the given list and</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  /// Use the given action when type index 0 is any type in the given list and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  /// imm index 0 is anything. Action should not be an action that requires</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  /// imm index 0 is anything. Action should not be an action that requires</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">  /// mutation.</td>
    <td class="lineNumber">513</td>
    <td class="codeline">  /// mutation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  LegalizeRuleSet &actionForTypeWithAnyImm(LegalizeAction Action,</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  LegalizeRuleSet &actionForTypeWithAnyImm(LegalizeAction Action,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">                                           std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">515</td>
    <td class="codeline">                                           std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">516</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">    immIdx(0); // Inform verifier imm idx 0 is handled.</td>
    <td class="lineNumber">517</td>
    <td class="codeline">    immIdx(0); // Inform verifier imm idx 0 is handled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">    return actionIf(Action, typeInSet(typeIdx(0), Types));</td>
    <td class="lineNumber">518</td>
    <td class="codeline">    return actionIf(Action, typeInSet(typeIdx(0), Types));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  LegalizeRuleSet &actionForTypeWithAnyImm(</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  LegalizeRuleSet &actionForTypeWithAnyImm(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">    LegalizeAction Action, std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">522</td>
    <td class="codeline">    LegalizeAction Action, std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">523</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">    immIdx(0); // Inform verifier imm idx 0 is handled.</td>
    <td class="lineNumber">524</td>
    <td class="codeline">    immIdx(0); // Inform verifier imm idx 0 is handled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));</td>
    <td class="lineNumber">525</td>
    <td class="codeline">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">526</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline"></td>
    <td class="lineNumber">527</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">  /// Use the given action when type indexes 0 and 1 are both in the given list.</td>
    <td class="lineNumber">528</td>
    <td class="codeline">  /// Use the given action when type indexes 0 and 1 are both in the given list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">  /// That is, the type pair is in the cartesian product of the list.</td>
    <td class="lineNumber">529</td>
    <td class="codeline">  /// That is, the type pair is in the cartesian product of the list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  LegalizeRuleSet &actionForCartesianProduct(LegalizeAction Action,</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  LegalizeRuleSet &actionForCartesianProduct(LegalizeAction Action,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">                                             std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">532</td>
    <td class="codeline">                                             std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">533</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">    return actionIf(Action, all(typeInSet(typeIdx(0), Types),</td>
    <td class="lineNumber">534</td>
    <td class="codeline">    return actionIf(Action, all(typeInSet(typeIdx(0), Types),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">                                typeInSet(typeIdx(1), Types)));</td>
    <td class="lineNumber">535</td>
    <td class="codeline">                                typeInSet(typeIdx(1), Types)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  /// Use the given action when type indexes 0 and 1 are both in their</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  /// Use the given action when type indexes 0 and 1 are both in their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">  /// respective lists.</td>
    <td class="lineNumber">538</td>
    <td class="codeline">  /// respective lists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  /// That is, the type pair is in the cartesian product of the lists</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  /// That is, the type pair is in the cartesian product of the lists</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">540</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  LegalizeRuleSet &</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  LegalizeRuleSet &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  actionForCartesianProduct(LegalizeAction Action,</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  actionForCartesianProduct(LegalizeAction Action,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">                            std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">543</td>
    <td class="codeline">                            std::initializer_list<LLT> Types0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">544</td>
    <td class="codeline">                            std::initializer_list<LLT> Types1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">545</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),</td>
    <td class="lineNumber">546</td>
    <td class="codeline">    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">                                typeInSet(typeIdx(1), Types1)));</td>
    <td class="lineNumber">547</td>
    <td class="codeline">                                typeInSet(typeIdx(1), Types1)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">  /// Use the given action when type indexes 0, 1, and 2 are all in their</td>
    <td class="lineNumber">549</td>
    <td class="codeline">  /// Use the given action when type indexes 0, 1, and 2 are all in their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  /// respective lists.</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  /// respective lists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">  /// That is, the type triple is in the cartesian product of the lists</td>
    <td class="lineNumber">551</td>
    <td class="codeline">  /// That is, the type triple is in the cartesian product of the lists</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  /// Action should not be an action that requires mutation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">  LegalizeRuleSet &actionForCartesianProduct(</td>
    <td class="lineNumber">553</td>
    <td class="codeline">  LegalizeRuleSet &actionForCartesianProduct(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">      LegalizeAction Action, std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">554</td>
    <td class="codeline">      LegalizeAction Action, std::initializer_list<LLT> Types0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">      std::initializer_list<LLT> Types1, std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">555</td>
    <td class="codeline">      std::initializer_list<LLT> Types1, std::initializer_list<LLT> Types2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">556</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),</td>
    <td class="lineNumber">557</td>
    <td class="codeline">    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">                                all(typeInSet(typeIdx(1), Types1),</td>
    <td class="lineNumber">558</td>
    <td class="codeline">                                all(typeInSet(typeIdx(1), Types1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">                                    typeInSet(typeIdx(2), Types2))));</td>
    <td class="lineNumber">559</td>
    <td class="codeline">                                    typeInSet(typeIdx(2), Types2))));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">560</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline"></td>
    <td class="lineNumber">561</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">562</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  LegalizeRuleSet() = default;</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  LegalizeRuleSet() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline"></td>
    <td class="lineNumber">564</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">  bool isAliasedByAnother() { return IsAliasedByAnother; }</td>
    <td class="lineNumber">565</td>
    <td class="codeline">  bool isAliasedByAnother() { return IsAliasedByAnother; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">  void setIsAliasedByAnother() { IsAliasedByAnother = true; }</td>
    <td class="lineNumber">566</td>
    <td class="codeline">  void setIsAliasedByAnother() { IsAliasedByAnother = true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">  void aliasTo(unsigned Opcode) {</td>
    <td class="lineNumber">567</td>
    <td class="codeline">  void aliasTo(unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">    assert((AliasOf == 0 || AliasOf == Opcode) &&</td>
    <td class="lineNumber">568</td>
    <td class="codeline">    assert((AliasOf == 0 || AliasOf == Opcode) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">           "Opcode is already aliased to another opcode");</td>
    <td class="lineNumber">569</td>
    <td class="codeline">           "Opcode is already aliased to another opcode");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">    assert(Rules.empty() && "Aliasing will discard rules");</td>
    <td class="lineNumber">570</td>
    <td class="codeline">    assert(Rules.empty() && "Aliasing will discard rules");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">    AliasOf = Opcode;</td>
    <td class="lineNumber">571</td>
    <td class="codeline">    AliasOf = Opcode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">572</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">  unsigned getAlias() const { return AliasOf; }</td>
    <td class="lineNumber">573</td>
    <td class="codeline">  unsigned getAlias() const { return AliasOf; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline"></td>
    <td class="lineNumber">574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">  unsigned immIdx(unsigned ImmIdx) {</td>
    <td class="lineNumber">575</td>
    <td class="codeline">  unsigned immIdx(unsigned ImmIdx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">    assert(ImmIdx <= (MCOI::OPERAND_LAST_GENERIC_IMM -</td>
    <td class="lineNumber">576</td>
    <td class="codeline">    assert(ImmIdx <= (MCOI::OPERAND_LAST_GENERIC_IMM -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">                      MCOI::OPERAND_FIRST_GENERIC_IMM) &&</td>
    <td class="lineNumber">577</td>
    <td class="codeline">                      MCOI::OPERAND_FIRST_GENERIC_IMM) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">           "Imm Index is out of bounds");</td>
    <td class="lineNumber">578</td>
    <td class="codeline">           "Imm Index is out of bounds");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">579</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">    ImmIdxsCovered.set(ImmIdx);</td>
    <td class="lineNumber">580</td>
    <td class="codeline">    ImmIdxsCovered.set(ImmIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">581</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">    return ImmIdx;</td>
    <td class="lineNumber">582</td>
    <td class="codeline">    return ImmIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">583</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  /// The instruction is legal if predicate is true.</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  /// The instruction is legal if predicate is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">  LegalizeRuleSet &legalIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">586</td>
    <td class="codeline">  LegalizeRuleSet &legalIf(LegalityPredicate Predicate) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">    // We have no choice but conservatively assume that the free-form</td>
    <td class="lineNumber">587</td>
    <td class="codeline">    // We have no choice but conservatively assume that the free-form</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">    // user-provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">588</td>
    <td class="codeline">    // user-provided Predicate properly handles all type indices:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">589</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">    return actionIf(LegalizeAction::Legal, Predicate);</td>
    <td class="lineNumber">590</td>
    <td class="codeline">    return actionIf(LegalizeAction::Legal, Predicate);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">591</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">  /// The instruction is legal when type index 0 is any type in the given list.</td>
    <td class="lineNumber">592</td>
    <td class="codeline">  /// The instruction is legal when type index 0 is any type in the given list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">  LegalizeRuleSet &legalFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">593</td>
    <td class="codeline">  LegalizeRuleSet &legalFor(std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">    return actionFor(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">594</td>
    <td class="codeline">    return actionFor(LegalizeAction::Legal, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">595</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  /// The instruction is legal when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  /// The instruction is legal when type indexes 0 and 1 is any type pair in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">  /// given list.</td>
    <td class="lineNumber">597</td>
    <td class="codeline">  /// given list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">  LegalizeRuleSet &legalFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">598</td>
    <td class="codeline">  LegalizeRuleSet &legalFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">    return actionFor(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">599</td>
    <td class="codeline">    return actionFor(LegalizeAction::Legal, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">  /// The instruction is legal when type index 0 is any type in the given list</td>
    <td class="lineNumber">601</td>
    <td class="codeline">  /// The instruction is legal when type index 0 is any type in the given list</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">  /// and imm index 0 is anything.</td>
    <td class="lineNumber">602</td>
    <td class="codeline">  /// and imm index 0 is anything.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">  LegalizeRuleSet &legalForTypeWithAnyImm(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">603</td>
    <td class="codeline">  LegalizeRuleSet &legalForTypeWithAnyImm(std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">604</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">606</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
    <td class="lineNumber">607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">  LegalizeRuleSet &legalForTypeWithAnyImm(</td>
    <td class="lineNumber">608</td>
    <td class="codeline">  LegalizeRuleSet &legalForTypeWithAnyImm(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">    std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">609</td>
    <td class="codeline">    std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">610</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">611</td>
    <td class="codeline">    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">612</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">  /// The instruction is legal when type indexes 0 and 1 along with the memory</td>
    <td class="lineNumber">614</td>
    <td class="codeline">  /// The instruction is legal when type indexes 0 and 1 along with the memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  /// size and minimum alignment is any type and size tuple in the given list.</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  /// size and minimum alignment is any type and size tuple in the given list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  LegalizeRuleSet &legalForTypesWithMemDesc(</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  LegalizeRuleSet &legalForTypesWithMemDesc(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">      std::initializer_list<LegalityPredicates::TypePairAndMemDesc></td>
    <td class="lineNumber">617</td>
    <td class="codeline">      std::initializer_list<LegalityPredicates::TypePairAndMemDesc></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">          TypesAndMemDesc) {</td>
    <td class="lineNumber">618</td>
    <td class="codeline">          TypesAndMemDesc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">    return actionIf(LegalizeAction::Legal,</td>
    <td class="lineNumber">619</td>
    <td class="codeline">    return actionIf(LegalizeAction::Legal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">                    LegalityPredicates::typePairAndMemDescInSet(</td>
    <td class="lineNumber">620</td>
    <td class="codeline">                    LegalityPredicates::typePairAndMemDescInSet(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">                        typeIdx(0), typeIdx(1), /*MMOIdx*/ 0, TypesAndMemDesc));</td>
    <td class="lineNumber">621</td>
    <td class="codeline">                        typeIdx(0), typeIdx(1), /*MMOIdx*/ 0, TypesAndMemDesc));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">622</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  /// The instruction is legal when type indexes 0 and 1 are both in the given</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  /// The instruction is legal when type indexes 0 and 1 are both in the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  /// list. That is, the type pair is in the cartesian product of the list.</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  /// list. That is, the type pair is in the cartesian product of the list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">626</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Legal, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">  /// The instruction is legal when type indexes 0 and 1 are both their</td>
    <td class="lineNumber">628</td>
    <td class="codeline">  /// The instruction is legal when type indexes 0 and 1 are both their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  /// respective lists.</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  /// respective lists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">630</td>
    <td class="codeline">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">631</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1);</td>
    <td class="lineNumber">632</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  /// The instruction is legal when type indexes 0, 1, and 2 are both their</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  /// The instruction is legal when type indexes 0, 1, and 2 are both their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">  /// respective lists.</td>
    <td class="lineNumber">635</td>
    <td class="codeline">  /// respective lists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">636</td>
    <td class="codeline">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types1,</td>
    <td class="lineNumber">637</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">638</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1,</td>
    <td class="lineNumber">639</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">                                     Types2);</td>
    <td class="lineNumber">640</td>
    <td class="codeline">                                     Types2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline"></td>
    <td class="lineNumber">642</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  LegalizeRuleSet &alwaysLegal() {</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  LegalizeRuleSet &alwaysLegal() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">644</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">645</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">    return actionIf(LegalizeAction::Legal, always);</td>
    <td class="lineNumber">646</td>
    <td class="codeline">    return actionIf(LegalizeAction::Legal, always);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  /// The specified type index is coerced if predicate is true.</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  /// The specified type index is coerced if predicate is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">  LegalizeRuleSet &bitcastIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">650</td>
    <td class="codeline">  LegalizeRuleSet &bitcastIf(LegalityPredicate Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">                             LegalizeMutation Mutation) {</td>
    <td class="lineNumber">651</td>
    <td class="codeline">                             LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">    // We have no choice but conservatively assume that lowering with a</td>
    <td class="lineNumber">652</td>
    <td class="codeline">    // We have no choice but conservatively assume that lowering with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">653</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">654</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">    return actionIf(LegalizeAction::Bitcast, Predicate, Mutation);</td>
    <td class="lineNumber">655</td>
    <td class="codeline">    return actionIf(LegalizeAction::Bitcast, Predicate, Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  /// The instruction is lowered.</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  /// The instruction is lowered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">  LegalizeRuleSet &lower() {</td>
    <td class="lineNumber">659</td>
    <td class="codeline">  LegalizeRuleSet &lower() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">660</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">    // We have no choice but conservatively assume that predicate-less lowering</td>
    <td class="lineNumber">661</td>
    <td class="codeline">    // We have no choice but conservatively assume that predicate-less lowering</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">    // properly handles all type indices by design:</td>
    <td class="lineNumber">662</td>
    <td class="codeline">    // properly handles all type indices by design:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">663</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">    return actionIf(LegalizeAction::Lower, always);</td>
    <td class="lineNumber">664</td>
    <td class="codeline">    return actionIf(LegalizeAction::Lower, always);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">665</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  /// The instruction is lowered if predicate is true. Keep type index 0 as the</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  /// The instruction is lowered if predicate is true. Keep type index 0 as the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  /// same type.</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  /// same type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">669</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">    // We have no choice but conservatively assume that lowering with a</td>
    <td class="lineNumber">670</td>
    <td class="codeline">    // We have no choice but conservatively assume that lowering with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">671</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">672</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">    return actionIf(LegalizeAction::Lower, Predicate);</td>
    <td class="lineNumber">673</td>
    <td class="codeline">    return actionIf(LegalizeAction::Lower, Predicate);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">  /// The instruction is lowered if predicate is true.</td>
    <td class="lineNumber">675</td>
    <td class="codeline">  /// The instruction is lowered if predicate is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">676</td>
    <td class="codeline">  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">                           LegalizeMutation Mutation) {</td>
    <td class="lineNumber">677</td>
    <td class="codeline">                           LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">    // We have no choice but conservatively assume that lowering with a</td>
    <td class="lineNumber">678</td>
    <td class="codeline">    // We have no choice but conservatively assume that lowering with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">679</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">680</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">    return actionIf(LegalizeAction::Lower, Predicate, Mutation);</td>
    <td class="lineNumber">681</td>
    <td class="codeline">    return actionIf(LegalizeAction::Lower, Predicate, Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">  /// The instruction is lowered when type index 0 is any type in the given</td>
    <td class="lineNumber">683</td>
    <td class="codeline">  /// The instruction is lowered when type index 0 is any type in the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  /// list. Keep type index 0 as the same type.</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  /// list. Keep type index 0 as the same type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">685</td>
    <td class="codeline">  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">    return actionFor(LegalizeAction::Lower, Types);</td>
    <td class="lineNumber">686</td>
    <td class="codeline">    return actionFor(LegalizeAction::Lower, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  /// The instruction is lowered when type index 0 is any type in the given</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  /// The instruction is lowered when type index 0 is any type in the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  /// list.</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  /// list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types,</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">                            LegalizeMutation Mutation) {</td>
    <td class="lineNumber">691</td>
    <td class="codeline">                            LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">    return actionFor(LegalizeAction::Lower, Types, Mutation);</td>
    <td class="lineNumber">692</td>
    <td class="codeline">    return actionFor(LegalizeAction::Lower, Types, Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  /// The instruction is lowered when type indexes 0 and 1 is any type pair in</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  /// The instruction is lowered when type indexes 0 and 1 is any type pair in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  /// the given list. Keep type index 0 as the same type.</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  /// the given list. Keep type index 0 as the same type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">    return actionFor(LegalizeAction::Lower, Types);</td>
    <td class="lineNumber">697</td>
    <td class="codeline">    return actionFor(LegalizeAction::Lower, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  /// The instruction is lowered when type indexes 0 and 1 is any type pair in</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  /// The instruction is lowered when type indexes 0 and 1 is any type pair in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  /// the given list.</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  /// the given list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td class="lineNumber">701</td>
    <td class="codeline">  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">                            LegalizeMutation Mutation) {</td>
    <td class="lineNumber">702</td>
    <td class="codeline">                            LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">    return actionFor(LegalizeAction::Lower, Types, Mutation);</td>
    <td class="lineNumber">703</td>
    <td class="codeline">    return actionFor(LegalizeAction::Lower, Types, Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">704</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">  /// The instruction is lowered when type indexes 0 and 1 are both in their</td>
    <td class="lineNumber">705</td>
    <td class="codeline">  /// The instruction is lowered when type indexes 0 and 1 are both in their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">  /// respective lists.</td>
    <td class="lineNumber">706</td>
    <td class="codeline">  /// respective lists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">708</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">709</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1);</td>
    <td class="lineNumber">710</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">711</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">  /// The instruction is lowered when when type indexes 0, 1, and 2 are all in</td>
    <td class="lineNumber">712</td>
    <td class="codeline">  /// The instruction is lowered when when type indexes 0, 1, and 2 are all in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">  /// their respective lists.</td>
    <td class="lineNumber">713</td>
    <td class="codeline">  /// their respective lists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types1,</td>
    <td class="lineNumber">715</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">716</td>
    <td class="codeline">                                            std::initializer_list<LLT> Types2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">717</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1,</td>
    <td class="lineNumber">718</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">                                     Types2);</td>
    <td class="lineNumber">719</td>
    <td class="codeline">                                     Types2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">720</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline"></td>
    <td class="lineNumber">721</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">  /// The instruction is emitted as a library call.</td>
    <td class="lineNumber">722</td>
    <td class="codeline">  /// The instruction is emitted as a library call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  LegalizeRuleSet &libcall() {</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  LegalizeRuleSet &libcall() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">724</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">    // We have no choice but conservatively assume that predicate-less lowering</td>
    <td class="lineNumber">725</td>
    <td class="codeline">    // We have no choice but conservatively assume that predicate-less lowering</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">    // properly handles all type indices by design:</td>
    <td class="lineNumber">726</td>
    <td class="codeline">    // properly handles all type indices by design:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">727</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">    return actionIf(LegalizeAction::Libcall, always);</td>
    <td class="lineNumber">728</td>
    <td class="codeline">    return actionIf(LegalizeAction::Libcall, always);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">729</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline"></td>
    <td class="lineNumber">730</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">  /// Like legalIf, but for the Libcall action.</td>
    <td class="lineNumber">731</td>
    <td class="codeline">  /// Like legalIf, but for the Libcall action.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">  LegalizeRuleSet &libcallIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">732</td>
    <td class="codeline">  LegalizeRuleSet &libcallIf(LegalityPredicate Predicate) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">    // We have no choice but conservatively assume that a libcall with a</td>
    <td class="lineNumber">733</td>
    <td class="codeline">    // We have no choice but conservatively assume that a libcall with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">734</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">735</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">    return actionIf(LegalizeAction::Libcall, Predicate);</td>
    <td class="lineNumber">736</td>
    <td class="codeline">    return actionIf(LegalizeAction::Libcall, Predicate);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">737</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  LegalizeRuleSet &libcallFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  LegalizeRuleSet &libcallFor(std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">    return actionFor(LegalizeAction::Libcall, Types);</td>
    <td class="lineNumber">739</td>
    <td class="codeline">    return actionFor(LegalizeAction::Libcall, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">740</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">  LegalizeRuleSet &</td>
    <td class="lineNumber">741</td>
    <td class="codeline">  LegalizeRuleSet &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">  libcallFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">742</td>
    <td class="codeline">  libcallFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">    return actionFor(LegalizeAction::Libcall, Types);</td>
    <td class="lineNumber">743</td>
    <td class="codeline">    return actionFor(LegalizeAction::Libcall, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">744</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">  LegalizeRuleSet &</td>
    <td class="lineNumber">745</td>
    <td class="codeline">  LegalizeRuleSet &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  libcallForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  libcallForCartesianProduct(std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Libcall, Types);</td>
    <td class="lineNumber">747</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Libcall, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">  LegalizeRuleSet &</td>
    <td class="lineNumber">749</td>
    <td class="codeline">  LegalizeRuleSet &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">  libcallForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">750</td>
    <td class="codeline">  libcallForCartesianProduct(std::initializer_list<LLT> Types0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">                             std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">751</td>
    <td class="codeline">                             std::initializer_list<LLT> Types1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Libcall, Types0, Types1);</td>
    <td class="lineNumber">752</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Libcall, Types0, Types1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">753</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline"></td>
    <td class="lineNumber">754</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">  /// Widen the scalar to the one selected by the mutation if the predicate is</td>
    <td class="lineNumber">755</td>
    <td class="codeline">  /// Widen the scalar to the one selected by the mutation if the predicate is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">  /// true.</td>
    <td class="lineNumber">756</td>
    <td class="codeline">  /// true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">  LegalizeRuleSet &widenScalarIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">757</td>
    <td class="codeline">  LegalizeRuleSet &widenScalarIf(LegalityPredicate Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">                                 LegalizeMutation Mutation) {</td>
    <td class="lineNumber">758</td>
    <td class="codeline">                                 LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">759</td>
    <td class="codeline">    // We have no choice but conservatively assume that an action with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">760</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">761</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">    return actionIf(LegalizeAction::WidenScalar, Predicate, Mutation);</td>
    <td class="lineNumber">762</td>
    <td class="codeline">    return actionIf(LegalizeAction::WidenScalar, Predicate, Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">763</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">  /// Narrow the scalar to the one selected by the mutation if the predicate is</td>
    <td class="lineNumber">764</td>
    <td class="codeline">  /// Narrow the scalar to the one selected by the mutation if the predicate is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">  /// true.</td>
    <td class="lineNumber">765</td>
    <td class="codeline">  /// true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">  LegalizeRuleSet &narrowScalarIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">766</td>
    <td class="codeline">  LegalizeRuleSet &narrowScalarIf(LegalityPredicate Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">                                  LegalizeMutation Mutation) {</td>
    <td class="lineNumber">767</td>
    <td class="codeline">                                  LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">768</td>
    <td class="codeline">    // We have no choice but conservatively assume that an action with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">769</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">770</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">    return actionIf(LegalizeAction::NarrowScalar, Predicate, Mutation);</td>
    <td class="lineNumber">771</td>
    <td class="codeline">    return actionIf(LegalizeAction::NarrowScalar, Predicate, Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">772</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">  /// Narrow the scalar, specified in mutation, when type indexes 0 and 1 is any</td>
    <td class="lineNumber">773</td>
    <td class="codeline">  /// Narrow the scalar, specified in mutation, when type indexes 0 and 1 is any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">  /// type pair in the given list.</td>
    <td class="lineNumber">774</td>
    <td class="codeline">  /// type pair in the given list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">  LegalizeRuleSet &</td>
    <td class="lineNumber">775</td>
    <td class="codeline">  LegalizeRuleSet &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">  narrowScalarFor(std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td class="lineNumber">776</td>
    <td class="codeline">  narrowScalarFor(std::initializer_list<std::pair<LLT, LLT>> Types,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">                  LegalizeMutation Mutation) {</td>
    <td class="lineNumber">777</td>
    <td class="codeline">                  LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">    return actionFor(LegalizeAction::NarrowScalar, Types, Mutation);</td>
    <td class="lineNumber">778</td>
    <td class="codeline">    return actionFor(LegalizeAction::NarrowScalar, Types, Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">779</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline"></td>
    <td class="lineNumber">780</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">  /// Add more elements to reach the type selected by the mutation if the</td>
    <td class="lineNumber">781</td>
    <td class="codeline">  /// Add more elements to reach the type selected by the mutation if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  /// predicate is true.</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  /// predicate is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">  LegalizeRuleSet &moreElementsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">783</td>
    <td class="codeline">  LegalizeRuleSet &moreElementsIf(LegalityPredicate Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">                                  LegalizeMutation Mutation) {</td>
    <td class="lineNumber">784</td>
    <td class="codeline">                                  LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">785</td>
    <td class="codeline">    // We have no choice but conservatively assume that an action with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">786</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">787</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">    return actionIf(LegalizeAction::MoreElements, Predicate, Mutation);</td>
    <td class="lineNumber">788</td>
    <td class="codeline">    return actionIf(LegalizeAction::MoreElements, Predicate, Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">789</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">  /// Remove elements to reach the type selected by the mutation if the</td>
    <td class="lineNumber">790</td>
    <td class="codeline">  /// Remove elements to reach the type selected by the mutation if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">  /// predicate is true.</td>
    <td class="lineNumber">791</td>
    <td class="codeline">  /// predicate is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">  LegalizeRuleSet &fewerElementsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">792</td>
    <td class="codeline">  LegalizeRuleSet &fewerElementsIf(LegalityPredicate Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">                                   LegalizeMutation Mutation) {</td>
    <td class="lineNumber">793</td>
    <td class="codeline">                                   LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">794</td>
    <td class="codeline">    // We have no choice but conservatively assume that an action with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">795</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">796</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">    return actionIf(LegalizeAction::FewerElements, Predicate, Mutation);</td>
    <td class="lineNumber">797</td>
    <td class="codeline">    return actionIf(LegalizeAction::FewerElements, Predicate, Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">798</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline"></td>
    <td class="lineNumber">799</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">  /// The instruction is unsupported.</td>
    <td class="lineNumber">800</td>
    <td class="codeline">  /// The instruction is unsupported.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">  LegalizeRuleSet &unsupported() {</td>
    <td class="lineNumber">801</td>
    <td class="codeline">  LegalizeRuleSet &unsupported() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">802</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">    return actionIf(LegalizeAction::Unsupported, always);</td>
    <td class="lineNumber">803</td>
    <td class="codeline">    return actionIf(LegalizeAction::Unsupported, always);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">804</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">  LegalizeRuleSet &unsupportedIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">805</td>
    <td class="codeline">  LegalizeRuleSet &unsupportedIf(LegalityPredicate Predicate) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">    return actionIf(LegalizeAction::Unsupported, Predicate);</td>
    <td class="lineNumber">806</td>
    <td class="codeline">    return actionIf(LegalizeAction::Unsupported, Predicate);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">807</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline"></td>
    <td class="lineNumber">808</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">  LegalizeRuleSet &unsupportedFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">809</td>
    <td class="codeline">  LegalizeRuleSet &unsupportedFor(std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">    return actionFor(LegalizeAction::Unsupported, Types);</td>
    <td class="lineNumber">810</td>
    <td class="codeline">    return actionFor(LegalizeAction::Unsupported, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  LegalizeRuleSet &unsupportedIfMemSizeNotPow2() {</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  LegalizeRuleSet &unsupportedIfMemSizeNotPow2() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">    return actionIf(LegalizeAction::Unsupported,</td>
    <td class="lineNumber">814</td>
    <td class="codeline">    return actionIf(LegalizeAction::Unsupported,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">                    LegalityPredicates::memSizeInBytesNotPow2(0));</td>
    <td class="lineNumber">815</td>
    <td class="codeline">                    LegalityPredicates::memSizeInBytesNotPow2(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">816</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline"></td>
    <td class="lineNumber">817</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">  /// Lower a memory operation if the memory size, rounded to bytes, is not a</td>
    <td class="lineNumber">818</td>
    <td class="codeline">  /// Lower a memory operation if the memory size, rounded to bytes, is not a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  /// power of 2. For example, this will not trigger for s1 or s7, but will for</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  /// power of 2. For example, this will not trigger for s1 or s7, but will for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  /// s24.</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  /// s24.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  LegalizeRuleSet &lowerIfMemSizeNotPow2() {</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  LegalizeRuleSet &lowerIfMemSizeNotPow2() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">    return actionIf(LegalizeAction::Lower,</td>
    <td class="lineNumber">822</td>
    <td class="codeline">    return actionIf(LegalizeAction::Lower,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">                    LegalityPredicates::memSizeInBytesNotPow2(0));</td>
    <td class="lineNumber">823</td>
    <td class="codeline">                    LegalityPredicates::memSizeInBytesNotPow2(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline"></td>
    <td class="lineNumber">825</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  /// Lower a memory operation if the memory access size is not a round power of</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  /// Lower a memory operation if the memory access size is not a round power of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">  /// 2 byte size. This is stricter than lowerIfMemSizeNotPow2, and more likely</td>
    <td class="lineNumber">827</td>
    <td class="codeline">  /// 2 byte size. This is stricter than lowerIfMemSizeNotPow2, and more likely</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">  /// what you want (e.g. this will lower s1, s7 and s24).</td>
    <td class="lineNumber">828</td>
    <td class="codeline">  /// what you want (e.g. this will lower s1, s7 and s24).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  LegalizeRuleSet &lowerIfMemSizeNotByteSizePow2() {</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  LegalizeRuleSet &lowerIfMemSizeNotByteSizePow2() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">    return actionIf(LegalizeAction::Lower,</td>
    <td class="lineNumber">830</td>
    <td class="codeline">    return actionIf(LegalizeAction::Lower,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">                    LegalityPredicates::memSizeNotByteSizePow2(0));</td>
    <td class="lineNumber">831</td>
    <td class="codeline">                    LegalityPredicates::memSizeNotByteSizePow2(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  LegalizeRuleSet &customIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  LegalizeRuleSet &customIf(LegalityPredicate Predicate) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">    // We have no choice but conservatively assume that a custom action with a</td>
    <td class="lineNumber">835</td>
    <td class="codeline">    // We have no choice but conservatively assume that a custom action with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">836</td>
    <td class="codeline">    // free-form user provided Predicate properly handles all type indices:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">837</td>
    <td class="codeline">    markAllIdxsAsCovered();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">    return actionIf(LegalizeAction::Custom, Predicate);</td>
    <td class="lineNumber">838</td>
    <td class="codeline">    return actionIf(LegalizeAction::Custom, Predicate);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">839</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">  LegalizeRuleSet &customFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">840</td>
    <td class="codeline">  LegalizeRuleSet &customFor(std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">    return actionFor(LegalizeAction::Custom, Types);</td>
    <td class="lineNumber">841</td>
    <td class="codeline">    return actionFor(LegalizeAction::Custom, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">842</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline"></td>
    <td class="lineNumber">843</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">  /// The instruction is custom when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">844</td>
    <td class="codeline">  /// The instruction is custom when type indexes 0 and 1 is any type pair in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  /// given list.</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  /// given list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  LegalizeRuleSet &customFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  LegalizeRuleSet &customFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">    return actionFor(LegalizeAction::Custom, Types);</td>
    <td class="lineNumber">847</td>
    <td class="codeline">    return actionFor(LegalizeAction::Custom, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">  LegalizeRuleSet &customForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">850</td>
    <td class="codeline">  LegalizeRuleSet &customForCartesianProduct(std::initializer_list<LLT> Types) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Custom, Types);</td>
    <td class="lineNumber">851</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Custom, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">852</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  /// The instruction is custom when type indexes 0 and 1 are both in their</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  /// The instruction is custom when type indexes 0 and 1 are both in their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">  /// respective lists.</td>
    <td class="lineNumber">854</td>
    <td class="codeline">  /// respective lists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">  LegalizeRuleSet &</td>
    <td class="lineNumber">855</td>
    <td class="codeline">  LegalizeRuleSet &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">  customForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">856</td>
    <td class="codeline">  customForCartesianProduct(std::initializer_list<LLT> Types0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">857</td>
    <td class="codeline">                            std::initializer_list<LLT> Types1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Custom, Types0, Types1);</td>
    <td class="lineNumber">858</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Custom, Types0, Types1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">859</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  /// The instruction is custom when when type indexes 0, 1, and 2 are all in</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  /// The instruction is custom when when type indexes 0, 1, and 2 are all in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">  /// their respective lists.</td>
    <td class="lineNumber">861</td>
    <td class="codeline">  /// their respective lists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">  LegalizeRuleSet &</td>
    <td class="lineNumber">862</td>
    <td class="codeline">  LegalizeRuleSet &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  customForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  customForCartesianProduct(std::initializer_list<LLT> Types0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">                            std::initializer_list<LLT> Types1,</td>
    <td class="lineNumber">864</td>
    <td class="codeline">                            std::initializer_list<LLT> Types1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">                            std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">865</td>
    <td class="codeline">                            std::initializer_list<LLT> Types2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Custom, Types0, Types1,</td>
    <td class="lineNumber">866</td>
    <td class="codeline">    return actionForCartesianProduct(LegalizeAction::Custom, Types0, Types1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">                                     Types2);</td>
    <td class="lineNumber">867</td>
    <td class="codeline">                                     Types2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline"></td>
    <td class="lineNumber">869</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  /// Unconditionally custom lower.</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  /// Unconditionally custom lower.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">  LegalizeRuleSet &custom() {</td>
    <td class="lineNumber">871</td>
    <td class="codeline">  LegalizeRuleSet &custom() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">    return customIf(always);</td>
    <td class="lineNumber">872</td>
    <td class="codeline">    return customIf(always);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  /// Widen the scalar to the next power of two that is at least MinSize.</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  /// Widen the scalar to the next power of two that is at least MinSize.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  /// No effect if the type is not a scalar or is a power of two.</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  /// No effect if the type is not a scalar or is a power of two.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">  LegalizeRuleSet &widenScalarToNextPow2(unsigned TypeIdx,</td>
    <td class="lineNumber">877</td>
    <td class="codeline">  LegalizeRuleSet &widenScalarToNextPow2(unsigned TypeIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">                                         unsigned MinSize = 0) {</td>
    <td class="lineNumber">878</td>
    <td class="codeline">                                         unsigned MinSize = 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">879</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">    return actionIf(</td>
    <td class="lineNumber">880</td>
    <td class="codeline">    return actionIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">        LegalizeAction::WidenScalar, sizeNotPow2(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">881</td>
    <td class="codeline">        LegalizeAction::WidenScalar, sizeNotPow2(typeIdx(TypeIdx)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));</td>
    <td class="lineNumber">882</td>
    <td class="codeline">        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">883</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline"></td>
    <td class="lineNumber">884</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">  /// Widen the scalar to the next multiple of Size. No effect if the</td>
    <td class="lineNumber">885</td>
    <td class="codeline">  /// Widen the scalar to the next multiple of Size. No effect if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">  /// type is not a scalar or is a multiple of Size.</td>
    <td class="lineNumber">886</td>
    <td class="codeline">  /// type is not a scalar or is a multiple of Size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  LegalizeRuleSet &widenScalarToNextMultipleOf(unsigned TypeIdx,</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  LegalizeRuleSet &widenScalarToNextMultipleOf(unsigned TypeIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">                                               unsigned Size) {</td>
    <td class="lineNumber">888</td>
    <td class="codeline">                                               unsigned Size) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">889</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">    return actionIf(</td>
    <td class="lineNumber">890</td>
    <td class="codeline">    return actionIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">        LegalizeAction::WidenScalar, sizeNotMultipleOf(typeIdx(TypeIdx), Size),</td>
    <td class="lineNumber">891</td>
    <td class="codeline">        LegalizeAction::WidenScalar, sizeNotMultipleOf(typeIdx(TypeIdx), Size),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">        LegalizeMutations::widenScalarOrEltToNextMultipleOf(TypeIdx, Size));</td>
    <td class="lineNumber">892</td>
    <td class="codeline">        LegalizeMutations::widenScalarOrEltToNextMultipleOf(TypeIdx, Size));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">893</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">  /// Widen the scalar or vector element type to the next power of two that is</td>
    <td class="lineNumber">895</td>
    <td class="codeline">  /// Widen the scalar or vector element type to the next power of two that is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">  /// at least MinSize.  No effect if the scalar size is a power of two.</td>
    <td class="lineNumber">896</td>
    <td class="codeline">  /// at least MinSize.  No effect if the scalar size is a power of two.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">  LegalizeRuleSet &widenScalarOrEltToNextPow2(unsigned TypeIdx,</td>
    <td class="lineNumber">897</td>
    <td class="codeline">  LegalizeRuleSet &widenScalarOrEltToNextPow2(unsigned TypeIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">                                              unsigned MinSize = 0) {</td>
    <td class="lineNumber">898</td>
    <td class="codeline">                                              unsigned MinSize = 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">899</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">    return actionIf(</td>
    <td class="lineNumber">900</td>
    <td class="codeline">    return actionIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">        LegalizeAction::WidenScalar, scalarOrEltSizeNotPow2(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">901</td>
    <td class="codeline">        LegalizeAction::WidenScalar, scalarOrEltSizeNotPow2(typeIdx(TypeIdx)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));</td>
    <td class="lineNumber">902</td>
    <td class="codeline">        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">903</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">  LegalizeRuleSet &narrowScalar(unsigned TypeIdx, LegalizeMutation Mutation) {</td>
    <td class="lineNumber">905</td>
    <td class="codeline">  LegalizeRuleSet &narrowScalar(unsigned TypeIdx, LegalizeMutation Mutation) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">906</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">    return actionIf(LegalizeAction::NarrowScalar, isScalar(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">907</td>
    <td class="codeline">    return actionIf(LegalizeAction::NarrowScalar, isScalar(typeIdx(TypeIdx)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">                    Mutation);</td>
    <td class="lineNumber">908</td>
    <td class="codeline">                    Mutation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">909</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline"></td>
    <td class="lineNumber">910</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">  LegalizeRuleSet &scalarize(unsigned TypeIdx) {</td>
    <td class="lineNumber">911</td>
    <td class="codeline">  LegalizeRuleSet &scalarize(unsigned TypeIdx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">912</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">    return actionIf(LegalizeAction::FewerElements, isVector(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">913</td>
    <td class="codeline">    return actionIf(LegalizeAction::FewerElements, isVector(typeIdx(TypeIdx)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">                    LegalizeMutations::scalarize(TypeIdx));</td>
    <td class="lineNumber">914</td>
    <td class="codeline">                    LegalizeMutations::scalarize(TypeIdx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">915</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">  LegalizeRuleSet &scalarizeIf(LegalityPredicate Predicate, unsigned TypeIdx) {</td>
    <td class="lineNumber">917</td>
    <td class="codeline">  LegalizeRuleSet &scalarizeIf(LegalityPredicate Predicate, unsigned TypeIdx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">918</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">    return actionIf(LegalizeAction::FewerElements,</td>
    <td class="lineNumber">919</td>
    <td class="codeline">    return actionIf(LegalizeAction::FewerElements,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">                    all(Predicate, isVector(typeIdx(TypeIdx))),</td>
    <td class="lineNumber">920</td>
    <td class="codeline">                    all(Predicate, isVector(typeIdx(TypeIdx))),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">                    LegalizeMutations::scalarize(TypeIdx));</td>
    <td class="lineNumber">921</td>
    <td class="codeline">                    LegalizeMutations::scalarize(TypeIdx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">922</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">  /// Ensure the scalar or element is at least as wide as Ty.</td>
    <td class="lineNumber">924</td>
    <td class="codeline">  /// Ensure the scalar or element is at least as wide as Ty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">  LegalizeRuleSet &minScalarOrElt(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">925</td>
    <td class="codeline">  LegalizeRuleSet &minScalarOrElt(unsigned TypeIdx, const LLT Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">926</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">927</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">928</td>
    <td class="codeline">    return actionIf(LegalizeAction::WidenScalar,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">                    scalarOrEltNarrowerThan(TypeIdx, Ty.getScalarSizeInBits()),</td>
    <td class="lineNumber">929</td>
    <td class="codeline">                    scalarOrEltNarrowerThan(TypeIdx, Ty.getScalarSizeInBits()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">930</td>
    <td class="codeline">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">931</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline"></td>
    <td class="lineNumber">932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">  /// Ensure the scalar or element is at least as wide as Ty.</td>
    <td class="lineNumber">933</td>
    <td class="codeline">  /// Ensure the scalar or element is at least as wide as Ty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">  LegalizeRuleSet &minScalarOrEltIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">934</td>
    <td class="codeline">  LegalizeRuleSet &minScalarOrEltIf(LegalityPredicate Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">                                    unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">935</td>
    <td class="codeline">                                    unsigned TypeIdx, const LLT Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">936</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">937</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">938</td>
    <td class="codeline">    return actionIf(LegalizeAction::WidenScalar,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">                    all(Predicate, scalarOrEltNarrowerThan(</td>
    <td class="lineNumber">939</td>
    <td class="codeline">                    all(Predicate, scalarOrEltNarrowerThan(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">                                       TypeIdx, Ty.getScalarSizeInBits())),</td>
    <td class="lineNumber">940</td>
    <td class="codeline">                                       TypeIdx, Ty.getScalarSizeInBits())),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">941</td>
    <td class="codeline">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">942</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline"></td>
    <td class="lineNumber">943</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">  /// Ensure the vector size is at least as wide as VectorSize by promoting the</td>
    <td class="lineNumber">944</td>
    <td class="codeline">  /// Ensure the vector size is at least as wide as VectorSize by promoting the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">  /// element.</td>
    <td class="lineNumber">945</td>
    <td class="codeline">  /// element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">  LegalizeRuleSet &widenVectorEltsToVectorMinSize(unsigned TypeIdx,</td>
    <td class="lineNumber">946</td>
    <td class="codeline">  LegalizeRuleSet &widenVectorEltsToVectorMinSize(unsigned TypeIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">                                                  unsigned VectorSize) {</td>
    <td class="lineNumber">947</td>
    <td class="codeline">                                                  unsigned VectorSize) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">948</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">949</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">    return actionIf(</td>
    <td class="lineNumber">950</td>
    <td class="codeline">    return actionIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">        LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">951</td>
    <td class="codeline">        LegalizeAction::WidenScalar,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">952</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">          const LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">953</td>
    <td class="codeline">          const LLT VecTy = Query.Types[TypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">          return VecTy.isVector() && !VecTy.isScalable() &&</td>
    <td class="lineNumber">954</td>
    <td class="codeline">          return VecTy.isVector() && !VecTy.isScalable() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">                 VecTy.getSizeInBits() < VectorSize;</td>
    <td class="lineNumber">955</td>
    <td class="codeline">                 VecTy.getSizeInBits() < VectorSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">        },</td>
    <td class="lineNumber">956</td>
    <td class="codeline">        },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">957</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">          const LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">958</td>
    <td class="codeline">          const LLT VecTy = Query.Types[TypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">          unsigned NumElts = VecTy.getNumElements();</td>
    <td class="lineNumber">959</td>
    <td class="codeline">          unsigned NumElts = VecTy.getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">          unsigned MinSize = VectorSize / NumElts;</td>
    <td class="lineNumber">960</td>
    <td class="codeline">          unsigned MinSize = VectorSize / NumElts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">          LLT NewTy = LLT::fixed_vector(NumElts, LLT::scalar(MinSize));</td>
    <td class="lineNumber">961</td>
    <td class="codeline">          LLT NewTy = LLT::fixed_vector(NumElts, LLT::scalar(MinSize));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">          return std::make_pair(TypeIdx, NewTy);</td>
    <td class="lineNumber">962</td>
    <td class="codeline">          return std::make_pair(TypeIdx, NewTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">963</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  /// Ensure the scalar is at least as wide as Ty.</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  /// Ensure the scalar is at least as wide as Ty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  LegalizeRuleSet &minScalar(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  LegalizeRuleSet &minScalar(unsigned TypeIdx, const LLT Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">968</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">969</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">970</td>
    <td class="codeline">    return actionIf(LegalizeAction::WidenScalar,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">                    scalarNarrowerThan(TypeIdx, Ty.getSizeInBits()),</td>
    <td class="lineNumber">971</td>
    <td class="codeline">                    scalarNarrowerThan(TypeIdx, Ty.getSizeInBits()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">                    changeTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">972</td>
    <td class="codeline">                    changeTo(typeIdx(TypeIdx), Ty));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">973</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline"></td>
    <td class="lineNumber">974</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">  /// Ensure the scalar is at least as wide as Ty if condition is met.</td>
    <td class="lineNumber">975</td>
    <td class="codeline">  /// Ensure the scalar is at least as wide as Ty if condition is met.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">  LegalizeRuleSet &minScalarIf(LegalityPredicate Predicate, unsigned TypeIdx,</td>
    <td class="lineNumber">976</td>
    <td class="codeline">  LegalizeRuleSet &minScalarIf(LegalityPredicate Predicate, unsigned TypeIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">                               const LLT Ty) {</td>
    <td class="lineNumber">977</td>
    <td class="codeline">                               const LLT Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">978</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">979</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">    return actionIf(</td>
    <td class="lineNumber">980</td>
    <td class="codeline">    return actionIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">        LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">981</td>
    <td class="codeline">        LegalizeAction::WidenScalar,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">982</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">          const LLT QueryTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">983</td>
    <td class="codeline">          const LLT QueryTy = Query.Types[TypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">          return QueryTy.isScalar() &&</td>
    <td class="lineNumber">984</td>
    <td class="codeline">          return QueryTy.isScalar() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">                 QueryTy.getSizeInBits() < Ty.getSizeInBits() &&</td>
    <td class="lineNumber">985</td>
    <td class="codeline">                 QueryTy.getSizeInBits() < Ty.getSizeInBits() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">                 Predicate(Query);</td>
    <td class="lineNumber">986</td>
    <td class="codeline">                 Predicate(Query);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">        },</td>
    <td class="lineNumber">987</td>
    <td class="codeline">        },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">        changeTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">988</td>
    <td class="codeline">        changeTo(typeIdx(TypeIdx), Ty));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline"></td>
    <td class="lineNumber">990</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">  /// Ensure the scalar is at most as wide as Ty.</td>
    <td class="lineNumber">991</td>
    <td class="codeline">  /// Ensure the scalar is at most as wide as Ty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">  LegalizeRuleSet &maxScalarOrElt(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">992</td>
    <td class="codeline">  LegalizeRuleSet &maxScalarOrElt(unsigned TypeIdx, const LLT Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">993</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">994</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">    return actionIf(LegalizeAction::NarrowScalar,</td>
    <td class="lineNumber">995</td>
    <td class="codeline">    return actionIf(LegalizeAction::NarrowScalar,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">                    scalarOrEltWiderThan(TypeIdx, Ty.getScalarSizeInBits()),</td>
    <td class="lineNumber">996</td>
    <td class="codeline">                    scalarOrEltWiderThan(TypeIdx, Ty.getScalarSizeInBits()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">997</td>
    <td class="codeline">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline"></td>
    <td class="lineNumber">999</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">  /// Ensure the scalar is at most as wide as Ty.</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">  /// Ensure the scalar is at most as wide as Ty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">  LegalizeRuleSet &maxScalar(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">  LegalizeRuleSet &maxScalar(unsigned TypeIdx, const LLT Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">    return actionIf(LegalizeAction::NarrowScalar,</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">    return actionIf(LegalizeAction::NarrowScalar,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">                    scalarWiderThan(TypeIdx, Ty.getSizeInBits()),</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">                    scalarWiderThan(TypeIdx, Ty.getSizeInBits()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">                    changeTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">                    changeTo(typeIdx(TypeIdx), Ty));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline"></td>
    <td class="lineNumber">1008</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">  /// Conditionally limit the maximum size of the scalar.</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">  /// Conditionally limit the maximum size of the scalar.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">  /// For example, when the maximum size of one type depends on the size of</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">  /// For example, when the maximum size of one type depends on the size of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">  /// another such as extracting N bits from an M bit container.</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">  /// another such as extracting N bits from an M bit container.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">  LegalizeRuleSet &maxScalarIf(LegalityPredicate Predicate, unsigned TypeIdx,</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">  LegalizeRuleSet &maxScalarIf(LegalityPredicate Predicate, unsigned TypeIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">                               const LLT Ty) {</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">                               const LLT Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">    using namespace LegalizeMutations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">    return actionIf(</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">    return actionIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">        LegalizeAction::NarrowScalar,</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">        LegalizeAction::NarrowScalar,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">          const LLT QueryTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">          const LLT QueryTy = Query.Types[TypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">          return QueryTy.isScalar() &&</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">          return QueryTy.isScalar() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">                 QueryTy.getSizeInBits() > Ty.getSizeInBits() &&</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">                 QueryTy.getSizeInBits() > Ty.getSizeInBits() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">                 Predicate(Query);</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">                 Predicate(Query);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">        },</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">        },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">        changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">        changeElementTo(typeIdx(TypeIdx), Ty));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline"></td>
    <td class="lineNumber">1026</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  /// Limit the range of scalar sizes to MinTy and MaxTy.</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  /// Limit the range of scalar sizes to MinTy and MaxTy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  LegalizeRuleSet &clampScalar(unsigned TypeIdx, const LLT MinTy,</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  LegalizeRuleSet &clampScalar(unsigned TypeIdx, const LLT MinTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">                               const LLT MaxTy) {</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">                               const LLT MaxTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">    assert(MinTy.isScalar() && MaxTy.isScalar() && "Expected scalar types");</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">    assert(MinTy.isScalar() && MaxTy.isScalar() && "Expected scalar types");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">    return minScalar(TypeIdx, MinTy).maxScalar(TypeIdx, MaxTy);</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">    return minScalar(TypeIdx, MinTy).maxScalar(TypeIdx, MaxTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">  /// Limit the range of scalar sizes to MinTy and MaxTy.</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">  /// Limit the range of scalar sizes to MinTy and MaxTy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">  LegalizeRuleSet &clampScalarOrElt(unsigned TypeIdx, const LLT MinTy,</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">  LegalizeRuleSet &clampScalarOrElt(unsigned TypeIdx, const LLT MinTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">                                    const LLT MaxTy) {</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">                                    const LLT MaxTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">    return minScalarOrElt(TypeIdx, MinTy).maxScalarOrElt(TypeIdx, MaxTy);</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">    return minScalarOrElt(TypeIdx, MinTy).maxScalarOrElt(TypeIdx, MaxTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline"></td>
    <td class="lineNumber">1039</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">  /// Widen the scalar to match the size of another.</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">  /// Widen the scalar to match the size of another.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">  LegalizeRuleSet &minScalarSameAs(unsigned TypeIdx, unsigned LargeTypeIdx) {</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">  LegalizeRuleSet &minScalarSameAs(unsigned TypeIdx, unsigned LargeTypeIdx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">    return widenScalarIf(</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">    return widenScalarIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">          return Query.Types[LargeTypeIdx].getScalarSizeInBits() ></td>
    <td class="lineNumber">1045</td>
    <td class="codeline">          return Query.Types[LargeTypeIdx].getScalarSizeInBits() ></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">                 Query.Types[TypeIdx].getSizeInBits();</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">                 Query.Types[TypeIdx].getSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">        },</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">        },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">        LegalizeMutations::changeElementSizeTo(TypeIdx, LargeTypeIdx));</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">        LegalizeMutations::changeElementSizeTo(TypeIdx, LargeTypeIdx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline"></td>
    <td class="lineNumber">1050</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">  /// Narrow the scalar to match the size of another.</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">  /// Narrow the scalar to match the size of another.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">  LegalizeRuleSet &maxScalarSameAs(unsigned TypeIdx, unsigned NarrowTypeIdx) {</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">  LegalizeRuleSet &maxScalarSameAs(unsigned TypeIdx, unsigned NarrowTypeIdx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">    return narrowScalarIf(</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">    return narrowScalarIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">          return Query.Types[NarrowTypeIdx].getScalarSizeInBits() <</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">          return Query.Types[NarrowTypeIdx].getScalarSizeInBits() <</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">                 Query.Types[TypeIdx].getSizeInBits();</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">                 Query.Types[TypeIdx].getSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">        },</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">        },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">        LegalizeMutations::changeElementSizeTo(TypeIdx, NarrowTypeIdx));</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">        LegalizeMutations::changeElementSizeTo(TypeIdx, NarrowTypeIdx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline"></td>
    <td class="lineNumber">1061</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  /// Change the type \p TypeIdx to have the same scalar size as type \p</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  /// Change the type \p TypeIdx to have the same scalar size as type \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">  /// SameSizeIdx.</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">  /// SameSizeIdx.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">  LegalizeRuleSet &scalarSameSizeAs(unsigned TypeIdx, unsigned SameSizeIdx) {</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">  LegalizeRuleSet &scalarSameSizeAs(unsigned TypeIdx, unsigned SameSizeIdx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">    return minScalarSameAs(TypeIdx, SameSizeIdx)</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">    return minScalarSameAs(TypeIdx, SameSizeIdx)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">          .maxScalarSameAs(TypeIdx, SameSizeIdx);</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">          .maxScalarSameAs(TypeIdx, SameSizeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline"></td>
    <td class="lineNumber">1068</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">  /// Conditionally widen the scalar or elt to match the size of another.</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">  /// Conditionally widen the scalar or elt to match the size of another.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">  LegalizeRuleSet &minScalarEltSameAsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">  LegalizeRuleSet &minScalarEltSameAsIf(LegalityPredicate Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">                                   unsigned TypeIdx, unsigned LargeTypeIdx) {</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">                                   unsigned TypeIdx, unsigned LargeTypeIdx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">    return widenScalarIf(</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">    return widenScalarIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">          return Query.Types[LargeTypeIdx].getScalarSizeInBits() ></td>
    <td class="lineNumber">1075</td>
    <td class="codeline">          return Query.Types[LargeTypeIdx].getScalarSizeInBits() ></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">                     Query.Types[TypeIdx].getScalarSizeInBits() &&</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">                     Query.Types[TypeIdx].getScalarSizeInBits() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">                 Predicate(Query);</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">                 Predicate(Query);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">        },</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">        },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">          LLT T = Query.Types[LargeTypeIdx];</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">          LLT T = Query.Types[LargeTypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">          if (T.isVector() && T.getElementType().isPointer())</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">          if (T.isVector() && T.getElementType().isPointer())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">            T = T.changeElementType(LLT::scalar(T.getScalarSizeInBits()));</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">            T = T.changeElementType(LLT::scalar(T.getScalarSizeInBits()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">          return std::make_pair(TypeIdx, T);</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">          return std::make_pair(TypeIdx, T);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline"></td>
    <td class="lineNumber">1086</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">  /// Conditionally narrow the scalar or elt to match the size of another.</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">  /// Conditionally narrow the scalar or elt to match the size of another.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  LegalizeRuleSet &maxScalarEltSameAsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  LegalizeRuleSet &maxScalarEltSameAsIf(LegalityPredicate Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">                                        unsigned TypeIdx,</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">                                        unsigned TypeIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">                                        unsigned SmallTypeIdx) {</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">                                        unsigned SmallTypeIdx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">    return narrowScalarIf(</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">    return narrowScalarIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">          return Query.Types[SmallTypeIdx].getScalarSizeInBits() <</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">          return Query.Types[SmallTypeIdx].getScalarSizeInBits() <</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">                     Query.Types[TypeIdx].getScalarSizeInBits() &&</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">                     Query.Types[TypeIdx].getScalarSizeInBits() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">                 Predicate(Query);</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">                 Predicate(Query);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">        },</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">        },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">          LLT T = Query.Types[SmallTypeIdx];</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">          LLT T = Query.Types[SmallTypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">          return std::make_pair(TypeIdx, T);</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">          return std::make_pair(TypeIdx, T);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline"></td>
    <td class="lineNumber">1103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">  /// Add more elements to the vector to reach the next power of two.</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">  /// Add more elements to the vector to reach the next power of two.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  /// No effect if the type is not a vector or the element count is a power of</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  /// No effect if the type is not a vector or the element count is a power of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">  /// two.</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">  /// two.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">  LegalizeRuleSet &moreElementsToNextPow2(unsigned TypeIdx) {</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">  LegalizeRuleSet &moreElementsToNextPow2(unsigned TypeIdx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">    using namespace LegalityPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">    return actionIf(LegalizeAction::MoreElements,</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">    return actionIf(LegalizeAction::MoreElements,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">                    numElementsNotPow2(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">                    numElementsNotPow2(typeIdx(TypeIdx)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">                    LegalizeMutations::moreElementsToNextPow2(TypeIdx));</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">                    LegalizeMutations::moreElementsToNextPow2(TypeIdx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline"></td>
    <td class="lineNumber">1113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  /// Limit the number of elements in EltTy vectors to at least MinElements.</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  /// Limit the number of elements in EltTy vectors to at least MinElements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  LegalizeRuleSet &clampMinNumElements(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  LegalizeRuleSet &clampMinNumElements(unsigned TypeIdx, const LLT EltTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">                                       unsigned MinElements) {</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">                                       unsigned MinElements) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">    // Mark the type index as covered:</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">    // Mark the type index as covered:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">    return actionIf(</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">    return actionIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">        LegalizeAction::MoreElements,</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">        LegalizeAction::MoreElements,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">                 VecTy.getNumElements() < MinElements;</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">                 VecTy.getNumElements() < MinElements;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">        },</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">        },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">          return std::make_pair(</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">          return std::make_pair(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">              TypeIdx, LLT::fixed_vector(MinElements, VecTy.getElementType()));</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">              TypeIdx, LLT::fixed_vector(MinElements, VecTy.getElementType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline"></td>
    <td class="lineNumber">1132</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">  /// Set number of elements to nearest larger multiple of NumElts.</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">  /// Set number of elements to nearest larger multiple of NumElts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">  LegalizeRuleSet &alignNumElementsTo(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">  LegalizeRuleSet &alignNumElementsTo(unsigned TypeIdx, const LLT EltTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">                                      unsigned NumElts) {</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">                                      unsigned NumElts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">    return actionIf(</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">    return actionIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">        LegalizeAction::MoreElements,</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">        LegalizeAction::MoreElements,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">                 (VecTy.getNumElements() % NumElts != 0);</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">                 (VecTy.getNumElements() % NumElts != 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">        },</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">        },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">          unsigned NewSize = alignTo(VecTy.getNumElements(), NumElts);</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">          unsigned NewSize = alignTo(VecTy.getNumElements(), NumElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">          return std::make_pair(</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">          return std::make_pair(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">              TypeIdx, LLT::fixed_vector(NewSize, VecTy.getElementType()));</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">              TypeIdx, LLT::fixed_vector(NewSize, VecTy.getElementType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">  /// Limit the number of elements in EltTy vectors to at most MaxElements.</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">  /// Limit the number of elements in EltTy vectors to at most MaxElements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  LegalizeRuleSet &clampMaxNumElements(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  LegalizeRuleSet &clampMaxNumElements(unsigned TypeIdx, const LLT EltTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">                                       unsigned MaxElements) {</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">                                       unsigned MaxElements) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">    // Mark the type index as covered:</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">    // Mark the type index as covered:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">    typeIdx(TypeIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">    return actionIf(</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">    return actionIf(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">        LegalizeAction::FewerElements,</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">        LegalizeAction::FewerElements,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">                 VecTy.getNumElements() > MaxElements;</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">                 VecTy.getNumElements() > MaxElements;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">        },</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">        },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">        [=](const LegalityQuery &Query) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">          LLT VecTy = Query.Types[TypeIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">          LLT NewTy = LLT::scalarOrVector(ElementCount::getFixed(MaxElements),</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">          LLT NewTy = LLT::scalarOrVector(ElementCount::getFixed(MaxElements),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">                                          VecTy.getElementType());</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">                                          VecTy.getElementType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">          return std::make_pair(TypeIdx, NewTy);</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">          return std::make_pair(TypeIdx, NewTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  /// Limit the number of elements for the given vectors to at least MinTy's</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  /// Limit the number of elements for the given vectors to at least MinTy's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  /// number of elements and at most MaxTy's number of elements.</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  /// number of elements and at most MaxTy's number of elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">  /// No effect if the type is not a vector or does not have the same element</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">  /// No effect if the type is not a vector or does not have the same element</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">  /// type as the constraints.</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">  /// type as the constraints.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">  /// The element type of MinTy and MaxTy must match.</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">  /// The element type of MinTy and MaxTy must match.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">  LegalizeRuleSet &clampNumElements(unsigned TypeIdx, const LLT MinTy,</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">  LegalizeRuleSet &clampNumElements(unsigned TypeIdx, const LLT MinTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">                                    const LLT MaxTy) {</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">                                    const LLT MaxTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">    assert(MinTy.getElementType() == MaxTy.getElementType() &&</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">    assert(MinTy.getElementType() == MaxTy.getElementType() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">           "Expected element types to agree");</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">           "Expected element types to agree");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">    const LLT EltTy = MinTy.getElementType();</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">    const LLT EltTy = MinTy.getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">    return clampMinNumElements(TypeIdx, EltTy, MinTy.getNumElements())</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">    return clampMinNumElements(TypeIdx, EltTy, MinTy.getNumElements())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">        .clampMaxNumElements(TypeIdx, EltTy, MaxTy.getNumElements());</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">        .clampMaxNumElements(TypeIdx, EltTy, MaxTy.getNumElements());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">  /// Express \p EltTy vectors strictly using vectors with \p NumElts elements</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">  /// Express \p EltTy vectors strictly using vectors with \p NumElts elements</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">  /// (or scalars when \p NumElts equals 1).</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">  /// (or scalars when \p NumElts equals 1).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  /// First pad with undef elements to nearest larger multiple of \p NumElts.</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  /// First pad with undef elements to nearest larger multiple of \p NumElts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">  /// Then perform split with all sub-instructions having the same type.</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">  /// Then perform split with all sub-instructions having the same type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">  /// Using clampMaxNumElements (non-strict) can result in leftover instruction</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">  /// Using clampMaxNumElements (non-strict) can result in leftover instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">  /// with different type (fewer elements then \p NumElts or scalar).</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">  /// with different type (fewer elements then \p NumElts or scalar).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">  /// No effect if the type is not a vector.</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">  /// No effect if the type is not a vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">  LegalizeRuleSet &clampMaxNumElementsStrict(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">  LegalizeRuleSet &clampMaxNumElementsStrict(unsigned TypeIdx, const LLT EltTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">                                             unsigned NumElts) {</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">                                             unsigned NumElts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">    return alignNumElementsTo(TypeIdx, EltTy, NumElts)</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">    return alignNumElementsTo(TypeIdx, EltTy, NumElts)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">        .clampMaxNumElements(TypeIdx, EltTy, NumElts);</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">        .clampMaxNumElements(TypeIdx, EltTy, NumElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline"></td>
    <td class="lineNumber">1199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">  /// Fallback on the previous implementation. This should only be used while</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">  /// Fallback on the previous implementation. This should only be used while</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">  /// porting a rule.</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">  /// porting a rule.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">  LegalizeRuleSet &fallback() {</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">  LegalizeRuleSet &fallback() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">    add({always, LegalizeAction::UseLegacyRules});</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">    add({always, LegalizeAction::UseLegacyRules});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline"></td>
    <td class="lineNumber">1206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">  /// Check if there is no type index which is obviously not handled by the</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">  /// Check if there is no type index which is obviously not handled by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">  /// LegalizeRuleSet in any way at all.</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">  /// LegalizeRuleSet in any way at all.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">  /// \pre Type indices of the opcode form a dense [0, \p NumTypeIdxs) set.</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">  /// \pre Type indices of the opcode form a dense [0, \p NumTypeIdxs) set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">  bool verifyTypeIdxsCoverage(unsigned NumTypeIdxs) const;</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">  bool verifyTypeIdxsCoverage(unsigned NumTypeIdxs) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">  /// Check if there is no imm index which is obviously not handled by the</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">  /// Check if there is no imm index which is obviously not handled by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">  /// LegalizeRuleSet in any way at all.</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">  /// LegalizeRuleSet in any way at all.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">  /// \pre Type indices of the opcode form a dense [0, \p NumTypeIdxs) set.</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">  /// \pre Type indices of the opcode form a dense [0, \p NumTypeIdxs) set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  bool verifyImmIdxsCoverage(unsigned NumImmIdxs) const;</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  bool verifyImmIdxsCoverage(unsigned NumImmIdxs) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline"></td>
    <td class="lineNumber">1215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">  /// Apply the ruleset to the given LegalityQuery.</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">  /// Apply the ruleset to the given LegalityQuery.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">  LegalizeActionStep apply(const LegalityQuery &Query) const;</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">  LegalizeActionStep apply(const LegalityQuery &Query) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">class LegalizerInfo {</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">class LegalizerInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  virtual ~LegalizerInfo() = default;</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  virtual ~LegalizerInfo() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline"></td>
    <td class="lineNumber">1223</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  const LegacyLegalizerInfo &getLegacyLegalizerInfo() const {</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  const LegacyLegalizerInfo &getLegacyLegalizerInfo() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">    return LegacyInfo;</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">    return LegacyInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  LegacyLegalizerInfo &getLegacyLegalizerInfo() { return LegacyInfo; }</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  LegacyLegalizerInfo &getLegacyLegalizerInfo() { return LegacyInfo; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline"></td>
    <td class="lineNumber">1228</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">  unsigned getOpcodeIdxForOpcode(unsigned Opcode) const;</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">  unsigned getOpcodeIdxForOpcode(unsigned Opcode) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  unsigned getActionDefinitionsIdx(unsigned Opcode) const;</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  unsigned getActionDefinitionsIdx(unsigned Opcode) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  /// Perform simple self-diagnostic and assert if there is anything obviously</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  /// Perform simple self-diagnostic and assert if there is anything obviously</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">  /// wrong with the actions set up.</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">  /// wrong with the actions set up.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">  void verify(const MCInstrInfo &MII) const;</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">  void verify(const MCInstrInfo &MII) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline"></td>
    <td class="lineNumber">1235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">  /// Get the action definitions for the given opcode. Use this to run a</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">  /// Get the action definitions for the given opcode. Use this to run a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  /// LegalityQuery through the definitions.</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  /// LegalityQuery through the definitions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">  const LegalizeRuleSet &getActionDefinitions(unsigned Opcode) const;</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">  const LegalizeRuleSet &getActionDefinitions(unsigned Opcode) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline"></td>
    <td class="lineNumber">1239</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">  /// Get the action definition builder for the given opcode. Use this to define</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">  /// Get the action definition builder for the given opcode. Use this to define</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  /// the action definitions.</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  /// the action definitions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">  /// It is an error to request an opcode that has already been requested by the</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">  /// It is an error to request an opcode that has already been requested by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">  /// multiple-opcode variant.</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">  /// multiple-opcode variant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">  LegalizeRuleSet &getActionDefinitionsBuilder(unsigned Opcode);</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">  LegalizeRuleSet &getActionDefinitionsBuilder(unsigned Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline"></td>
    <td class="lineNumber">1246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">  /// Get the action definition builder for the given set of opcodes. Use this</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">  /// Get the action definition builder for the given set of opcodes. Use this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">  /// to define the action definitions for multiple opcodes at once. The first</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">  /// to define the action definitions for multiple opcodes at once. The first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">  /// opcode given will be considered the representative opcode and will hold</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">  /// opcode given will be considered the representative opcode and will hold</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">  /// the definitions whereas the other opcodes will be configured to refer to</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">  /// the definitions whereas the other opcodes will be configured to refer to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  /// the representative opcode. This lowers memory requirements and very</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  /// the representative opcode. This lowers memory requirements and very</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">  /// slightly improves performance.</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">  /// slightly improves performance.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">  /// It would be very easy to introduce unexpected side-effects as a result of</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">  /// It would be very easy to introduce unexpected side-effects as a result of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">  /// this aliasing if it were permitted to request different but intersecting</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">  /// this aliasing if it were permitted to request different but intersecting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  /// sets of opcodes but that is difficult to keep track of. It is therefore an</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  /// sets of opcodes but that is difficult to keep track of. It is therefore an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">  /// error to request the same opcode twice using this API, to request an</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">  /// error to request the same opcode twice using this API, to request an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  /// opcode that already has definitions, or to use the single-opcode API on an</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  /// opcode that already has definitions, or to use the single-opcode API on an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">  /// opcode that has already been requested by this API.</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">  /// opcode that has already been requested by this API.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  LegalizeRuleSet &</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  LegalizeRuleSet &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  getActionDefinitionsBuilder(std::initializer_list<unsigned> Opcodes);</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  getActionDefinitionsBuilder(std::initializer_list<unsigned> Opcodes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">  void aliasActionDefinitions(unsigned OpcodeTo, unsigned OpcodeFrom);</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">  void aliasActionDefinitions(unsigned OpcodeTo, unsigned OpcodeFrom);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline"></td>
    <td class="lineNumber">1263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">  /// Determine what action should be taken to legalize the described</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">  /// Determine what action should be taken to legalize the described</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">  /// instruction. Requires computeTables to have been called.</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">  /// instruction. Requires computeTables to have been called.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">  /// \returns a description of the next legalization step to perform.</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">  /// \returns a description of the next legalization step to perform.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">  LegalizeActionStep getAction(const LegalityQuery &Query) const;</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">  LegalizeActionStep getAction(const LegalityQuery &Query) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">  /// Determine what action should be taken to legalize the given generic</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">  /// Determine what action should be taken to legalize the given generic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">  /// instruction.</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">  /// instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">  /// \returns a description of the next legalization step to perform.</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">  /// \returns a description of the next legalization step to perform.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  LegalizeActionStep getAction(const MachineInstr &MI,</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  LegalizeActionStep getAction(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">                               const MachineRegisterInfo &MRI) const;</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">                               const MachineRegisterInfo &MRI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">  bool isLegal(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">  bool isLegal(const LegalityQuery &Query) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">    return getAction(Query).Action == LegalizeAction::Legal;</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">    return getAction(Query).Action == LegalizeAction::Legal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline"></td>
    <td class="lineNumber">1280</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  bool isLegalOrCustom(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  bool isLegalOrCustom(const LegalityQuery &Query) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">    auto Action = getAction(Query).Action;</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">    auto Action = getAction(Query).Action;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">    return Action == LegalizeAction::Legal || Action == LegalizeAction::Custom;</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">    return Action == LegalizeAction::Legal || Action == LegalizeAction::Custom;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">  bool isLegal(const MachineInstr &MI, const MachineRegisterInfo &MRI) const;</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">  bool isLegal(const MachineInstr &MI, const MachineRegisterInfo &MRI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  bool isLegalOrCustom(const MachineInstr &MI,</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  bool isLegalOrCustom(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">                       const MachineRegisterInfo &MRI) const;</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">                       const MachineRegisterInfo &MRI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline"></td>
    <td class="lineNumber">1289</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">  /// Called for instructions with the Custom LegalizationAction.</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">  /// Called for instructions with the Custom LegalizationAction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">  virtual bool legalizeCustom(LegalizerHelper &Helper,</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">  virtual bool legalizeCustom(LegalizerHelper &Helper,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">                              MachineInstr &MI) const {</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">                              MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">    llvm_unreachable("must implement this if custom action is used");</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">    llvm_unreachable("must implement this if custom action is used");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">  /// \returns true if MI is either legal or has been legalized and false if not</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">  /// \returns true if MI is either legal or has been legalized and false if not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">  /// legal.</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">  /// legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">  /// Return true if MI is either legal or has been legalized and false</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">  /// Return true if MI is either legal or has been legalized and false</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">  /// if not legal.</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">  /// if not legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">  virtual bool legalizeIntrinsic(LegalizerHelper &Helper,</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">  virtual bool legalizeIntrinsic(LegalizerHelper &Helper,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">                                 MachineInstr &MI) const {</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">                                 MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline"></td>
    <td class="lineNumber">1304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">  /// Return the opcode (SEXT/ZEXT/ANYEXT) that should be performed while</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">  /// Return the opcode (SEXT/ZEXT/ANYEXT) that should be performed while</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">  /// widening a constant of type SmallTy which targets can override.</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">  /// widening a constant of type SmallTy which targets can override.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">  /// For eg, the DAG does (SmallTy.isByteSized() ? G_SEXT : G_ZEXT) which</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">  /// For eg, the DAG does (SmallTy.isByteSized() ? G_SEXT : G_ZEXT) which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">  /// will be the default.</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">  /// will be the default.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">  virtual unsigned getExtOpcodeForWideningConstant(LLT SmallTy) const;</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">  virtual unsigned getExtOpcodeForWideningConstant(LLT SmallTy) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline"></td>
    <td class="lineNumber">1310</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">  static const int FirstOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_START;</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">  static const int FirstOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_START;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  static const int LastOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_END;</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  static const int LastOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_END;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline"></td>
    <td class="lineNumber">1314</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">  LegalizeRuleSet RulesForOpcode[LastOp - FirstOp + 1];</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">  LegalizeRuleSet RulesForOpcode[LastOp - FirstOp + 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">  LegacyLegalizerInfo LegacyInfo;</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">  LegacyLegalizerInfo LegacyInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline"></td>
    <td class="lineNumber">1318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">/// Checks that MIR is fully legal, returns an illegal instruction if it's not,</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">/// Checks that MIR is fully legal, returns an illegal instruction if it's not,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">/// nullptr otherwise</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">/// nullptr otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">const MachineInstr *machineFunctionIsIllegal(const MachineFunction &MF);</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">const MachineInstr *machineFunctionIsIllegal(const MachineFunction &MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">} // end namespace llvm.</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">} // end namespace llvm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline"></td>
    <td class="lineNumber">1326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">#endif // LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">#endif // LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline"></td>
    <td class="lineNumber">1328</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/CodeGen/GlobalISel/LegalizerInfo.h ------------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/CodeGen/GlobalISel/LegalizerInfo.h ------------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">/// Interface for Targets to specify which operations they can successfully</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">/// Interface for Targets to specify which operations they can successfully</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// select and how the others should be expanded most efficiently.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// select and how the others should be expanded most efficiently.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#define LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#define LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/SmallBitVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/SmallBitVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/CodeGen/LowLevelType.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/CodeGen/LowLevelType.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineMemOperand.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineMemOperand.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetOpcodes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetOpcodes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/MC/MCInstrDesc.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/MC/MCInstrDesc.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">extern cl::opt<bool> DisableGISelLegalityCheck;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">extern cl::opt<bool> DisableGISelLegalityCheck;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">class MachineFunction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">class MachineFunction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">class raw_ostream;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">class raw_ostream;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">class LegalizerHelper;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">class LegalizerHelper;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">class MachineInstr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">class MachineInstr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">class MachineRegisterInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">class MachineRegisterInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">class MCInstrInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">class MCInstrInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">namespace LegalizeActions {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">namespace LegalizeActions {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">enum LegalizeAction : std::uint8_t {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">enum LegalizeAction : std::uint8_t {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">  /// The operation is expected to be selectable directly by the target, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">  /// The operation is expected to be selectable directly by the target, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">  /// no transformation is necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">  /// no transformation is necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">  Legal,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">  Legal,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">  /// The operation should be synthesized from multiple instructions acting on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">  /// The operation should be synthesized from multiple instructions acting on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">  /// a narrower scalar base-type. For example a 64-bit add might be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">  /// a narrower scalar base-type. For example a 64-bit add might be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">  /// implemented in terms of 32-bit add-with-carry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">  /// implemented in terms of 32-bit add-with-carry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">  NarrowScalar,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">  NarrowScalar,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">  /// The operation should be implemented in terms of a wider scalar</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">  /// The operation should be implemented in terms of a wider scalar</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">  /// base-type. For example a <2 x s8> add could be implemented as a <2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">  /// base-type. For example a <2 x s8> add could be implemented as a <2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">  /// x s32> add (ignoring the high bits).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">  /// x s32> add (ignoring the high bits).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">  WidenScalar,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">  WidenScalar,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">  /// The (vector) operation should be implemented by splitting it into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">  /// The (vector) operation should be implemented by splitting it into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">  /// sub-vectors where the operation is legal. For example a <8 x s64> add</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">  /// sub-vectors where the operation is legal. For example a <8 x s64> add</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">  /// might be implemented as 4 separate <2 x s64> adds. There can be a leftover</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">  /// might be implemented as 4 separate <2 x s64> adds. There can be a leftover</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">  /// if there are not enough elements for last sub-vector e.g. <7 x s64> add</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">  /// if there are not enough elements for last sub-vector e.g. <7 x s64> add</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">  /// will be implemented as 3 separate <2 x s64> adds and one s64 add. Leftover</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">  /// will be implemented as 3 separate <2 x s64> adds and one s64 add. Leftover</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">  /// types can be avoided by doing MoreElements first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">  /// types can be avoided by doing MoreElements first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">  FewerElements,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">  FewerElements,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">  /// The (vector) operation should be implemented by widening the input</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">  /// The (vector) operation should be implemented by widening the input</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">  /// vector and ignoring the lanes added by doing so. For example <2 x i8> is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">  /// vector and ignoring the lanes added by doing so. For example <2 x i8> is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">  /// rarely legal, but you might perform an <8 x i8> and then only look at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">  /// rarely legal, but you might perform an <8 x i8> and then only look at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">  /// the first two results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">  /// the first two results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">  MoreElements,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">  MoreElements,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">  /// Perform the operation on a different, but equivalently sized type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">  /// Perform the operation on a different, but equivalently sized type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">  Bitcast,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">  Bitcast,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">  /// The operation itself must be expressed in terms of simpler actions on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">  /// The operation itself must be expressed in terms of simpler actions on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">  /// this target. E.g. a SREM replaced by an SDIV and subtraction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">  /// this target. E.g. a SREM replaced by an SDIV and subtraction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">  Lower,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">  Lower,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">  /// The operation should be implemented as a call to some kind of runtime</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">  /// The operation should be implemented as a call to some kind of runtime</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">  /// support library. For example this usually happens on machines that don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">  /// support library. For example this usually happens on machines that don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">  /// support floating-point operations natively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">  /// support floating-point operations natively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">  Libcall,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">  Libcall,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">  /// The target wants to do something special with this combination of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">  /// The target wants to do something special with this combination of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">  /// operand and type. A callback will be issued when it is needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">  /// operand and type. A callback will be issued when it is needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">  Custom,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">  Custom,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">  /// This operation is completely unsupported on the target. A programming</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">  /// This operation is completely unsupported on the target. A programming</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">  /// error has occurred.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">  /// error has occurred.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">  Unsupported,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">  Unsupported,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">  /// Sentinel value for when no action was found in the specified table.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">  /// Sentinel value for when no action was found in the specified table.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  NotFound,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  NotFound,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  /// Fall back onto the old rules.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  /// Fall back onto the old rules.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">  /// TODO: Remove this once we've migrated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">  /// TODO: Remove this once we've migrated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">  UseLegacyRules,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">  UseLegacyRules,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">} // end namespace LegalizeActions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">} // end namespace LegalizeActions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">raw_ostream &operator<<(raw_ostream &OS, LegalizeActions::LegalizeAction Action);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">raw_ostream &operator<<(raw_ostream &OS, LegalizeActions::LegalizeAction Action);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">using LegalizeActions::LegalizeAction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">using LegalizeActions::LegalizeAction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">/// The LegalityQuery object bundles together all the information that's needed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">/// The LegalityQuery object bundles together all the information that's needed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">/// to decide whether a given operation is legal or not.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">/// to decide whether a given operation is legal or not.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">/// For efficiency, it doesn't make a copy of Types so care must be taken not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">/// For efficiency, it doesn't make a copy of Types so care must be taken not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">/// to free it before using the query.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">/// to free it before using the query.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">struct LegalityQuery {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">struct LegalityQuery {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">  unsigned Opcode;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">  unsigned Opcode;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  ArrayRef<LLT> Types;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  ArrayRef<LLT> Types;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  struct MemDesc {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  struct MemDesc {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">    LLT MemoryTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">    LLT MemoryTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">    uint64_t AlignInBits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">    uint64_t AlignInBits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">    AtomicOrdering Ordering;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">    AtomicOrdering Ordering;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">    MemDesc() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">    MemDesc() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">    MemDesc(LLT MemoryTy, uint64_t AlignInBits, AtomicOrdering Ordering)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">    MemDesc(LLT MemoryTy, uint64_t AlignInBits, AtomicOrdering Ordering)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">        : MemoryTy(MemoryTy), AlignInBits(AlignInBits), Ordering(Ordering) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">        : MemoryTy(MemoryTy), AlignInBits(AlignInBits), Ordering(Ordering) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">    MemDesc(const MachineMemOperand &MMO)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">    MemDesc(const MachineMemOperand &MMO)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">        : MemoryTy(MMO.getMemoryType()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">        : MemoryTy(MMO.getMemoryType()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">          AlignInBits(MMO.getAlign().value() * 8),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">          AlignInBits(MMO.getAlign().value() * 8),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">          Ordering(MMO.getSuccessOrdering()) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">          Ordering(MMO.getSuccessOrdering()) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  /// Operations which require memory can use this to place requirements on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  /// Operations which require memory can use this to place requirements on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  /// memory type for each MMO.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  /// memory type for each MMO.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  ArrayRef<MemDesc> MMODescrs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  ArrayRef<MemDesc> MMODescrs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">                          const ArrayRef<MemDesc> MMODescrs)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">                          const ArrayRef<MemDesc> MMODescrs)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">      : Opcode(Opcode), Types(Types), MMODescrs(MMODescrs) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">      : Opcode(Opcode), Types(Types), MMODescrs(MMODescrs) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">      : LegalityQuery(Opcode, Types, {}) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">      : LegalityQuery(Opcode, Types, {}) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">  raw_ostream &print(raw_ostream &OS) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">  raw_ostream &print(raw_ostream &OS) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">/// The result of a query. It either indicates a final answer of Legal or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">/// The result of a query. It either indicates a final answer of Legal or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">/// Unsupported or describes an action that must be taken to make an operation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">/// Unsupported or describes an action that must be taken to make an operation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">/// more legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">/// more legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">struct LegalizeActionStep {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">struct LegalizeActionStep {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">  /// The action to take or the final answer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">  /// The action to take or the final answer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  LegalizeAction Action;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  LegalizeAction Action;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">  /// If describing an action, the type index to change. Otherwise zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">  /// If describing an action, the type index to change. Otherwise zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  unsigned TypeIdx;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  unsigned TypeIdx;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  /// If describing an action, the new type for TypeIdx. Otherwise LLT{}.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  /// If describing an action, the new type for TypeIdx. Otherwise LLT{}.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">  LLT NewType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">  LLT NewType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">  LegalizeActionStep(LegalizeAction Action, unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">  LegalizeActionStep(LegalizeAction Action, unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">                     const LLT NewType)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">                     const LLT NewType)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">      : Action(Action), TypeIdx(TypeIdx), NewType(NewType) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">      : Action(Action), TypeIdx(TypeIdx), NewType(NewType) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">  LegalizeActionStep(LegacyLegalizeActionStep Step)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">  LegalizeActionStep(LegacyLegalizeActionStep Step)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">      : TypeIdx(Step.TypeIdx), NewType(Step.NewType) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">      : TypeIdx(Step.TypeIdx), NewType(Step.NewType) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">    switch (Step.Action) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">    switch (Step.Action) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">    case LegacyLegalizeActions::Legal:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">    case LegacyLegalizeActions::Legal:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">      Action = LegalizeActions::Legal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">      Action = LegalizeActions::Legal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">    case LegacyLegalizeActions::NarrowScalar:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">    case LegacyLegalizeActions::NarrowScalar:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">      Action = LegalizeActions::NarrowScalar;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">      Action = LegalizeActions::NarrowScalar;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">    case LegacyLegalizeActions::WidenScalar:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">    case LegacyLegalizeActions::WidenScalar:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">      Action = LegalizeActions::WidenScalar;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">      Action = LegalizeActions::WidenScalar;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">    case LegacyLegalizeActions::FewerElements:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">    case LegacyLegalizeActions::FewerElements:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">      Action = LegalizeActions::FewerElements;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">      Action = LegalizeActions::FewerElements;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">    case LegacyLegalizeActions::MoreElements:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">    case LegacyLegalizeActions::MoreElements:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">      Action = LegalizeActions::MoreElements;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">      Action = LegalizeActions::MoreElements;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">    case LegacyLegalizeActions::Bitcast:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">    case LegacyLegalizeActions::Bitcast:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">      Action = LegalizeActions::Bitcast;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">      Action = LegalizeActions::Bitcast;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">    case LegacyLegalizeActions::Lower:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">    case LegacyLegalizeActions::Lower:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">      Action = LegalizeActions::Lower;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">      Action = LegalizeActions::Lower;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">    case LegacyLegalizeActions::Libcall:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">    case LegacyLegalizeActions::Libcall:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">      Action = LegalizeActions::Libcall;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">      Action = LegalizeActions::Libcall;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">    case LegacyLegalizeActions::Custom:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">    case LegacyLegalizeActions::Custom:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">      Action = LegalizeActions::Custom;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">      Action = LegalizeActions::Custom;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">    case LegacyLegalizeActions::Unsupported:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">    case LegacyLegalizeActions::Unsupported:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">      Action = LegalizeActions::Unsupported;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">      Action = LegalizeActions::Unsupported;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">    case LegacyLegalizeActions::NotFound:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">    case LegacyLegalizeActions::NotFound:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">      Action = LegalizeActions::NotFound;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">      Action = LegalizeActions::NotFound;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  bool operator==(const LegalizeActionStep &RHS) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  bool operator==(const LegalizeActionStep &RHS) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">    return std::tie(Action, TypeIdx, NewType) ==</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">    return std::tie(Action, TypeIdx, NewType) ==</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">        std::tie(RHS.Action, RHS.TypeIdx, RHS.NewType);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">        std::tie(RHS.Action, RHS.TypeIdx, RHS.NewType);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">using LegalityPredicate = std::function<bool (const LegalityQuery &)>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">using LegalityPredicate = std::function<bool (const LegalityQuery &)>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">using LegalizeMutation =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">using LegalizeMutation =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">    std::function<std::pair<unsigned, LLT>(const LegalityQuery &)>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">    std::function<std::pair<unsigned, LLT>(const LegalityQuery &)>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">namespace LegalityPredicates {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">namespace LegalityPredicates {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">struct TypePairAndMemDesc {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">struct TypePairAndMemDesc {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  LLT Type0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  LLT Type0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  LLT Type1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  LLT Type1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  LLT MemTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  LLT MemTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  uint64_t Align;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  uint64_t Align;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">  bool operator==(const TypePairAndMemDesc &Other) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">  bool operator==(const TypePairAndMemDesc &Other) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">    return Type0 == Other.Type0 && Type1 == Other.Type1 &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">    return Type0 == Other.Type0 && Type1 == Other.Type1 &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">           Align == Other.Align && MemTy == Other.MemTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">           Align == Other.Align && MemTy == Other.MemTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">  /// \returns true if this memory access is legal with for the access described</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">  /// \returns true if this memory access is legal with for the access described</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">  /// by \p Other (The alignment is sufficient for the size and result type).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">  /// by \p Other (The alignment is sufficient for the size and result type).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  bool isCompatible(const TypePairAndMemDesc &Other) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  bool isCompatible(const TypePairAndMemDesc &Other) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">    return Type0 == Other.Type0 && Type1 == Other.Type1 &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">    return Type0 == Other.Type0 && Type1 == Other.Type1 &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">           Align >= Other.Align &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">           Align >= Other.Align &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">           // FIXME: This perhaps should be stricter, but the current legality</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">           // FIXME: This perhaps should be stricter, but the current legality</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">           // rules are written only considering the size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">           // rules are written only considering the size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">           MemTy.getSizeInBits() == Other.MemTy.getSizeInBits();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">           MemTy.getSizeInBits() == Other.MemTy.getSizeInBits();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">/// True iff P0 and P1 are true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">/// True iff P0 and P1 are true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">template<typename Predicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">template<typename Predicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine coveredLine">Predicate all(Predicate P0, Predicate P1) {</td>
    <td class="lineNumber">50</td>
    <td class="lineNumber">228</td>
    <td class="codeLine coveredLine">Predicate all(Predicate P0, Predicate P1) {</td>
    <td class="lineNumber">50</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  return [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  return [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">    return P0(Query) && P1(Query);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">    return P0(Query) && P1(Query);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine coveredLine">  };</td>
    <td class="lineNumber">50</td>
    <td class="lineNumber">231</td>
    <td class="codeLine coveredLine">  };</td>
    <td class="lineNumber">50</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">/// True iff all given predicates are true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">/// True iff all given predicates are true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">template<typename Predicate, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">template<typename Predicate, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">Predicate all(Predicate P0, Predicate P1, Args... args) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">Predicate all(Predicate P0, Predicate P1, Args... args) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">  return all(all(P0, P1), args...);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">  return all(all(P0, P1), args...);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">/// True iff P0 or P1 are true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">/// True iff P0 or P1 are true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">template<typename Predicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">template<typename Predicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">Predicate any(Predicate P0, Predicate P1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">Predicate any(Predicate P0, Predicate P1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  return [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  return [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">    return P0(Query) || P1(Query);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">    return P0(Query) || P1(Query);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">/// True iff any given predicates are true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">/// True iff any given predicates are true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">template<typename Predicate, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">template<typename Predicate, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">Predicate any(Predicate P0, Predicate P1, Args... args) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">Predicate any(Predicate P0, Predicate P1, Args... args) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  return any(any(P0, P1), args...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  return any(any(P0, P1), args...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">/// True iff the given type index is the specified type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">/// True iff the given type index is the specified type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">LegalityPredicate typeIs(unsigned TypeIdx, LLT TypesInit);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">LegalityPredicate typeIs(unsigned TypeIdx, LLT TypesInit);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">/// True iff the given type index is one of the specified types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">/// True iff the given type index is one of the specified types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">LegalityPredicate typeInSet(unsigned TypeIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">LegalityPredicate typeInSet(unsigned TypeIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">                            std::initializer_list<LLT> TypesInit);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">                            std::initializer_list<LLT> TypesInit);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">/// True iff the given type index is not the specified type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">/// True iff the given type index is not the specified type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">inline LegalityPredicate typeIsNot(unsigned TypeIdx, LLT Type) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">inline LegalityPredicate typeIsNot(unsigned TypeIdx, LLT Type) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  return [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  return [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">           return Query.Types[TypeIdx] != Type;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">           return Query.Types[TypeIdx] != Type;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">         };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">         };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">/// True iff the given types for the given pair of type indexes is one of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">/// True iff the given types for the given pair of type indexes is one of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">/// specified type pairs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">/// specified type pairs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">LegalityPredicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">LegalityPredicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">typePairInSet(unsigned TypeIdx0, unsigned TypeIdx1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">typePairInSet(unsigned TypeIdx0, unsigned TypeIdx1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">              std::initializer_list<std::pair<LLT, LLT>> TypesInit);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">              std::initializer_list<std::pair<LLT, LLT>> TypesInit);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">/// True iff the given types for the given pair of type indexes is one of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">/// True iff the given types for the given pair of type indexes is one of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">/// specified type pairs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">/// specified type pairs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">LegalityPredicate typePairAndMemDescInSet(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">LegalityPredicate typePairAndMemDescInSet(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">    unsigned TypeIdx0, unsigned TypeIdx1, unsigned MMOIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">    unsigned TypeIdx0, unsigned TypeIdx1, unsigned MMOIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">    std::initializer_list<TypePairAndMemDesc> TypesAndMemDescInit);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">    std::initializer_list<TypePairAndMemDesc> TypesAndMemDescInit);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">/// True iff the specified type index is a scalar.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">/// True iff the specified type index is a scalar.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">LegalityPredicate isScalar(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">LegalityPredicate isScalar(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">/// True iff the specified type index is a vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">/// True iff the specified type index is a vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">LegalityPredicate isVector(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">LegalityPredicate isVector(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">/// True iff the specified type index is a pointer (with any address space).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">/// True iff the specified type index is a pointer (with any address space).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">LegalityPredicate isPointer(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">LegalityPredicate isPointer(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">/// True iff the specified type index is a pointer with the specified address</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">/// True iff the specified type index is a pointer with the specified address</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">/// space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">/// space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">LegalityPredicate isPointer(unsigned TypeIdx, unsigned AddrSpace);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">LegalityPredicate isPointer(unsigned TypeIdx, unsigned AddrSpace);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">/// True if the type index is a vector with element type \p EltTy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">/// True if the type index is a vector with element type \p EltTy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">LegalityPredicate elementTypeIs(unsigned TypeIdx, LLT EltTy);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">LegalityPredicate elementTypeIs(unsigned TypeIdx, LLT EltTy);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">/// True iff the specified type index is a scalar that's narrower than the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">/// True iff the specified type index is a scalar that's narrower than the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">/// size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">/// size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">LegalityPredicate scalarNarrowerThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">LegalityPredicate scalarNarrowerThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">/// True iff the specified type index is a scalar that's wider than the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">/// True iff the specified type index is a scalar that's wider than the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">/// size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">/// size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">LegalityPredicate scalarWiderThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">LegalityPredicate scalarWiderThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">/// True iff the specified type index is a scalar or vector with an element type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">/// True iff the specified type index is a scalar or vector with an element type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">/// that's narrower than the given size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">/// that's narrower than the given size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">LegalityPredicate scalarOrEltNarrowerThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">LegalityPredicate scalarOrEltNarrowerThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">/// True iff the specified type index is a scalar or a vector with an element</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">/// True iff the specified type index is a scalar or a vector with an element</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">/// type that's wider than the given size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">/// type that's wider than the given size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">LegalityPredicate scalarOrEltWiderThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">LegalityPredicate scalarOrEltWiderThan(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">/// True iff the specified type index is a scalar whose size is not a multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">/// True iff the specified type index is a scalar whose size is not a multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">/// of Size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">/// of Size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">LegalityPredicate sizeNotMultipleOf(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">LegalityPredicate sizeNotMultipleOf(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">/// True iff the specified type index is a scalar whose size is not a power of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">/// True iff the specified type index is a scalar whose size is not a power of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">/// 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">/// 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">LegalityPredicate sizeNotPow2(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">LegalityPredicate sizeNotPow2(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">/// True iff the specified type index is a scalar or vector whose element size</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">/// True iff the specified type index is a scalar or vector whose element size</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">/// is not a power of 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">/// is not a power of 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">LegalityPredicate scalarOrEltSizeNotPow2(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">LegalityPredicate scalarOrEltSizeNotPow2(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">/// True if the total bitwidth of the specified type index is \p Size bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">/// True if the total bitwidth of the specified type index is \p Size bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">LegalityPredicate sizeIs(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">LegalityPredicate sizeIs(unsigned TypeIdx, unsigned Size);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">/// True iff the specified type indices are both the same bit size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">/// True iff the specified type indices are both the same bit size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">LegalityPredicate sameSize(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">LegalityPredicate sameSize(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">/// True iff the first type index has a larger total bit size than second type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">/// True iff the first type index has a larger total bit size than second type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">/// index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">/// index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">LegalityPredicate largerThan(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">LegalityPredicate largerThan(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">/// True iff the first type index has a smaller total bit size than second type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">/// True iff the first type index has a smaller total bit size than second type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">/// index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">/// index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">LegalityPredicate smallerThan(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">LegalityPredicate smallerThan(unsigned TypeIdx0, unsigned TypeIdx1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">/// True iff the specified MMO index has a size (rounded to bytes) that is not a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">/// True iff the specified MMO index has a size (rounded to bytes) that is not a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">/// power of 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">/// power of 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">LegalityPredicate memSizeInBytesNotPow2(unsigned MMOIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">LegalityPredicate memSizeInBytesNotPow2(unsigned MMOIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">/// True iff the specified MMO index has a size that is not an even byte size,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">/// True iff the specified MMO index has a size that is not an even byte size,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">/// or that even byte size is not a power of 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">/// or that even byte size is not a power of 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">LegalityPredicate memSizeNotByteSizePow2(unsigned MMOIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">LegalityPredicate memSizeNotByteSizePow2(unsigned MMOIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">/// True iff the specified type index is a vector whose element count is not a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">/// True iff the specified type index is a vector whose element count is not a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">/// power of 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">/// power of 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">LegalityPredicate numElementsNotPow2(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">LegalityPredicate numElementsNotPow2(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">/// True iff the specified MMO index has at an atomic ordering of at Ordering or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">/// True iff the specified MMO index has at an atomic ordering of at Ordering or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">/// stronger.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">/// stronger.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">LegalityPredicate atomicOrderingAtLeastOrStrongerThan(unsigned MMOIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">LegalityPredicate atomicOrderingAtLeastOrStrongerThan(unsigned MMOIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">                                                      AtomicOrdering Ordering);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">                                                      AtomicOrdering Ordering);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">} // end namespace LegalityPredicates</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">} // end namespace LegalityPredicates</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">namespace LegalizeMutations {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">namespace LegalizeMutations {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">/// Select this specific type for the given type index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">/// Select this specific type for the given type index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">LegalizeMutation changeTo(unsigned TypeIdx, LLT Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">LegalizeMutation changeTo(unsigned TypeIdx, LLT Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">/// Keep the same type as the given type index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">/// Keep the same type as the given type index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">LegalizeMutation changeTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">LegalizeMutation changeTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">/// Keep the same scalar or element type as the given type index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">/// Keep the same scalar or element type as the given type index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">LegalizeMutation changeElementTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">LegalizeMutation changeElementTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">/// Keep the same scalar or element type as the given type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">/// Keep the same scalar or element type as the given type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">LegalizeMutation changeElementTo(unsigned TypeIdx, LLT Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">LegalizeMutation changeElementTo(unsigned TypeIdx, LLT Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">/// Keep the same scalar or element type as \p TypeIdx, but take the number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">/// Keep the same scalar or element type as \p TypeIdx, but take the number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">/// elements from \p FromTypeIdx.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">/// elements from \p FromTypeIdx.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">LegalizeMutation changeElementCountTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">LegalizeMutation changeElementCountTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">/// Keep the same scalar or element type as \p TypeIdx, but take the number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">/// Keep the same scalar or element type as \p TypeIdx, but take the number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">/// elements from \p Ty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">/// elements from \p Ty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">LegalizeMutation changeElementCountTo(unsigned TypeIdx, LLT Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">LegalizeMutation changeElementCountTo(unsigned TypeIdx, LLT Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">/// Change the scalar size or element size to have the same scalar size as type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">/// Change the scalar size or element size to have the same scalar size as type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">/// index \p FromIndex. Unlike changeElementTo, this discards pointer types and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">/// index \p FromIndex. Unlike changeElementTo, this discards pointer types and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">/// only changes the size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">/// only changes the size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">LegalizeMutation changeElementSizeTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">LegalizeMutation changeElementSizeTo(unsigned TypeIdx, unsigned FromTypeIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">/// Widen the scalar type or vector element type for the given type index to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">/// Widen the scalar type or vector element type for the given type index to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">/// next power of 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">/// next power of 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">LegalizeMutation widenScalarOrEltToNextPow2(unsigned TypeIdx, unsigned Min = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">LegalizeMutation widenScalarOrEltToNextPow2(unsigned TypeIdx, unsigned Min = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">/// Widen the scalar type or vector element type for the given type index to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">/// Widen the scalar type or vector element type for the given type index to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">/// next multiple of \p Size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">/// next multiple of \p Size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">LegalizeMutation widenScalarOrEltToNextMultipleOf(unsigned TypeIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">LegalizeMutation widenScalarOrEltToNextMultipleOf(unsigned TypeIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">                                                  unsigned Size);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">                                                  unsigned Size);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">/// Add more elements to the type for the given type index to the next power of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">/// Add more elements to the type for the given type index to the next power of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">/// 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">/// 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">LegalizeMutation moreElementsToNextPow2(unsigned TypeIdx, unsigned Min = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">LegalizeMutation moreElementsToNextPow2(unsigned TypeIdx, unsigned Min = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">/// Break up the vector type for the given type index into the element type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">/// Break up the vector type for the given type index into the element type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">LegalizeMutation scalarize(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">LegalizeMutation scalarize(unsigned TypeIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">} // end namespace LegalizeMutations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">} // end namespace LegalizeMutations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">/// A single rule in a legalizer info ruleset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">/// A single rule in a legalizer info ruleset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">/// The specified action is chosen when the predicate is true. Where appropriate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">/// The specified action is chosen when the predicate is true. Where appropriate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">/// for the action (e.g. for WidenScalar) the new type is selected using the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">/// for the action (e.g. for WidenScalar) the new type is selected using the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">/// given mutator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">/// given mutator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">class LegalizeRule {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">class LegalizeRule {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  LegalityPredicate Predicate;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  LegalityPredicate Predicate;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">  LegalizeAction Action;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">  LegalizeAction Action;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  LegalizeMutation Mutation;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  LegalizeMutation Mutation;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine coveredLine">  LegalizeRule(LegalityPredicate Predicate, LegalizeAction Action,</td>
    <td class="lineNumber">460</td>
    <td class="lineNumber">399</td>
    <td class="codeLine coveredLine">  LegalizeRule(LegalityPredicate Predicate, LegalizeAction Action,</td>
    <td class="lineNumber">460</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">               LegalizeMutation Mutation = nullptr)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">               LegalizeMutation Mutation = nullptr)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine coveredLine">      : Predicate(Predicate), Action(Action), Mutation(Mutation) {}</td>
    <td class="lineNumber">460</td>
    <td class="lineNumber">401</td>
    <td class="codeLine coveredLine">      : Predicate(Predicate), Action(Action), Mutation(Mutation) {}</td>
    <td class="lineNumber">460</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  /// Test whether the LegalityQuery matches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  /// Test whether the LegalityQuery matches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  bool match(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  bool match(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">    return Predicate(Query);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">    return Predicate(Query);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">  LegalizeAction getAction() const { return Action; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">  LegalizeAction getAction() const { return Action; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">  /// Determine the change to make.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">  /// Determine the change to make.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  std::pair<unsigned, LLT> determineMutation(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  std::pair<unsigned, LLT> determineMutation(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">    if (Mutation)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">    if (Mutation)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">      return Mutation(Query);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">      return Mutation(Query);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">    return std::make_pair(0, LLT{});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">    return std::make_pair(0, LLT{});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">class LegalizeRuleSet {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">class LegalizeRuleSet {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">  /// When non-zero, the opcode we are an alias of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">  /// When non-zero, the opcode we are an alias of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">  unsigned AliasOf = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">  unsigned AliasOf = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">  /// If true, there is another opcode that aliases this one</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">  /// If true, there is another opcode that aliases this one</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  bool IsAliasedByAnother = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  bool IsAliasedByAnother = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  SmallVector<LegalizeRule, 2> Rules;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  SmallVector<LegalizeRule, 2> Rules;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  /// If bit I is set, this rule set contains a rule that may handle (predicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  /// If bit I is set, this rule set contains a rule that may handle (predicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  /// or perform an action upon (or both)) the type index I. The uncertainty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  /// or perform an action upon (or both)) the type index I. The uncertainty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  /// comes from free-form rules executing user-provided lambda functions. We</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  /// comes from free-form rules executing user-provided lambda functions. We</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  /// conservatively assume such rules do the right thing and cover all type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  /// conservatively assume such rules do the right thing and cover all type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  /// indices. The bitset is intentionally 1 bit wider than it absolutely needs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  /// indices. The bitset is intentionally 1 bit wider than it absolutely needs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  /// to be to distinguish such cases from the cases where all type indices are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  /// to be to distinguish such cases from the cases where all type indices are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  /// individually handled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  /// individually handled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">  SmallBitVector TypeIdxsCovered{MCOI::OPERAND_LAST_GENERIC -</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">  SmallBitVector TypeIdxsCovered{MCOI::OPERAND_LAST_GENERIC -</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">                                 MCOI::OPERAND_FIRST_GENERIC + 2};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">                                 MCOI::OPERAND_FIRST_GENERIC + 2};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  SmallBitVector ImmIdxsCovered{MCOI::OPERAND_LAST_GENERIC_IMM -</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  SmallBitVector ImmIdxsCovered{MCOI::OPERAND_LAST_GENERIC_IMM -</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">                                MCOI::OPERAND_FIRST_GENERIC_IMM + 2};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">                                MCOI::OPERAND_FIRST_GENERIC_IMM + 2};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine coveredLine">  unsigned typeIdx(unsigned TypeIdx) {</td>
    <td class="lineNumber">535</td>
    <td class="lineNumber">439</td>
    <td class="codeLine coveredLine">  unsigned typeIdx(unsigned TypeIdx) {</td>
    <td class="lineNumber">535</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine coveredLine">    assert(TypeIdx <=</td>
    <td class="lineNumber">535</td>
    <td class="lineNumber">440</td>
    <td class="codeLine coveredLine">    assert(TypeIdx <=</td>
    <td class="lineNumber">535</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">               (MCOI::OPERAND_LAST_GENERIC - MCOI::OPERAND_FIRST_GENERIC) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">               (MCOI::OPERAND_LAST_GENERIC - MCOI::OPERAND_FIRST_GENERIC) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">           "Type Index is out of bounds");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">           "Type Index is out of bounds");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine coveredLine">    TypeIdxsCovered.set(TypeIdx);</td>
    <td class="lineNumber">535</td>
    <td class="lineNumber">444</td>
    <td class="codeLine coveredLine">    TypeIdxsCovered.set(TypeIdx);</td>
    <td class="lineNumber">535</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine coveredLine">    return TypeIdx;</td>
    <td class="lineNumber">535</td>
    <td class="lineNumber">446</td>
    <td class="codeLine coveredLine">    return TypeIdx;</td>
    <td class="lineNumber">535</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine coveredLine">  void markAllIdxsAsCovered() {</td>
    <td class="lineNumber">60</td>
    <td class="lineNumber">449</td>
    <td class="codeLine coveredLine">  void markAllIdxsAsCovered() {</td>
    <td class="lineNumber">60</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine coveredLine">    TypeIdxsCovered.set();</td>
    <td class="lineNumber">60</td>
    <td class="lineNumber">451</td>
    <td class="codeLine coveredLine">    TypeIdxsCovered.set();</td>
    <td class="lineNumber">60</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine coveredLine">    ImmIdxsCovered.set();</td>
    <td class="lineNumber">60</td>
    <td class="lineNumber">452</td>
    <td class="codeLine coveredLine">    ImmIdxsCovered.set();</td>
    <td class="lineNumber">60</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">60</td>
    <td class="lineNumber">454</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">60</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine coveredLine">  void add(const LegalizeRule &Rule) {</td>
    <td class="lineNumber">460</td>
    <td class="lineNumber">456</td>
    <td class="codeLine coveredLine">  void add(const LegalizeRule &Rule) {</td>
    <td class="lineNumber">460</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine coveredLine">    assert(AliasOf == 0 &&</td>
    <td class="lineNumber">460</td>
    <td class="lineNumber">457</td>
    <td class="codeLine coveredLine">    assert(AliasOf == 0 &&</td>
    <td class="lineNumber">460</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">           "RuleSet is aliased, change the representative opcode instead");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">           "RuleSet is aliased, change the representative opcode instead");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine coveredLine">    Rules.push_back(Rule);</td>
    <td class="lineNumber">460</td>
    <td class="lineNumber">459</td>
    <td class="codeLine coveredLine">    Rules.push_back(Rule);</td>
    <td class="lineNumber">460</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">460</td>
    <td class="lineNumber">460</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">460</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">  static bool always(const LegalityQuery &) { return true; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">  static bool always(const LegalityQuery &) { return true; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  /// Use the given action when the predicate is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  /// Use the given action when the predicate is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &actionIf(LegalizeAction Action,</td>
    <td class="lineNumber">265</td>
    <td class="lineNumber">466</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &actionIf(LegalizeAction Action,</td>
    <td class="lineNumber">265</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">                            LegalityPredicate Predicate) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">                            LegalityPredicate Predicate) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine coveredLine">    add({Predicate, Action});</td>
    <td class="lineNumber">265</td>
    <td class="lineNumber">468</td>
    <td class="codeLine coveredLine">    add({Predicate, Action});</td>
    <td class="lineNumber">265</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine coveredLine">    return *this;</td>
    <td class="lineNumber">265</td>
    <td class="lineNumber">469</td>
    <td class="codeLine coveredLine">    return *this;</td>
    <td class="lineNumber">265</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">  /// Use the given action when the predicate is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">  /// Use the given action when the predicate is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  /// Action should be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  /// Action should be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &actionIf(LegalizeAction Action, LegalityPredicate Predicate,</td>
    <td class="lineNumber">195</td>
    <td class="lineNumber">473</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &actionIf(LegalizeAction Action, LegalityPredicate Predicate,</td>
    <td class="lineNumber">195</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">                            LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">                            LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine coveredLine">    add({Predicate, Action, Mutation});</td>
    <td class="lineNumber">195</td>
    <td class="lineNumber">475</td>
    <td class="codeLine coveredLine">    add({Predicate, Action, Mutation});</td>
    <td class="lineNumber">195</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine coveredLine">    return *this;</td>
    <td class="lineNumber">195</td>
    <td class="lineNumber">476</td>
    <td class="codeLine coveredLine">    return *this;</td>
    <td class="lineNumber">195</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  /// Use the given action when type index 0 is any type in the given list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  /// Use the given action when type index 0 is any type in the given list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">70</td>
    <td class="lineNumber">480</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">70</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">                             std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">                             std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine coveredLine">    return actionIf(Action, typeInSet(typeIdx(0), Types));</td>
    <td class="lineNumber">70</td>
    <td class="lineNumber">483</td>
    <td class="codeLine coveredLine">    return actionIf(Action, typeInSet(typeIdx(0), Types));</td>
    <td class="lineNumber">70</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">  /// Use the given action when type index 0 is any type in the given list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">  /// Use the given action when type index 0 is any type in the given list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  /// Action should be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  /// Action should be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">                             std::initializer_list<LLT> Types,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">                             std::initializer_list<LLT> Types,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">                             LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">                             LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">    return actionIf(Action, typeInSet(typeIdx(0), Types), Mutation);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">    return actionIf(Action, typeInSet(typeIdx(0), Types), Mutation);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  /// Use the given action when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  /// Use the given action when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  /// given list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  /// given list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">80</td>
    <td class="lineNumber">496</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">80</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">                             std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">                             std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine coveredLine">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));</td>
    <td class="lineNumber">80</td>
    <td class="lineNumber">499</td>
    <td class="codeLine coveredLine">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));</td>
    <td class="lineNumber">80</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">  /// Use the given action when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">  /// Use the given action when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">  /// given list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">  /// given list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">  /// Action should be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">  /// Action should be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">  LegalizeRuleSet &actionFor(LegalizeAction Action,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">                             std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">                             std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">                             LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">                             LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">                    Mutation);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">                    Mutation);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  /// Use the given action when type index 0 is any type in the given list and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  /// Use the given action when type index 0 is any type in the given list and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  /// imm index 0 is anything. Action should not be an action that requires</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  /// imm index 0 is anything. Action should not be an action that requires</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">  /// mutation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">  /// mutation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  LegalizeRuleSet &actionForTypeWithAnyImm(LegalizeAction Action,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  LegalizeRuleSet &actionForTypeWithAnyImm(LegalizeAction Action,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">                                           std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">                                           std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">    immIdx(0); // Inform verifier imm idx 0 is handled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">    immIdx(0); // Inform verifier imm idx 0 is handled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">    return actionIf(Action, typeInSet(typeIdx(0), Types));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">    return actionIf(Action, typeInSet(typeIdx(0), Types));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  LegalizeRuleSet &actionForTypeWithAnyImm(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  LegalizeRuleSet &actionForTypeWithAnyImm(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">    LegalizeAction Action, std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">    LegalizeAction Action, std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">    immIdx(0); // Inform verifier imm idx 0 is handled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">    immIdx(0); // Inform verifier imm idx 0 is handled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">  /// Use the given action when type indexes 0 and 1 are both in the given list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">  /// Use the given action when type indexes 0 and 1 are both in the given list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">  /// That is, the type pair is in the cartesian product of the list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">  /// That is, the type pair is in the cartesian product of the list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  LegalizeRuleSet &actionForCartesianProduct(LegalizeAction Action,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  LegalizeRuleSet &actionForCartesianProduct(LegalizeAction Action,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">                                             std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">                                             std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">    return actionIf(Action, all(typeInSet(typeIdx(0), Types),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">    return actionIf(Action, all(typeInSet(typeIdx(0), Types),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">                                typeInSet(typeIdx(1), Types)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">                                typeInSet(typeIdx(1), Types)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  /// Use the given action when type indexes 0 and 1 are both in their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  /// Use the given action when type indexes 0 and 1 are both in their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  /// That is, the type pair is in the cartesian product of the lists</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  /// That is, the type pair is in the cartesian product of the lists</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine coveredLine">  actionForCartesianProduct(LegalizeAction Action,</td>
    <td class="lineNumber">50</td>
    <td class="lineNumber">542</td>
    <td class="codeLine coveredLine">  actionForCartesianProduct(LegalizeAction Action,</td>
    <td class="lineNumber">50</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">                            std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">                            std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine coveredLine">    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),</td>
    <td class="lineNumber">100</td>
    <td class="lineNumber">546</td>
    <td class="codeLine coveredLine">    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),</td>
    <td class="lineNumber">100</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine coveredLine">                                typeInSet(typeIdx(1), Types1)));</td>
    <td class="lineNumber">150</td>
    <td class="lineNumber">547</td>
    <td class="codeLine coveredLine">                                typeInSet(typeIdx(1), Types1)));</td>
    <td class="lineNumber">150</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// Use the given action when type indexes 0, 1, and 2 are all in their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// Use the given action when type indexes 0, 1, and 2 are all in their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">  /// That is, the type triple is in the cartesian product of the lists</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">  /// That is, the type triple is in the cartesian product of the lists</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  /// Action should not be an action that requires mutation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">  LegalizeRuleSet &actionForCartesianProduct(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">  LegalizeRuleSet &actionForCartesianProduct(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">      LegalizeAction Action, std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">      LegalizeAction Action, std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">      std::initializer_list<LLT> Types1, std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">      std::initializer_list<LLT> Types1, std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">                                all(typeInSet(typeIdx(1), Types1),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">                                all(typeInSet(typeIdx(1), Types1),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">                                    typeInSet(typeIdx(2), Types2))));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">                                    typeInSet(typeIdx(2), Types2))));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet() = default;</td>
    <td class="lineNumber">1050</td>
    <td class="lineNumber">563</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet() = default;</td>
    <td class="lineNumber">1050</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine coveredLine">  bool isAliasedByAnother() { return IsAliasedByAnother; }</td>
    <td class="lineNumber">225</td>
    <td class="lineNumber">565</td>
    <td class="codeLine coveredLine">  bool isAliasedByAnother() { return IsAliasedByAnother; }</td>
    <td class="lineNumber">225</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine coveredLine">  void setIsAliasedByAnother() { IsAliasedByAnother = true; }</td>
    <td class="lineNumber">65</td>
    <td class="lineNumber">566</td>
    <td class="codeLine coveredLine">  void setIsAliasedByAnother() { IsAliasedByAnother = true; }</td>
    <td class="lineNumber">65</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine coveredLine">  void aliasTo(unsigned Opcode) {</td>
    <td class="lineNumber">135</td>
    <td class="lineNumber">567</td>
    <td class="codeLine coveredLine">  void aliasTo(unsigned Opcode) {</td>
    <td class="lineNumber">135</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine coveredLine">    assert((AliasOf == 0 || AliasOf == Opcode) &&</td>
    <td class="lineNumber">135</td>
    <td class="lineNumber">568</td>
    <td class="codeLine coveredLine">    assert((AliasOf == 0 || AliasOf == Opcode) &&</td>
    <td class="lineNumber">135</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">           "Opcode is already aliased to another opcode");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">           "Opcode is already aliased to another opcode");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine coveredLine">    assert(Rules.empty() && "Aliasing will discard rules");</td>
    <td class="lineNumber">135</td>
    <td class="lineNumber">570</td>
    <td class="codeLine coveredLine">    assert(Rules.empty() && "Aliasing will discard rules");</td>
    <td class="lineNumber">135</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine coveredLine">    AliasOf = Opcode;</td>
    <td class="lineNumber">135</td>
    <td class="lineNumber">571</td>
    <td class="codeLine coveredLine">    AliasOf = Opcode;</td>
    <td class="lineNumber">135</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">135</td>
    <td class="lineNumber">572</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">135</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine coveredLine">  unsigned getAlias() const { return AliasOf; }</td>
    <td class="lineNumber">1410</td>
    <td class="lineNumber">573</td>
    <td class="codeLine coveredLine">  unsigned getAlias() const { return AliasOf; }</td>
    <td class="lineNumber">1410</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">  unsigned immIdx(unsigned ImmIdx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">  unsigned immIdx(unsigned ImmIdx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">    assert(ImmIdx <= (MCOI::OPERAND_LAST_GENERIC_IMM -</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">    assert(ImmIdx <= (MCOI::OPERAND_LAST_GENERIC_IMM -</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">                      MCOI::OPERAND_FIRST_GENERIC_IMM) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">                      MCOI::OPERAND_FIRST_GENERIC_IMM) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">           "Imm Index is out of bounds");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">           "Imm Index is out of bounds");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">    ImmIdxsCovered.set(ImmIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">    ImmIdxsCovered.set(ImmIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">    return ImmIdx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">    return ImmIdx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  /// The instruction is legal if predicate is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  /// The instruction is legal if predicate is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &legalIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">35</td>
    <td class="lineNumber">586</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &legalIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">35</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">    // We have no choice but conservatively assume that the free-form</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">    // We have no choice but conservatively assume that the free-form</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">    // user-provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">    // user-provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine coveredLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">35</td>
    <td class="lineNumber">589</td>
    <td class="codeLine coveredLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">35</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Legal, Predicate);</td>
    <td class="lineNumber">35</td>
    <td class="lineNumber">590</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Legal, Predicate);</td>
    <td class="lineNumber">35</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">  /// The instruction is legal when type index 0 is any type in the given list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">  /// The instruction is legal when type index 0 is any type in the given list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &legalFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">593</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &legalFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">55</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine coveredLine">    return actionFor(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">594</td>
    <td class="codeLine coveredLine">    return actionFor(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">55</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  /// The instruction is legal when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  /// The instruction is legal when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">  /// given list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">  /// given list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &legalFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">50</td>
    <td class="lineNumber">598</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &legalFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">50</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine coveredLine">    return actionFor(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">50</td>
    <td class="lineNumber">599</td>
    <td class="codeLine coveredLine">    return actionFor(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">50</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">  /// The instruction is legal when type index 0 is any type in the given list</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">  /// The instruction is legal when type index 0 is any type in the given list</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">  /// and imm index 0 is anything.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">  /// and imm index 0 is anything.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">  LegalizeRuleSet &legalForTypeWithAnyImm(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">  LegalizeRuleSet &legalForTypeWithAnyImm(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">  LegalizeRuleSet &legalForTypeWithAnyImm(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">  LegalizeRuleSet &legalForTypeWithAnyImm(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">    std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">    std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">  /// The instruction is legal when type indexes 0 and 1 along with the memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">  /// The instruction is legal when type indexes 0 and 1 along with the memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  /// size and minimum alignment is any type and size tuple in the given list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  /// size and minimum alignment is any type and size tuple in the given list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &legalForTypesWithMemDesc(</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">616</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &legalForTypesWithMemDesc(</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">      std::initializer_list<LegalityPredicates::TypePairAndMemDesc></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">      std::initializer_list<LegalityPredicates::TypePairAndMemDesc></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">          TypesAndMemDesc) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">          TypesAndMemDesc) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Legal,</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">619</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Legal,</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine coveredLine">                    LegalityPredicates::typePairAndMemDescInSet(</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">620</td>
    <td class="codeLine coveredLine">                    LegalityPredicates::typePairAndMemDescInSet(</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine coveredLine">                        typeIdx(0), typeIdx(1), /*MMOIdx*/ 0, TypesAndMemDesc));</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">621</td>
    <td class="codeLine coveredLine">                        typeIdx(0), typeIdx(1), /*MMOIdx*/ 0, TypesAndMemDesc));</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  /// The instruction is legal when type indexes 0 and 1 are both in the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  /// The instruction is legal when type indexes 0 and 1 are both in the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  /// list. That is, the type pair is in the cartesian product of the list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  /// list. That is, the type pair is in the cartesian product of the list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Legal, Types);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">  /// The instruction is legal when type indexes 0 and 1 are both their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">  /// The instruction is legal when type indexes 0 and 1 are both their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">20</td>
    <td class="lineNumber">630</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">20</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine coveredLine">    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1);</td>
    <td class="lineNumber">20</td>
    <td class="lineNumber">632</td>
    <td class="codeLine coveredLine">    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1);</td>
    <td class="lineNumber">20</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  /// The instruction is legal when type indexes 0, 1, and 2 are both their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  /// The instruction is legal when type indexes 0, 1, and 2 are both their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">                                     Types2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">                                     Types2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  LegalizeRuleSet &alwaysLegal() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  LegalizeRuleSet &alwaysLegal() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Legal, always);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Legal, always);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  /// The specified type index is coerced if predicate is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  /// The specified type index is coerced if predicate is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">  LegalizeRuleSet &bitcastIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">  LegalizeRuleSet &bitcastIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">                             LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">                             LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">    // We have no choice but conservatively assume that lowering with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">    // We have no choice but conservatively assume that lowering with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Bitcast, Predicate, Mutation);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Bitcast, Predicate, Mutation);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  /// The instruction is lowered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  /// The instruction is lowered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &lower() {</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">659</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &lower() {</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">    // We have no choice but conservatively assume that predicate-less lowering</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">    // We have no choice but conservatively assume that predicate-less lowering</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">    // properly handles all type indices by design:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">    // properly handles all type indices by design:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine coveredLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">663</td>
    <td class="codeLine coveredLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Lower, always);</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">664</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Lower, always);</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  /// The instruction is lowered if predicate is true. Keep type index 0 as the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  /// The instruction is lowered if predicate is true. Keep type index 0 as the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  /// same type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  /// same type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">668</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">    // We have no choice but conservatively assume that lowering with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">    // We have no choice but conservatively assume that lowering with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine coveredLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">672</td>
    <td class="codeLine coveredLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Lower, Predicate);</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">673</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Lower, Predicate);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">  /// The instruction is lowered if predicate is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">  /// The instruction is lowered if predicate is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">                           LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">                           LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">    // We have no choice but conservatively assume that lowering with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">    // We have no choice but conservatively assume that lowering with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Lower, Predicate, Mutation);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Lower, Predicate, Mutation);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">  /// The instruction is lowered when type index 0 is any type in the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">  /// The instruction is lowered when type index 0 is any type in the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  /// list. Keep type index 0 as the same type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  /// list. Keep type index 0 as the same type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">685</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine coveredLine">    return actionFor(LegalizeAction::Lower, Types);</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">686</td>
    <td class="codeLine coveredLine">    return actionFor(LegalizeAction::Lower, Types);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  /// The instruction is lowered when type index 0 is any type in the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  /// The instruction is lowered when type index 0 is any type in the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  /// list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  /// list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">                            LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">                            LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Lower, Types, Mutation);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Lower, Types, Mutation);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  /// The instruction is lowered when type indexes 0 and 1 is any type pair in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  /// The instruction is lowered when type indexes 0 and 1 is any type pair in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  /// the given list. Keep type index 0 as the same type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  /// the given list. Keep type index 0 as the same type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">30</td>
    <td class="lineNumber">696</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">30</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine coveredLine">    return actionFor(LegalizeAction::Lower, Types);</td>
    <td class="lineNumber">30</td>
    <td class="lineNumber">697</td>
    <td class="codeLine coveredLine">    return actionFor(LegalizeAction::Lower, Types);</td>
    <td class="lineNumber">30</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  /// The instruction is lowered when type indexes 0 and 1 is any type pair in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  /// The instruction is lowered when type indexes 0 and 1 is any type pair in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  /// the given list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  /// the given list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">                            LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">                            LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Lower, Types, Mutation);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Lower, Types, Mutation);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">  /// The instruction is lowered when type indexes 0 and 1 are both in their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">  /// The instruction is lowered when type indexes 0 and 1 are both in their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">707</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine coveredLine">    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1);</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">710</td>
    <td class="codeLine coveredLine">    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">  /// The instruction is lowered when when type indexes 0, 1, and 2 are all in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">  /// The instruction is lowered when when type indexes 0, 1, and 2 are all in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// their respective lists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// their respective lists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">                                            std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">                                     Types2);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">                                     Types2);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">  /// The instruction is emitted as a library call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">  /// The instruction is emitted as a library call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &libcall() {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">723</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &libcall() {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">    // We have no choice but conservatively assume that predicate-less lowering</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">    // We have no choice but conservatively assume that predicate-less lowering</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">    // properly handles all type indices by design:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">    // properly handles all type indices by design:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine coveredLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">727</td>
    <td class="codeLine coveredLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Libcall, always);</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">728</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Libcall, always);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">  /// Like legalIf, but for the Libcall action.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">  /// Like legalIf, but for the Libcall action.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">  LegalizeRuleSet &libcallIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">  LegalizeRuleSet &libcallIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">    // We have no choice but conservatively assume that a libcall with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">    // We have no choice but conservatively assume that a libcall with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Libcall, Predicate);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Libcall, Predicate);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &libcallFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">738</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &libcallFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine coveredLine">    return actionFor(LegalizeAction::Libcall, Types);</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">739</td>
    <td class="codeLine coveredLine">    return actionFor(LegalizeAction::Libcall, Types);</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">  libcallFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">  libcallFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Libcall, Types);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Libcall, Types);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  libcallForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  libcallForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Libcall, Types);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Libcall, Types);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine coveredLine">  libcallForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">20</td>
    <td class="lineNumber">750</td>
    <td class="codeLine coveredLine">  libcallForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">20</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">                             std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">                             std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine coveredLine">    return actionForCartesianProduct(LegalizeAction::Libcall, Types0, Types1);</td>
    <td class="lineNumber">20</td>
    <td class="lineNumber">752</td>
    <td class="codeLine coveredLine">    return actionForCartesianProduct(LegalizeAction::Libcall, Types0, Types1);</td>
    <td class="lineNumber">20</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">  /// Widen the scalar to the one selected by the mutation if the predicate is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">  /// Widen the scalar to the one selected by the mutation if the predicate is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">  LegalizeRuleSet &widenScalarIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">  LegalizeRuleSet &widenScalarIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">                                 LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">                                 LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">    return actionIf(LegalizeAction::WidenScalar, Predicate, Mutation);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">    return actionIf(LegalizeAction::WidenScalar, Predicate, Mutation);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">  /// Narrow the scalar to the one selected by the mutation if the predicate is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">  /// Narrow the scalar to the one selected by the mutation if the predicate is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">  LegalizeRuleSet &narrowScalarIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">  LegalizeRuleSet &narrowScalarIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">                                  LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">                                  LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">    return actionIf(LegalizeAction::NarrowScalar, Predicate, Mutation);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">    return actionIf(LegalizeAction::NarrowScalar, Predicate, Mutation);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">  /// Narrow the scalar, specified in mutation, when type indexes 0 and 1 is any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">  /// Narrow the scalar, specified in mutation, when type indexes 0 and 1 is any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">  /// type pair in the given list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">  /// type pair in the given list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">  narrowScalarFor(std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">  narrowScalarFor(std::initializer_list<std::pair<LLT, LLT>> Types,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">                  LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">                  LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">    return actionFor(LegalizeAction::NarrowScalar, Types, Mutation);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">    return actionFor(LegalizeAction::NarrowScalar, Types, Mutation);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">  /// Add more elements to reach the type selected by the mutation if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">  /// Add more elements to reach the type selected by the mutation if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  /// predicate is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  /// predicate is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">  LegalizeRuleSet &moreElementsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">  LegalizeRuleSet &moreElementsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">                                  LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">                                  LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">    return actionIf(LegalizeAction::MoreElements, Predicate, Mutation);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">    return actionIf(LegalizeAction::MoreElements, Predicate, Mutation);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">  /// Remove elements to reach the type selected by the mutation if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">  /// Remove elements to reach the type selected by the mutation if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">  /// predicate is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">  /// predicate is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">  LegalizeRuleSet &fewerElementsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">  LegalizeRuleSet &fewerElementsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">                                   LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">                                   LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">    // We have no choice but conservatively assume that an action with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">    return actionIf(LegalizeAction::FewerElements, Predicate, Mutation);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">    return actionIf(LegalizeAction::FewerElements, Predicate, Mutation);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">  /// The instruction is unsupported.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">  /// The instruction is unsupported.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">  LegalizeRuleSet &unsupported() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">  LegalizeRuleSet &unsupported() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Unsupported, always);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Unsupported, always);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">  LegalizeRuleSet &unsupportedIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">  LegalizeRuleSet &unsupportedIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Unsupported, Predicate);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Unsupported, Predicate);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">  LegalizeRuleSet &unsupportedFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">  LegalizeRuleSet &unsupportedFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Unsupported, Types);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Unsupported, Types);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">  LegalizeRuleSet &unsupportedIfMemSizeNotPow2() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">  LegalizeRuleSet &unsupportedIfMemSizeNotPow2() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Unsupported,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Unsupported,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">                    LegalityPredicates::memSizeInBytesNotPow2(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">                    LegalityPredicates::memSizeInBytesNotPow2(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">  /// Lower a memory operation if the memory size, rounded to bytes, is not a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">  /// Lower a memory operation if the memory size, rounded to bytes, is not a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// power of 2. For example, this will not trigger for s1 or s7, but will for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// power of 2. For example, this will not trigger for s1 or s7, but will for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  /// s24.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  /// s24.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  LegalizeRuleSet &lowerIfMemSizeNotPow2() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  LegalizeRuleSet &lowerIfMemSizeNotPow2() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Lower,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Lower,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">                    LegalityPredicates::memSizeInBytesNotPow2(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">                    LegalityPredicates::memSizeInBytesNotPow2(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  /// Lower a memory operation if the memory access size is not a round power of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  /// Lower a memory operation if the memory access size is not a round power of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">  /// 2 byte size. This is stricter than lowerIfMemSizeNotPow2, and more likely</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">  /// 2 byte size. This is stricter than lowerIfMemSizeNotPow2, and more likely</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">  /// what you want (e.g. this will lower s1, s7 and s24).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">  /// what you want (e.g. this will lower s1, s7 and s24).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  LegalizeRuleSet &lowerIfMemSizeNotByteSizePow2() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  LegalizeRuleSet &lowerIfMemSizeNotByteSizePow2() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Lower,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">    return actionIf(LegalizeAction::Lower,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">                    LegalityPredicates::memSizeNotByteSizePow2(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">                    LegalityPredicates::memSizeNotByteSizePow2(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &customIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">834</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &customIf(LegalityPredicate Predicate) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">    // We have no choice but conservatively assume that a custom action with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">    // We have no choice but conservatively assume that a custom action with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">    // free-form user provided Predicate properly handles all type indices:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine coveredLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">837</td>
    <td class="codeLine coveredLine">    markAllIdxsAsCovered();</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Custom, Predicate);</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">838</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::Custom, Predicate);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">  LegalizeRuleSet &customFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">  LegalizeRuleSet &customFor(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Custom, Types);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Custom, Types);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">  /// The instruction is custom when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">  /// The instruction is custom when type indexes 0 and 1 is any type pair in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">  /// given list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">  /// given list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  LegalizeRuleSet &customFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  LegalizeRuleSet &customFor(std::initializer_list<std::pair<LLT, LLT>> Types) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Custom, Types);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">    return actionFor(LegalizeAction::Custom, Types);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">  LegalizeRuleSet &customForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">  LegalizeRuleSet &customForCartesianProduct(std::initializer_list<LLT> Types) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Custom, Types);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Custom, Types);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  /// The instruction is custom when type indexes 0 and 1 are both in their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  /// The instruction is custom when type indexes 0 and 1 are both in their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">  /// respective lists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine coveredLine">  customForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">856</td>
    <td class="codeLine coveredLine">  customForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">                            std::initializer_list<LLT> Types1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine coveredLine">    return actionForCartesianProduct(LegalizeAction::Custom, Types0, Types1);</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">858</td>
    <td class="codeLine coveredLine">    return actionForCartesianProduct(LegalizeAction::Custom, Types0, Types1);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">  /// The instruction is custom when when type indexes 0, 1, and 2 are all in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">  /// The instruction is custom when when type indexes 0, 1, and 2 are all in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">  /// their respective lists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">  /// their respective lists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  customForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  customForCartesianProduct(std::initializer_list<LLT> Types0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">                            std::initializer_list<LLT> Types1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">                            std::initializer_list<LLT> Types1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">                            std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">                            std::initializer_list<LLT> Types2) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Custom, Types0, Types1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">    return actionForCartesianProduct(LegalizeAction::Custom, Types0, Types1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">                                     Types2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">                                     Types2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  /// Unconditionally custom lower.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  /// Unconditionally custom lower.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">  LegalizeRuleSet &custom() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">  LegalizeRuleSet &custom() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">    return customIf(always);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">    return customIf(always);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  /// Widen the scalar to the next power of two that is at least MinSize.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  /// Widen the scalar to the next power of two that is at least MinSize.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  /// No effect if the type is not a scalar or is a power of two.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  /// No effect if the type is not a scalar or is a power of two.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">  LegalizeRuleSet &widenScalarToNextPow2(unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">  LegalizeRuleSet &widenScalarToNextPow2(unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">                                         unsigned MinSize = 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">                                         unsigned MinSize = 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">        LegalizeAction::WidenScalar, sizeNotPow2(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">        LegalizeAction::WidenScalar, sizeNotPow2(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">  /// Widen the scalar to the next multiple of Size. No effect if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">  /// Widen the scalar to the next multiple of Size. No effect if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">  /// type is not a scalar or is a multiple of Size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">  /// type is not a scalar or is a multiple of Size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  LegalizeRuleSet &widenScalarToNextMultipleOf(unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  LegalizeRuleSet &widenScalarToNextMultipleOf(unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">                                               unsigned Size) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">                                               unsigned Size) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">        LegalizeAction::WidenScalar, sizeNotMultipleOf(typeIdx(TypeIdx), Size),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">        LegalizeAction::WidenScalar, sizeNotMultipleOf(typeIdx(TypeIdx), Size),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">        LegalizeMutations::widenScalarOrEltToNextMultipleOf(TypeIdx, Size));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">        LegalizeMutations::widenScalarOrEltToNextMultipleOf(TypeIdx, Size));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">  /// Widen the scalar or vector element type to the next power of two that is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">  /// Widen the scalar or vector element type to the next power of two that is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">  /// at least MinSize.  No effect if the scalar size is a power of two.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">  /// at least MinSize.  No effect if the scalar size is a power of two.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">  LegalizeRuleSet &widenScalarOrEltToNextPow2(unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">  LegalizeRuleSet &widenScalarOrEltToNextPow2(unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">                                              unsigned MinSize = 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">                                              unsigned MinSize = 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">        LegalizeAction::WidenScalar, scalarOrEltSizeNotPow2(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">        LegalizeAction::WidenScalar, scalarOrEltSizeNotPow2(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">  LegalizeRuleSet &narrowScalar(unsigned TypeIdx, LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">  LegalizeRuleSet &narrowScalar(unsigned TypeIdx, LegalizeMutation Mutation) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">    return actionIf(LegalizeAction::NarrowScalar, isScalar(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">    return actionIf(LegalizeAction::NarrowScalar, isScalar(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">                    Mutation);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">                    Mutation);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">  LegalizeRuleSet &scalarize(unsigned TypeIdx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">  LegalizeRuleSet &scalarize(unsigned TypeIdx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">    return actionIf(LegalizeAction::FewerElements, isVector(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">    return actionIf(LegalizeAction::FewerElements, isVector(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">                    LegalizeMutations::scalarize(TypeIdx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">                    LegalizeMutations::scalarize(TypeIdx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">  LegalizeRuleSet &scalarizeIf(LegalityPredicate Predicate, unsigned TypeIdx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">  LegalizeRuleSet &scalarizeIf(LegalityPredicate Predicate, unsigned TypeIdx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">    return actionIf(LegalizeAction::FewerElements,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">    return actionIf(LegalizeAction::FewerElements,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">                    all(Predicate, isVector(typeIdx(TypeIdx))),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">                    all(Predicate, isVector(typeIdx(TypeIdx))),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">                    LegalizeMutations::scalarize(TypeIdx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">                    LegalizeMutations::scalarize(TypeIdx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">  /// Ensure the scalar or element is at least as wide as Ty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">  /// Ensure the scalar or element is at least as wide as Ty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">  LegalizeRuleSet &minScalarOrElt(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">  LegalizeRuleSet &minScalarOrElt(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">                    scalarOrEltNarrowerThan(TypeIdx, Ty.getScalarSizeInBits()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">                    scalarOrEltNarrowerThan(TypeIdx, Ty.getScalarSizeInBits()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">  /// Ensure the scalar or element is at least as wide as Ty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">  /// Ensure the scalar or element is at least as wide as Ty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">  LegalizeRuleSet &minScalarOrEltIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">  LegalizeRuleSet &minScalarOrEltIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">                                    unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">                                    unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">                    all(Predicate, scalarOrEltNarrowerThan(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">                    all(Predicate, scalarOrEltNarrowerThan(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">                                       TypeIdx, Ty.getScalarSizeInBits())),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">                                       TypeIdx, Ty.getScalarSizeInBits())),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">  /// Ensure the vector size is at least as wide as VectorSize by promoting the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">  /// Ensure the vector size is at least as wide as VectorSize by promoting the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">  /// element.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">  /// element.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">  LegalizeRuleSet &widenVectorEltsToVectorMinSize(unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">  LegalizeRuleSet &widenVectorEltsToVectorMinSize(unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">                                                  unsigned VectorSize) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">                                                  unsigned VectorSize) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">        LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">        LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">          const LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">          const LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">          return VecTy.isVector() && !VecTy.isScalable() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">          return VecTy.isVector() && !VecTy.isScalable() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">                 VecTy.getSizeInBits() < VectorSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">                 VecTy.getSizeInBits() < VectorSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">          const LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">          const LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">          unsigned NumElts = VecTy.getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">          unsigned NumElts = VecTy.getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">          unsigned MinSize = VectorSize / NumElts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">          unsigned MinSize = VectorSize / NumElts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">          LLT NewTy = LLT::fixed_vector(NumElts, LLT::scalar(MinSize));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">          LLT NewTy = LLT::fixed_vector(NumElts, LLT::scalar(MinSize));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">          return std::make_pair(TypeIdx, NewTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">          return std::make_pair(TypeIdx, NewTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// Ensure the scalar is at least as wide as Ty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// Ensure the scalar is at least as wide as Ty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &minScalar(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">105</td>
    <td class="lineNumber">967</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &minScalar(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">105</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">105</td>
    <td class="lineNumber">970</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">105</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine coveredLine">                    scalarNarrowerThan(TypeIdx, Ty.getSizeInBits()),</td>
    <td class="lineNumber">210</td>
    <td class="lineNumber">971</td>
    <td class="codeLine coveredLine">                    scalarNarrowerThan(TypeIdx, Ty.getSizeInBits()),</td>
    <td class="lineNumber">210</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine coveredLine">                    changeTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">315</td>
    <td class="lineNumber">972</td>
    <td class="codeLine coveredLine">                    changeTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">315</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">  /// Ensure the scalar is at least as wide as Ty if condition is met.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">  /// Ensure the scalar is at least as wide as Ty if condition is met.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">  LegalizeRuleSet &minScalarIf(LegalityPredicate Predicate, unsigned TypeIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">  LegalizeRuleSet &minScalarIf(LegalityPredicate Predicate, unsigned TypeIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">                               const LLT Ty) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">                               const LLT Ty) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">        LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">        LegalizeAction::WidenScalar,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">          const LLT QueryTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">          const LLT QueryTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">          return QueryTy.isScalar() &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">          return QueryTy.isScalar() &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">                 QueryTy.getSizeInBits() < Ty.getSizeInBits() &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">                 QueryTy.getSizeInBits() < Ty.getSizeInBits() &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">                 Predicate(Query);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">                 Predicate(Query);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">        changeTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">        changeTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">  /// Ensure the scalar is at most as wide as Ty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">  /// Ensure the scalar is at most as wide as Ty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">  LegalizeRuleSet &maxScalarOrElt(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">  LegalizeRuleSet &maxScalarOrElt(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">    return actionIf(LegalizeAction::NarrowScalar,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">    return actionIf(LegalizeAction::NarrowScalar,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">                    scalarOrEltWiderThan(TypeIdx, Ty.getScalarSizeInBits()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">                    scalarOrEltWiderThan(TypeIdx, Ty.getScalarSizeInBits()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">                    changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">  /// Ensure the scalar is at most as wide as Ty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">  /// Ensure the scalar is at most as wide as Ty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &maxScalar(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">90</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &maxScalar(unsigned TypeIdx, const LLT Ty) {</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::NarrowScalar,</td>
    <td class="lineNumber">90</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine coveredLine">    return actionIf(LegalizeAction::NarrowScalar,</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine coveredLine">                    scalarWiderThan(TypeIdx, Ty.getSizeInBits()),</td>
    <td class="lineNumber">180</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine coveredLine">                    scalarWiderThan(TypeIdx, Ty.getSizeInBits()),</td>
    <td class="lineNumber">180</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine coveredLine">                    changeTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">270</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine coveredLine">                    changeTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">270</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">  /// Conditionally limit the maximum size of the scalar.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">  /// Conditionally limit the maximum size of the scalar.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">  /// For example, when the maximum size of one type depends on the size of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">  /// For example, when the maximum size of one type depends on the size of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">  /// another such as extracting N bits from an M bit container.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">  /// another such as extracting N bits from an M bit container.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">  LegalizeRuleSet &maxScalarIf(LegalityPredicate Predicate, unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">  LegalizeRuleSet &maxScalarIf(LegalityPredicate Predicate, unsigned TypeIdx,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">                               const LLT Ty) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">                               const LLT Ty) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">    using namespace LegalizeMutations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">        LegalizeAction::NarrowScalar,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">        LegalizeAction::NarrowScalar,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">          const LLT QueryTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">          const LLT QueryTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">          return QueryTy.isScalar() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">          return QueryTy.isScalar() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">                 QueryTy.getSizeInBits() > Ty.getSizeInBits() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">                 QueryTy.getSizeInBits() > Ty.getSizeInBits() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">                 Predicate(Query);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">                 Predicate(Query);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">        changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">        changeElementTo(typeIdx(TypeIdx), Ty));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  /// Limit the range of scalar sizes to MinTy and MaxTy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  /// Limit the range of scalar sizes to MinTy and MaxTy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &clampScalar(unsigned TypeIdx, const LLT MinTy,</td>
    <td class="lineNumber">45</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine coveredLine">  LegalizeRuleSet &clampScalar(unsigned TypeIdx, const LLT MinTy,</td>
    <td class="lineNumber">45</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">                               const LLT MaxTy) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">                               const LLT MaxTy) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine coveredLine">    assert(MinTy.isScalar() && MaxTy.isScalar() && "Expected scalar types");</td>
    <td class="lineNumber">45</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine coveredLine">    assert(MinTy.isScalar() && MaxTy.isScalar() && "Expected scalar types");</td>
    <td class="lineNumber">45</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine coveredLine">    return minScalar(TypeIdx, MinTy).maxScalar(TypeIdx, MaxTy);</td>
    <td class="lineNumber">45</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine coveredLine">    return minScalar(TypeIdx, MinTy).maxScalar(TypeIdx, MaxTy);</td>
    <td class="lineNumber">45</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">  /// Limit the range of scalar sizes to MinTy and MaxTy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">  /// Limit the range of scalar sizes to MinTy and MaxTy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">  LegalizeRuleSet &clampScalarOrElt(unsigned TypeIdx, const LLT MinTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">  LegalizeRuleSet &clampScalarOrElt(unsigned TypeIdx, const LLT MinTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">                                    const LLT MaxTy) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">                                    const LLT MaxTy) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">    return minScalarOrElt(TypeIdx, MinTy).maxScalarOrElt(TypeIdx, MaxTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">    return minScalarOrElt(TypeIdx, MinTy).maxScalarOrElt(TypeIdx, MaxTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">  /// Widen the scalar to match the size of another.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">  /// Widen the scalar to match the size of another.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">  LegalizeRuleSet &minScalarSameAs(unsigned TypeIdx, unsigned LargeTypeIdx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">  LegalizeRuleSet &minScalarSameAs(unsigned TypeIdx, unsigned LargeTypeIdx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">    return widenScalarIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">    return widenScalarIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">          return Query.Types[LargeTypeIdx].getScalarSizeInBits() ></td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">          return Query.Types[LargeTypeIdx].getScalarSizeInBits() ></td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">                 Query.Types[TypeIdx].getSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">                 Query.Types[TypeIdx].getSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">        LegalizeMutations::changeElementSizeTo(TypeIdx, LargeTypeIdx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">        LegalizeMutations::changeElementSizeTo(TypeIdx, LargeTypeIdx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">  /// Narrow the scalar to match the size of another.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">  /// Narrow the scalar to match the size of another.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">  LegalizeRuleSet &maxScalarSameAs(unsigned TypeIdx, unsigned NarrowTypeIdx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">  LegalizeRuleSet &maxScalarSameAs(unsigned TypeIdx, unsigned NarrowTypeIdx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">    return narrowScalarIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">    return narrowScalarIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">          return Query.Types[NarrowTypeIdx].getScalarSizeInBits() <</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">          return Query.Types[NarrowTypeIdx].getScalarSizeInBits() <</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">                 Query.Types[TypeIdx].getSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">                 Query.Types[TypeIdx].getSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">        LegalizeMutations::changeElementSizeTo(TypeIdx, NarrowTypeIdx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">        LegalizeMutations::changeElementSizeTo(TypeIdx, NarrowTypeIdx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  /// Change the type \p TypeIdx to have the same scalar size as type \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  /// Change the type \p TypeIdx to have the same scalar size as type \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">  /// SameSizeIdx.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">  /// SameSizeIdx.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">  LegalizeRuleSet &scalarSameSizeAs(unsigned TypeIdx, unsigned SameSizeIdx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">  LegalizeRuleSet &scalarSameSizeAs(unsigned TypeIdx, unsigned SameSizeIdx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">    return minScalarSameAs(TypeIdx, SameSizeIdx)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">    return minScalarSameAs(TypeIdx, SameSizeIdx)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">          .maxScalarSameAs(TypeIdx, SameSizeIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">          .maxScalarSameAs(TypeIdx, SameSizeIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">  /// Conditionally widen the scalar or elt to match the size of another.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">  /// Conditionally widen the scalar or elt to match the size of another.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">  LegalizeRuleSet &minScalarEltSameAsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">  LegalizeRuleSet &minScalarEltSameAsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">                                   unsigned TypeIdx, unsigned LargeTypeIdx) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">                                   unsigned TypeIdx, unsigned LargeTypeIdx) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">    return widenScalarIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">    return widenScalarIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">          return Query.Types[LargeTypeIdx].getScalarSizeInBits() ></td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">          return Query.Types[LargeTypeIdx].getScalarSizeInBits() ></td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">                     Query.Types[TypeIdx].getScalarSizeInBits() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">                     Query.Types[TypeIdx].getScalarSizeInBits() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">                 Predicate(Query);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">                 Predicate(Query);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">          LLT T = Query.Types[LargeTypeIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">          LLT T = Query.Types[LargeTypeIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">          if (T.isVector() && T.getElementType().isPointer())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">          if (T.isVector() && T.getElementType().isPointer())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">            T = T.changeElementType(LLT::scalar(T.getScalarSizeInBits()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">            T = T.changeElementType(LLT::scalar(T.getScalarSizeInBits()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">          return std::make_pair(TypeIdx, T);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">          return std::make_pair(TypeIdx, T);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">  /// Conditionally narrow the scalar or elt to match the size of another.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">  /// Conditionally narrow the scalar or elt to match the size of another.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  LegalizeRuleSet &maxScalarEltSameAsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  LegalizeRuleSet &maxScalarEltSameAsIf(LegalityPredicate Predicate,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">                                        unsigned TypeIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">                                        unsigned TypeIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">                                        unsigned SmallTypeIdx) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">                                        unsigned SmallTypeIdx) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">    return narrowScalarIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">    return narrowScalarIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">          return Query.Types[SmallTypeIdx].getScalarSizeInBits() <</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">          return Query.Types[SmallTypeIdx].getScalarSizeInBits() <</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">                     Query.Types[TypeIdx].getScalarSizeInBits() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">                     Query.Types[TypeIdx].getScalarSizeInBits() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">                 Predicate(Query);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">                 Predicate(Query);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">          LLT T = Query.Types[SmallTypeIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">          LLT T = Query.Types[SmallTypeIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">          return std::make_pair(TypeIdx, T);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">          return std::make_pair(TypeIdx, T);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">  /// Add more elements to the vector to reach the next power of two.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">  /// Add more elements to the vector to reach the next power of two.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  /// No effect if the type is not a vector or the element count is a power of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  /// No effect if the type is not a vector or the element count is a power of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">  /// two.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">  /// two.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">  LegalizeRuleSet &moreElementsToNextPow2(unsigned TypeIdx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">  LegalizeRuleSet &moreElementsToNextPow2(unsigned TypeIdx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">    using namespace LegalityPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">    return actionIf(LegalizeAction::MoreElements,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">    return actionIf(LegalizeAction::MoreElements,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">                    numElementsNotPow2(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">                    numElementsNotPow2(typeIdx(TypeIdx)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">                    LegalizeMutations::moreElementsToNextPow2(TypeIdx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">                    LegalizeMutations::moreElementsToNextPow2(TypeIdx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  /// Limit the number of elements in EltTy vectors to at least MinElements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  /// Limit the number of elements in EltTy vectors to at least MinElements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">  LegalizeRuleSet &clampMinNumElements(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">  LegalizeRuleSet &clampMinNumElements(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">                                       unsigned MinElements) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">                                       unsigned MinElements) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">    // Mark the type index as covered:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">    // Mark the type index as covered:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">        LegalizeAction::MoreElements,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">        LegalizeAction::MoreElements,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">                 VecTy.getNumElements() < MinElements;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">                 VecTy.getNumElements() < MinElements;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">          return std::make_pair(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">          return std::make_pair(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">              TypeIdx, LLT::fixed_vector(MinElements, VecTy.getElementType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">              TypeIdx, LLT::fixed_vector(MinElements, VecTy.getElementType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">  /// Set number of elements to nearest larger multiple of NumElts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">  /// Set number of elements to nearest larger multiple of NumElts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">  LegalizeRuleSet &alignNumElementsTo(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">  LegalizeRuleSet &alignNumElementsTo(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">                                      unsigned NumElts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">                                      unsigned NumElts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">        LegalizeAction::MoreElements,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">        LegalizeAction::MoreElements,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">                 (VecTy.getNumElements() % NumElts != 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">                 (VecTy.getNumElements() % NumElts != 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">          unsigned NewSize = alignTo(VecTy.getNumElements(), NumElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">          unsigned NewSize = alignTo(VecTy.getNumElements(), NumElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">          return std::make_pair(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">          return std::make_pair(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">              TypeIdx, LLT::fixed_vector(NewSize, VecTy.getElementType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">              TypeIdx, LLT::fixed_vector(NewSize, VecTy.getElementType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">  /// Limit the number of elements in EltTy vectors to at most MaxElements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">  /// Limit the number of elements in EltTy vectors to at most MaxElements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">  LegalizeRuleSet &clampMaxNumElements(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">  LegalizeRuleSet &clampMaxNumElements(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">                                       unsigned MaxElements) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">                                       unsigned MaxElements) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">    // Mark the type index as covered:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">    // Mark the type index as covered:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">    typeIdx(TypeIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">    return actionIf(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">        LegalizeAction::FewerElements,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">        LegalizeAction::FewerElements,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">          return VecTy.isVector() && VecTy.getElementType() == EltTy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">                 VecTy.getNumElements() > MaxElements;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">                 VecTy.getNumElements() > MaxElements;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">        },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">        [=](const LegalityQuery &Query) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">          LLT VecTy = Query.Types[TypeIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">          LLT NewTy = LLT::scalarOrVector(ElementCount::getFixed(MaxElements),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">          LLT NewTy = LLT::scalarOrVector(ElementCount::getFixed(MaxElements),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">                                          VecTy.getElementType());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">                                          VecTy.getElementType());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">          return std::make_pair(TypeIdx, NewTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">          return std::make_pair(TypeIdx, NewTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  /// Limit the number of elements for the given vectors to at least MinTy's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  /// Limit the number of elements for the given vectors to at least MinTy's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  /// number of elements and at most MaxTy's number of elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  /// number of elements and at most MaxTy's number of elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">  /// No effect if the type is not a vector or does not have the same element</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">  /// No effect if the type is not a vector or does not have the same element</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">  /// type as the constraints.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">  /// type as the constraints.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">  /// The element type of MinTy and MaxTy must match.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">  /// The element type of MinTy and MaxTy must match.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">  LegalizeRuleSet &clampNumElements(unsigned TypeIdx, const LLT MinTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">  LegalizeRuleSet &clampNumElements(unsigned TypeIdx, const LLT MinTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">                                    const LLT MaxTy) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">                                    const LLT MaxTy) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">    assert(MinTy.getElementType() == MaxTy.getElementType() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">    assert(MinTy.getElementType() == MaxTy.getElementType() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">           "Expected element types to agree");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">           "Expected element types to agree");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">    const LLT EltTy = MinTy.getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">    const LLT EltTy = MinTy.getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">    return clampMinNumElements(TypeIdx, EltTy, MinTy.getNumElements())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">    return clampMinNumElements(TypeIdx, EltTy, MinTy.getNumElements())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">        .clampMaxNumElements(TypeIdx, EltTy, MaxTy.getNumElements());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">        .clampMaxNumElements(TypeIdx, EltTy, MaxTy.getNumElements());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">  /// Express \p EltTy vectors strictly using vectors with \p NumElts elements</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">  /// Express \p EltTy vectors strictly using vectors with \p NumElts elements</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">  /// (or scalars when \p NumElts equals 1).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">  /// (or scalars when \p NumElts equals 1).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  /// First pad with undef elements to nearest larger multiple of \p NumElts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  /// First pad with undef elements to nearest larger multiple of \p NumElts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">  /// Then perform split with all sub-instructions having the same type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">  /// Then perform split with all sub-instructions having the same type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">  /// Using clampMaxNumElements (non-strict) can result in leftover instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">  /// Using clampMaxNumElements (non-strict) can result in leftover instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">  /// with different type (fewer elements then \p NumElts or scalar).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">  /// with different type (fewer elements then \p NumElts or scalar).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">  /// No effect if the type is not a vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">  /// No effect if the type is not a vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">  LegalizeRuleSet &clampMaxNumElementsStrict(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">  LegalizeRuleSet &clampMaxNumElementsStrict(unsigned TypeIdx, const LLT EltTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">                                             unsigned NumElts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">                                             unsigned NumElts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">    return alignNumElementsTo(TypeIdx, EltTy, NumElts)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">    return alignNumElementsTo(TypeIdx, EltTy, NumElts)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">        .clampMaxNumElements(TypeIdx, EltTy, NumElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">        .clampMaxNumElements(TypeIdx, EltTy, NumElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">  /// Fallback on the previous implementation. This should only be used while</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">  /// Fallback on the previous implementation. This should only be used while</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">  /// porting a rule.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">  /// porting a rule.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">  LegalizeRuleSet &fallback() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">  LegalizeRuleSet &fallback() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">    add({always, LegalizeAction::UseLegacyRules});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">    add({always, LegalizeAction::UseLegacyRules});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">  /// Check if there is no type index which is obviously not handled by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">  /// Check if there is no type index which is obviously not handled by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">  /// LegalizeRuleSet in any way at all.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">  /// LegalizeRuleSet in any way at all.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">  /// \pre Type indices of the opcode form a dense [0, \p NumTypeIdxs) set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">  /// \pre Type indices of the opcode form a dense [0, \p NumTypeIdxs) set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">  bool verifyTypeIdxsCoverage(unsigned NumTypeIdxs) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">  bool verifyTypeIdxsCoverage(unsigned NumTypeIdxs) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">  /// Check if there is no imm index which is obviously not handled by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">  /// Check if there is no imm index which is obviously not handled by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">  /// LegalizeRuleSet in any way at all.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">  /// LegalizeRuleSet in any way at all.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">  /// \pre Type indices of the opcode form a dense [0, \p NumTypeIdxs) set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">  /// \pre Type indices of the opcode form a dense [0, \p NumTypeIdxs) set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  bool verifyImmIdxsCoverage(unsigned NumImmIdxs) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  bool verifyImmIdxsCoverage(unsigned NumImmIdxs) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">  /// Apply the ruleset to the given LegalityQuery.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">  /// Apply the ruleset to the given LegalityQuery.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">  LegalizeActionStep apply(const LegalityQuery &Query) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">  LegalizeActionStep apply(const LegalityQuery &Query) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">class LegalizerInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">class LegalizerInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine coveredLine">  virtual ~LegalizerInfo() = default;</td>
    <td class="lineNumber">1055</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine coveredLine">  virtual ~LegalizerInfo() = default;</td>
    <td class="lineNumber">1055</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  const LegacyLegalizerInfo &getLegacyLegalizerInfo() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  const LegacyLegalizerInfo &getLegacyLegalizerInfo() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">    return LegacyInfo;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">    return LegacyInfo;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine coveredLine">  LegacyLegalizerInfo &getLegacyLegalizerInfo() { return LegacyInfo; }</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine coveredLine">  LegacyLegalizerInfo &getLegacyLegalizerInfo() { return LegacyInfo; }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">  unsigned getOpcodeIdxForOpcode(unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">  unsigned getOpcodeIdxForOpcode(unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  unsigned getActionDefinitionsIdx(unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  unsigned getActionDefinitionsIdx(unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  /// Perform simple self-diagnostic and assert if there is anything obviously</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  /// Perform simple self-diagnostic and assert if there is anything obviously</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">  /// wrong with the actions set up.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">  /// wrong with the actions set up.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">  void verify(const MCInstrInfo &MII) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">  void verify(const MCInstrInfo &MII) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">  /// Get the action definitions for the given opcode. Use this to run a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">  /// Get the action definitions for the given opcode. Use this to run a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  /// LegalityQuery through the definitions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  /// LegalityQuery through the definitions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">  const LegalizeRuleSet &getActionDefinitions(unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">  const LegalizeRuleSet &getActionDefinitions(unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">  /// Get the action definition builder for the given opcode. Use this to define</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">  /// Get the action definition builder for the given opcode. Use this to define</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  /// the action definitions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  /// the action definitions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">  /// It is an error to request an opcode that has already been requested by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">  /// It is an error to request an opcode that has already been requested by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">  /// multiple-opcode variant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">  /// multiple-opcode variant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">  LegalizeRuleSet &getActionDefinitionsBuilder(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">  LegalizeRuleSet &getActionDefinitionsBuilder(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">  /// Get the action definition builder for the given set of opcodes. Use this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">  /// Get the action definition builder for the given set of opcodes. Use this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">  /// to define the action definitions for multiple opcodes at once. The first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">  /// to define the action definitions for multiple opcodes at once. The first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">  /// opcode given will be considered the representative opcode and will hold</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">  /// opcode given will be considered the representative opcode and will hold</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">  /// the definitions whereas the other opcodes will be configured to refer to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">  /// the definitions whereas the other opcodes will be configured to refer to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  /// the representative opcode. This lowers memory requirements and very</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  /// the representative opcode. This lowers memory requirements and very</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">  /// slightly improves performance.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">  /// slightly improves performance.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">  /// It would be very easy to introduce unexpected side-effects as a result of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">  /// It would be very easy to introduce unexpected side-effects as a result of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">  /// this aliasing if it were permitted to request different but intersecting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">  /// this aliasing if it were permitted to request different but intersecting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  /// sets of opcodes but that is difficult to keep track of. It is therefore an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  /// sets of opcodes but that is difficult to keep track of. It is therefore an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">  /// error to request the same opcode twice using this API, to request an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">  /// error to request the same opcode twice using this API, to request an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  /// opcode that already has definitions, or to use the single-opcode API on an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  /// opcode that already has definitions, or to use the single-opcode API on an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">  /// opcode that has already been requested by this API.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">  /// opcode that has already been requested by this API.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  LegalizeRuleSet &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  getActionDefinitionsBuilder(std::initializer_list<unsigned> Opcodes);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  getActionDefinitionsBuilder(std::initializer_list<unsigned> Opcodes);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">  void aliasActionDefinitions(unsigned OpcodeTo, unsigned OpcodeFrom);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">  void aliasActionDefinitions(unsigned OpcodeTo, unsigned OpcodeFrom);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">  /// Determine what action should be taken to legalize the described</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">  /// Determine what action should be taken to legalize the described</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">  /// instruction. Requires computeTables to have been called.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">  /// instruction. Requires computeTables to have been called.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">  /// \returns a description of the next legalization step to perform.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">  /// \returns a description of the next legalization step to perform.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">  LegalizeActionStep getAction(const LegalityQuery &Query) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">  LegalizeActionStep getAction(const LegalityQuery &Query) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">  /// Determine what action should be taken to legalize the given generic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">  /// Determine what action should be taken to legalize the given generic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">  /// instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">  /// instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">  /// \returns a description of the next legalization step to perform.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">  /// \returns a description of the next legalization step to perform.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  LegalizeActionStep getAction(const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  LegalizeActionStep getAction(const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">                               const MachineRegisterInfo &MRI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">                               const MachineRegisterInfo &MRI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">  bool isLegal(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">  bool isLegal(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">    return getAction(Query).Action == LegalizeAction::Legal;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">    return getAction(Query).Action == LegalizeAction::Legal;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  bool isLegalOrCustom(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  bool isLegalOrCustom(const LegalityQuery &Query) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">    auto Action = getAction(Query).Action;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">    auto Action = getAction(Query).Action;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">    return Action == LegalizeAction::Legal || Action == LegalizeAction::Custom;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">    return Action == LegalizeAction::Legal || Action == LegalizeAction::Custom;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">  bool isLegal(const MachineInstr &MI, const MachineRegisterInfo &MRI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">  bool isLegal(const MachineInstr &MI, const MachineRegisterInfo &MRI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  bool isLegalOrCustom(const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  bool isLegalOrCustom(const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">                       const MachineRegisterInfo &MRI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">                       const MachineRegisterInfo &MRI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">  /// Called for instructions with the Custom LegalizationAction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">  /// Called for instructions with the Custom LegalizationAction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">  virtual bool legalizeCustom(LegalizerHelper &Helper,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">  virtual bool legalizeCustom(LegalizerHelper &Helper,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">                              MachineInstr &MI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">                              MachineInstr &MI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">    llvm_unreachable("must implement this if custom action is used");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">    llvm_unreachable("must implement this if custom action is used");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">  /// \returns true if MI is either legal or has been legalized and false if not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">  /// \returns true if MI is either legal or has been legalized and false if not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">  /// legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">  /// legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">  /// Return true if MI is either legal or has been legalized and false</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">  /// Return true if MI is either legal or has been legalized and false</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">  /// if not legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">  /// if not legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">  virtual bool legalizeIntrinsic(LegalizerHelper &Helper,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">  virtual bool legalizeIntrinsic(LegalizerHelper &Helper,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">                                 MachineInstr &MI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">                                 MachineInstr &MI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">  /// Return the opcode (SEXT/ZEXT/ANYEXT) that should be performed while</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">  /// Return the opcode (SEXT/ZEXT/ANYEXT) that should be performed while</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">  /// widening a constant of type SmallTy which targets can override.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">  /// widening a constant of type SmallTy which targets can override.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">  /// For eg, the DAG does (SmallTy.isByteSized() ? G_SEXT : G_ZEXT) which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">  /// For eg, the DAG does (SmallTy.isByteSized() ? G_SEXT : G_ZEXT) which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">  /// will be the default.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">  /// will be the default.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">  virtual unsigned getExtOpcodeForWideningConstant(LLT SmallTy) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">  virtual unsigned getExtOpcodeForWideningConstant(LLT SmallTy) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">  static const int FirstOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_START;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">  static const int FirstOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_START;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  static const int LastOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_END;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  static const int LastOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_END;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">  LegalizeRuleSet RulesForOpcode[LastOp - FirstOp + 1];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">  LegalizeRuleSet RulesForOpcode[LastOp - FirstOp + 1];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">  LegacyLegalizerInfo LegacyInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">  LegacyLegalizerInfo LegacyInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">/// Checks that MIR is fully legal, returns an illegal instruction if it's not,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">/// Checks that MIR is fully legal, returns an illegal instruction if it's not,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">/// nullptr otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">/// nullptr otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">const MachineInstr *machineFunctionIsIllegal(const MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">const MachineInstr *machineFunctionIsIllegal(const MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">} // end namespace llvm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">} // end namespace llvm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">#endif // LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">#endif // LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>